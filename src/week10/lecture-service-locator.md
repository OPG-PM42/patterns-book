# Service Locator — паттерн для получения и инверсии зависимостей

## Введение

Паттерн **Service Locator** — один из способов реализовать инверсию зависимостей (Dependency Inversion) из принципов SOLID.

Перед изучением этой темы рекомендуется ознакомиться с принципом инверсии зависимостей (буква **D** в SOLID). Его суть в том, что модули не должны напрямую зависеть друг от друга — оба должны зависеть от абстракций (интерфейсов), а не от конкретных реализаций.

Есть два основных пути развязать модули:

- Через систему модульности (CommonJS, ESM)
- Через паттерн Service Locator

---

## Паттерн Service Locator

**Service Locator** — это объект (реестр), который хранит коллекцию зависимостей (классов, функций, модулей) и позволяет получать их по имени. Вместо того чтобы один модуль напрямую импортировал другой, он обращается к локатору и получает нужную реализацию оттуда.

Ключевая идея: потребитель зависимости не знает, откуда берётся реализация. Локатор скрывает эту деталь.

Что важно понять сразу — `require` и `import` сами по себе являются сервис-локаторами:

- `require` хранит внутренний кэш: ключи — полные пути к файлам, значения — то, что они экспортируют.
- При повторном вызове `require('logger')` модуль не перезапускается — значение берётся из кэша.
- В кэш `require` можно вручную записать подменённое значение по имени модуля.
- В случае `import` (ESM) такой ручной подмены нет — кэш недоступен напрямую.

---

## Реализация

### Вариант 1 — Простой экспорт Map

Самая минимальная реализация: экспортировать экземпляр `Map` из файла.

```js
// serviceLocator.js

// Создаём общий реестр зависимостей
const locator = new Map();

export default locator;
```

```js
// bootstrap.js — регистрация зависимостей при старте приложения
import locator from './serviceLocator.js';
import Logger from './Logger.js';
import Database from './Database.js';

locator.set('logger', Logger);
locator.set('db', Database);
```

```js
// someModule.js — использование зависимости
import locator from './serviceLocator.js';

const Logger = locator.get('logger');
const logger = new Logger();
logger.log('Модуль запущен');
```

Проблема этого варианта: снаружи открыт полный доступ к `Map`. Любой модуль может добавлять, удалять или перезаписывать зависимости произвольно.

---

### Вариант 2 — Фасад через стрелочные функции

Чтобы ограничить доступ и выставить наружу только `get` и `set`, оборачиваем Map в фасад из двух функций.

```js
// serviceLocator.js

const _registry = new Map();

// Экспортируем только два метода — публичный интерфейс локатора
export const get = (key) => _registry.get(key);
export const set = (key, value) => _registry.set(key, value);
```

```js
// bootstrap.js
import { set } from './serviceLocator.js';
import Logger from './Logger.js';

set('logger', Logger);
```

```js
// someModule.js
import { get } from './serviceLocator.js';

const Logger = get('logger');
const logger = new Logger();
logger.log('Готово');
```

---

### Вариант 3 — Привязка методов через bind (без новых функций)

Вместо того чтобы создавать новые стрелочные функции, можно взять методы `get` и `set` у экземпляра `Map` и привязать их к самому экземпляру через `bind`. Новые функции при этом не создаются — переиспользуются встроенные.

```js
// serviceLocator.js

const _registry = new Map();

// bind привязывает метод к конкретному экземпляру Map
// без этого this внутри get/set не будет указывать на _registry
export const get = _registry.get.bind(_registry);
export const set = _registry.set.bind(_registry);
```

---

### Вариант 4 — Класс-обёртка

Классовая реализация даёт возможность создавать несколько независимых локаторов (например, для фронтенда и бэкенда с разными реализациями одних и тех же зависимостей).

```js
// ServiceLocator.js

class ServiceLocator {
  constructor() {
    this._registry = new Map();
  }

  // Регистрация зависимости по имени
  set(name, implementation) {
    this._registry.set(name, implementation);
    return this; // позволяет chaining: locator.set('a', A).set('b', B)
  }

  // Получение зависимости по имени
  get(name) {
    if (!this._registry.has(name)) {
      throw new Error(`ServiceLocator: зависимость "${name}" не зарегистрирована`);
    }
    return this._registry.get(name);
  }

  // Получить все зарегистрированные имена
  keys() {
    return [...this._registry.keys()];
  }
}

export default ServiceLocator;
```

```js
// bootstrap.js — регистрация зависимостей
import ServiceLocator from './ServiceLocator.js';
import Logger from './Logger.js';
import ConsoleLogger from './ConsoleLogger.js';

const locator = new ServiceLocator();

// Регистрируем реализацию для текущей среды
locator.set('logger', Logger);

export default locator;
```

```js
// someModule.js — получение и подмена зависимости
import locator from './bootstrap.js';
import MockLogger from './MockLogger.js';

// Получаем зарегистрированный класс
const Logger = locator.get('logger');
const logger = new Logger();
logger.log('Работаем с основным логгером');

// Подменяем реализацию (например, для тестов)
locator.set('logger', MockLogger);

const MockLoggerClass = locator.get('logger');
const mockLogger = new MockLoggerClass();
mockLogger.log('Работаем с мок-логгером');
```

---

## Сравнение с Dependency Injection (DI)

| Критерий | Service Locator | Dependency Injection |
|---|---|---|
| Как получают зависимость | Активно запрашивают через `get` | Пассивно получают через конструктор / аргументы |
| Кто контролирует создание | Сам потребитель | Внешний контейнер / фреймворк |
| Видимость зависимостей | Скрыта (зависит от локатора) | Явная (видна в сигнатуре) |
| Тестируемость | Требует настройки локатора в тестах | Зависимости подставляются напрямую |
| Сложность | Ниже (нет контейнера) | Выше, но явнее |

Service Locator иногда называют **антипаттерном**, потому что зависимости модуля становятся неявными — их нет в сигнатуре конструктора или функции. При этом он остаётся полезным инструментом для определённых задач.

---

## Связь с паттерном Стратегия

Service Locator по своей сути очень близок к паттерну **Strategy**, реализованному через коллекции (Map/объект). Вместо явного условного оператора (`if/switch`) нужная реализация выбирается по имени-ключу. Это тот же принцип: поведение подменяется динамически, без изменения кода потребителя.

```js
// Пример: разные реализации для разных сред
import ServiceLocator from './ServiceLocator.js';
import BrowserLogger from './BrowserLogger.js';
import NodeLogger from './NodeLogger.js';

const locator = new ServiceLocator();

// Выбор реализации в зависимости от среды выполнения
if (typeof window !== 'undefined') {
  locator.set('logger', BrowserLogger); // фронтенд
} else {
  locator.set('logger', NodeLogger);    // бэкенд
}

export default locator;
```

---

## Когда применять

**Применять Service Locator стоит, когда:**

- Нужно динамически подменять реализации зависимостей в рантайме (например, переключение между реальным и тестовым логгером, между окружениями).
- Система не использует DI-контейнер, но нужна централизованная точка регистрации зависимостей.
- Ведётся работа со старым кодом (`require`-based), где нет готового DI-фреймворка.
- Нужна несколько изолированных наборов зависимостей для разных частей приложения (несколько экземпляров `ServiceLocator`).

**Стоит избегать, когда:**

- Зависимости модуля должны быть явными и легко читаемыми (предпочтительнее DI через конструктор).
- Важна строгая типизация и IDE-подсказки (TypeScript + DI-контейнер справится лучше).
- Команда незнакома с паттерном — скрытые зависимости усложняют дебаг.

---

## Итог

- **Service Locator** — реестр, который хранит зависимости и выдаёт их по имени через `get`.
- `require` и `import` — это встроенные сервис-локаторы с кэшированием. В `require` кэш можно изменить вручную, в ESM — нет.
- Минимальная реализация: экспортировать `Map` с методами `get` и `set`.
- Для инкапсуляции внутреннего реестра используется либо фасад из стрелочных функций, либо `bind`, либо класс-обёртка.
- Паттерн очень близок к **Strategy через коллекции** — позволяет подменять поведение по имени ключа.
- Альтернативы для инверсии зависимостей: системы модульности (CommonJS, ESM), собственная система модульности с sandboxing.
- Ключевое отличие от DI: при Service Locator потребитель сам запрашивает зависимость, при DI — получает её извне.
