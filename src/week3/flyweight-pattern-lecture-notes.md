# Паттерн Легковес (Flyweight) из Банды Четырёх

## Обзор

Паттерн **Flyweight (Легковес)** — это структурный паттерн проектирования из Банды Четырёх (GoF), основная задача которого — **экономия памяти** путём разделения объектов на две части: общую (разделяемую) и уникальную. Этот паттерн особенно полезен при создании большого количества однотипных объектов.

**Ключевая идея**: Разделить абстракцию на два класса — один хранит данные, одинаковые для множества экземпляров (внутреннее состояние), а другой хранит уникальные данные (внешнее состояние).

## Основные концепции

### Принцип работы

Экономия памяти достигается за счёт:
- **Повышения сложности программы** — требуется дополнительная логика для управления разделяемыми объектами
- **Использования процессорных ресурсов** — необходимы дополнительные вычисления для связывания объектов

### Компромисс

**Выигрыш**: Значительная экономия памяти при большом количестве однотипных объектов

**Цена**: Увеличение сложности кода и небольшое увеличение нагрузки на процессор

---

## Классическая реализация паттерна Flyweight

### Пример: Система таймеров

Таймер — это идеальный пример для демонстрации паттерна Flyweight, потому что:
1. Каждый таймер выделяет память
2. Каждый таймер связан с системным ресурсом (handle или ID)
3. Платформа (браузер или Node.js) предоставляет ограниченное количество таймеров

### Структура классической реализации

#### Класс Timer (Тяжёлый объект)

Этот класс оборачивает системный `setInterval` и представляет собой тяжеловесную часть паттерна.

```javascript
class Timer {
  constructor(interval, removeTimer) {
    // Сохраняем интервал
    this.interval = interval;

    // Коллекция слушателей (listeners) для данного таймера
    this.listeners = new Set();

    // Callback для удаления таймера из коллекции
    this.removeTimer = removeTimer;

    // Создаём системный таймер (платформенный)
    this.instance = setInterval(() => {
      // При срабатывании таймера вызываем все зарегистрированные listeners
      for (const listener of this.listeners) {
        listener();
      }
    }, interval);
  }

  // Метод для добавления listener'а
  add(callback) {
    this.listeners.add(callback);
  }

  // Метод для удаления listener'а
  remove(callback) {
    this.listeners.delete(callback);

    // Если больше нет слушателей, удаляем системный таймер
    if (this.listeners.size === 0) {
      clearInterval(this.instance);
      // Удаляем таймер из кэша фабрики
      this.removeTimer();
    }
  }
}
```

**Важные поля класса Timer**:
- `interval` — интервал срабатывания (одинаковый для всех, кто использует этот таймер)
- `listeners` — коллекция (Set) всех callback'ов, которые должны вызываться
- `removeTimer` — callback для удаления таймера из фабрики
- `instance` — ссылка на системный таймер (в Node.js это объект, в браузере — Number)

#### Класс TimerFactory (Фабрика с кэшем)

Фабрика управляет коллекцией таймеров и реализует паттерн Flyweight.

```javascript
class TimerFactory {
  // Статическая коллекция таймеров
  // Ключ: интервал (число), Значение: экземпляр Timer
  static timers = new Map();

  // Статический метод для получения таймера
  static getTimer(interval) {
    // Создаём функцию для удаления таймера из кэша
    const removeTimer = () => {
      TimerFactory.timers.delete(interval);
    };

    // Проверяем, есть ли таймер с таким интервалом в кэше
    let timer = TimerFactory.timers.get(interval);

    if (timer) {
      // Если таймер уже существует, возвращаем его
      return timer;
    }

    // Если таймера нет, создаём новый
    timer = new Timer(interval, removeTimer);

    // Добавляем в кэш
    TimerFactory.timers.set(interval, timer);

    // Возвращаем созданный таймер
    return timer;
  }
}
```

**Как работает фабрика**:
1. Метод `getTimer()` проверяет кэш таймеров по ключу `interval`
2. Если таймер с таким интервалом уже существует — возвращает его
3. Если нет — создаёт новый, сохраняет в кэш и возвращает
4. Функция `removeTimer` позволяет таймеру удалить себя из кэша, когда все listeners удалены

#### Класс Interval (Лёгкий объект)

Это клиентская обёртка, которая предоставляет удобный интерфейс для работы с таймерами.

```javascript
class Interval {
  constructor(interval, callback) {
    // Сохраняем callback (уникальный для каждого экземпляра)
    this.callback = callback;

    // Получаем таймер из фабрики (разделяемый ресурс)
    this.timer = TimerFactory.getTimer(interval);

    // Регистрируем наш callback в таймере
    this.timer.add(this.callback);
  }

  // Метод для остановки интервала
  stop() {
    // Удаляем наш callback из таймера
    this.timer.remove(this.callback);
  }
}
```

**Поля класса Interval**:
- `callback` — уникальный для каждого экземпляра (внешнее состояние)
- `timer` — ссылка на разделяемый Timer (внутреннее состояние)

### Использование классической реализации

```javascript
// Создаём множество интервалов
const intervals = [];

// Создаём 1 миллион таймеров с интервалом 1000ms
for (let i = 0; i < 1000000; i++) {
  intervals.push(new Interval(1000, () => {
    // Какая-то логика
  }));
}

// Создаём ещё 1 миллион таймеров с интервалом 2000ms
for (let i = 0; i < 1000000; i++) {
  intervals.push(new Interval(2000, () => {
    // Какая-то логика
  }));
}

// Итого: 2 миллиона Interval объектов
// Но только 2 системных таймера!
```

**Важное наблюдение**: Без паттерна Flyweight создание 2 миллионов `setInterval` вызовов:
- Займёт огромное количество памяти
- Может привести к исчерпанию системных ресурсов
- Будет очень медленным

С паттерном Flyweight:
- Создаются только 2 системных таймера (для 1000ms и 2000ms)
- Экономия памяти и ресурсов в сотни тысяч раз
- Быстрое выполнение

---

## Оптимизированная реализация для JavaScript

В JavaScript можно упростить классическую реализацию, объединив логику в одном классе.

### Вариант 1: Один класс с условной инициализацией

```javascript
class Interval {
  // Статическая коллекция таймеров (кэш)
  static timers = new Map();

  constructor(interval, callback) {
    // Сохраняем callback
    this.callback = callback;

    // Проверяем, есть ли таймер в кэше
    const cached = Interval.timers.get(interval);

    if (!cached) {
      // Если нет — инициализируем полновесный объект
      this.interval = interval;
      this.listeners = new Set();

      this.instance = setInterval(() => {
        for (const listener of this.listeners) {
          listener();
        }
      }, interval);

      // Добавляем в кэш
      Interval.timers.set(interval, this);
    } else {
      // Если есть — возвращаем легковесный объект
      // У него будет только поле callback
    }

    // В любом случае, получаем таймер (либо cached, либо this)
    const timer = cached || this;

    // Добавляем callback в коллекцию listeners
    timer.listeners.add(callback);
  }

  remove(callback) {
    // Находим таймер по callback (через прототип)
    const timer = this.instance ? this : Interval.timers.get(this.interval);

    timer.listeners.delete(callback);

    if (timer.listeners.size === 0) {
      clearInterval(timer.instance);
      Interval.timers.delete(timer.interval);
    }
  }
}
```

**Особенности этой реализации**:
- Объединяет Timer и TimerFactory в один класс
- Создаёт два типа объектов: **тяжёлые** (с полями `interval`, `listeners`, `instance`) и **лёгкие** (только с `callback`)
- **Компромисс**: Объект становится полиморфным, но не деоптимизируется в современных движках JavaScript

### Вариант 2: Использование цепочки прототипов

Эта реализация использует `Object.setPrototypeOf()` для создания связи между лёгкими и тяжёлыми объектами.

```javascript
class Interval {
  static timers = new Map();

  constructor(interval, callback) {
    // Всегда сохраняем callback
    this.callback = callback;

    // Ищем существующий таймер
    const timer = Interval.timers.get(interval);

    if (timer) {
      // Если таймер найден, связываем текущий объект с ним через прототип
      Object.setPrototypeOf(this, timer);
    } else {
      // Если таймера нет, инициализируем полновесный объект
      this.interval = interval;
      this.listeners = new Set();

      this.instance = setInterval(() => {
        for (const listener of this.listeners) {
          listener();
        }
      }, interval);

      // Добавляем в кэш
      Interval.timers.set(interval, this);
    }

    // Добавляем callback в listeners
    // Благодаря прототипу, this.listeners найдётся в цепочке
    this.listeners.add(callback);
  }

  remove() {
    // Удаляем callback из listeners
    this.listeners.delete(this.callback);

    // Если listeners пуст, очищаем таймер
    if (this.listeners.size === 0) {
      clearInterval(this.instance);
      Interval.timers.delete(this.interval);
    }
  }
}
```

**Как работает цепочка прототипов**:

1. **Лёгкий объект** создаётся с одним полем `callback`
2. Его прототип указывает на **тяжёлый объект** с полями `interval`, `listeners`, `instance`
3. При обращении к `this.listeners` JavaScript ищет это свойство в цепочке прототипов и находит его в тяжёлом объекте
4. Все лёгкие объекты с одинаковым интервалом ссылаются на один тяжёлый объект

**Визуализация**:

```
Лёгкий объект 1       Лёгкий объект 2       Лёгкий объект 3
{                     {                     {
  callback: fn1       callback: fn2         callback: fn3
}                     }                     }
  |                     |                     |
  |                     |                     |
  +---------------------+---------------------+
                        |
                        v
            Тяжёлый объект (в кэше)
            {
              interval: 1000,
              listeners: Set([fn1, fn2, fn3]),
              instance: <системный таймер>
            }
```

**Преимущества этого подхода**:
- Не нужно передавать ссылку на callback в метод `remove()`
- Каждый объект знает свой callback через свойство `this.callback`
- Чистый API: `interval.remove()` вместо `interval.remove(callback)`

---

## Сравнение производительности

### Без паттерна Flyweight

```javascript
const intervals = [];

// Создаём 2 миллиона setInterval
for (let i = 0; i < 1000000; i++) {
  intervals.push(setInterval(() => {}, 1000));
}

for (let i = 0; i < 1000000; i++) {
  intervals.push(setInterval(() => {}, 2000));
}

// Проблемы:
// - Огромное потребление памяти
// - Возможное исчерпание системных ресурсов
// - Медленное выполнение
```

### С паттерном Flyweight

```javascript
const intervals = [];

// Создаём 2 миллиона Interval объектов
for (let i = 0; i < 1000000; i++) {
  intervals.push(new Interval(1000, () => {}));
}

for (let i = 0; i < 1000000; i++) {
  intervals.push(new Interval(2000, () => {}));
}

// Преимущества:
// - Только 2 системных таймера
// - Минимальное потребление памяти (только callback'и)
// - Быстрое выполнение
```

### Измерение использования памяти

Вы можете измерить использование памяти в Node.js:

```javascript
// Получаем использование памяти
const memoryBefore = process.memoryUsage();

// ... создаём объекты ...

const memoryAfter = process.memoryUsage();

console.log('Heap используется:',
  (memoryAfter.heapUsed - memoryBefore.heapUsed) / 1024 / 1024, 'MB');
```

---

## Архитектурные аспекты

### Разделение состояния

**Внутреннее состояние (Intrinsic State)**:
- Одинаковое для множества объектов
- Хранится в разделяемом (тяжёлом) объекте
- В нашем примере: `interval`, `listeners`, `instance`

**Внешнее состояние (Extrinsic State)**:
- Уникальное для каждого объекта
- Хранится в лёгком объекте или передаётся как параметр
- В нашем примере: `callback`

### Роль фабрики

Фабрика (Factory) в паттерне Flyweight:
1. **Кэширует** тяжёлые объекты
2. **Возвращает** существующий объект или создаёт новый
3. **Управляет** жизненным циклом разделяемых объектов

В классической реализации фабрика — отдельный класс. В JavaScript можно использовать:
- Статические методы класса
- Функции в модуле (closure)
- Отдельный объект-контейнер

### Управление памятью

**Важный момент**: Таймер удаляется из кэша, когда у него не осталось слушателей.

```javascript
// Когда последний listener удаляется:
if (this.listeners.size === 0) {
  clearInterval(this.instance);  // Очищаем системный таймер
  Interval.timers.delete(interval);  // Удаляем из кэша
}
```

Это предотвращает утечки памяти и освобождает системные ресурсы.

---

## Когда использовать паттерн Flyweight

### Подходящие сценарии

Используйте Flyweight, когда:
1. **Приложение создаёт огромное количество объектов** (сотни тысяч или миллионы)
2. **Большая часть состояния объектов может быть вынесена наружу** (превращена в внешнее состояние)
3. **Множество объектов можно заменить небольшим количеством разделяемых объектов**
4. **Идентичность объектов не важна** (объекты взаимозаменяемы)

### Примеры применения

**1. Графические редакторы**
- Символы в текстовом редакторе
- Частицы в графических эффектах
- Спрайты в играх

```javascript
// Пример: Символы в редакторе
class Character {
  constructor(char, font, size) {
    this.char = char;  // Внутреннее состояние
    this.font = font;  // Внутреннее состояние
    this.size = size;  // Внутреннее состояние
  }

  display(position, color) {
    // position и color — внешнее состояние
    console.log(`Отображаем ${this.char} в ${position} цветом ${color}`);
  }
}

class CharacterFactory {
  static characters = new Map();

  static getCharacter(char, font, size) {
    const key = `${char}-${font}-${size}`;
    if (!this.characters.has(key)) {
      this.characters.set(key, new Character(char, font, size));
    }
    return this.characters.get(key);
  }
}
```

**2. Пулы соединений**
- Database connection pools
- HTTP connection pools
- WebSocket connections

**3. Кэширование**
- Кэш часто используемых объектов
- Мемоизация вычислений

### Неподходящие сценарии

**Не используйте Flyweight, если**:
- Мало объектов (производительность не критична)
- Все объекты уникальны (нет разделяемого состояния)
- Требуется изменяемое внутреннее состояние

---

## Связь с другими паттернами

### Flyweight и Singleton

**Сходства**:
- Оба ограничивают количество экземпляров
- Оба используют разделяемые объекты

**Различия**:
- Singleton: один экземпляр на всё приложение
- Flyweight: несколько экземпляров, но меньше, чем могло бы быть

### Flyweight и Factory

Flyweight **почти всегда** использует Factory для:
- Управления кэшем объектов
- Принятия решения: создать новый или вернуть существующий

### Flyweight и Proxy

**Сходства**:
- Оба добавляют уровень косвенности
- Оба могут экономить ресурсы

**Различия**:
- Proxy: заменяет один объект на другой
- Flyweight: разделяет один объект между многими клиентами

---

## Ключевые выводы

### Суть паттерна

Паттерн Flyweight позволяет:
1. **Экономить память** путём разделения объектов на лёгкие и тяжёлые части
2. **Переиспользовать** тяжёлые объекты между множеством лёгких
3. **Сохранять** удобный интерфейс для клиентского кода

### Основные компоненты

1. **Flyweight (Легковес)** — разделяемый объект с внутренним состоянием
2. **Unshared Concrete Flyweight** — объект с внешним состоянием
3. **Flyweight Factory** — управляет созданием и кэшированием

### Реализация в JavaScript

В JavaScript паттерн можно реализовать:
- **Классически** (отдельные классы для Flyweight и Factory)
- **Упрощённо** (один класс с условной инициализацией)
- **Через прототипы** (использование цепочки прототипов)

### Производительность

**Экономия памяти**: В примере с таймерами:
- Без Flyweight: 2 000 000 системных таймеров
- С Flyweight: 2 системных таймера
- **Экономия: в 1 000 000 раз!**

**Цена**: Небольшое увеличение сложности кода и процессорного времени

---

## Практические рекомендации

### Проектирование

1. **Определите, что разделяемо**: Найдите общее состояние у множества объектов
2. **Вынесите уникальное состояние наружу**: Превратите его в параметры методов
3. **Создайте фабрику**: Для управления кэшем разделяемых объектов
4. **Продумайте очистку**: Освобождайте ресурсы, когда они больше не нужны

### Оптимизация

1. **Используйте Map для кэша**: Быстрый поиск по ключу
2. **Очищайте кэш**: Удаляйте неиспользуемые объекты
3. **Измеряйте**: Проверяйте реальную экономию памяти
4. **Не переусложняйте**: Применяйте паттерн только при реальной необходимости

### Отладка

```javascript
// Добавьте методы для диагностики
class Interval {
  static getStats() {
    return {
      cachedTimers: Interval.timers.size,
      intervals: Array.from(Interval.timers.keys())
    };
  }
}

// Использование
console.log(Interval.getStats());
// { cachedTimers: 2, intervals: [1000, 2000] }
```

---

## Дополнительные материалы

### Классификация паттерна

- **Тип**: Структурный паттерн
- **Уровень**: Объектный
- **Цель**: Экономия памяти через разделение состояния

### Альтернативные названия

- Приспособленец
- Легковес
- Flyweight

### История

Паттерн Flyweight был впервые описан в книге "Design Patterns: Elements of Reusable Object-Oriented Software" (Банда Четырёх, 1994).

### Связанные концепции

- **Object Pool** — похожая идея переиспользования объектов
- **Lazy Initialization** — создание объектов по требованию
- **Copy-on-Write** — разделение данных до момента изменения

---

## Заключение

Паттерн Flyweight — мощный инструмент оптимизации памяти, особенно актуальный при работе с большим количеством однотипных объектов. В JavaScript его можно реализовать различными способами, от классической ООП структуры до использования прототипного наследования.

**Помните**:
- Flyweight решает проблему избыточного потребления памяти
- Он эффективен только при большом количестве объектов
- Современные движки JavaScript хорошо оптимизируют такие паттерны
- Всегда измеряйте реальную эффективность применения паттерна

Паттерн Flyweight демонстрирует классический компромисс в программировании: вы обмениваете **простоту** на **эффективность**. Используйте его разумно, и он принесёт значительную пользу вашему приложению.
