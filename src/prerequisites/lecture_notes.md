# Конспект лекции: JavaScript оптимизация и паттерны

---

## Введение: Философия разработки

### Суть работы программиста
Лектор начинает с социальной аналогии: работа программиста схожа с работой заводского рабочего, которому нужно повторять одно и то же. Но программистам спасает **интеллект** — они разбираются в сложных системах (Event Loop, асинхронность, контракты типов).

**Ключевая идея**: Интересное время требует постоянного изучения и понимания внутреннего устройства систем. Это невозможно ограничить линиями кода в день — нельзя писать ни обязательно 1000 строк, ни обязательно менее 10 строк. Решение зависит от задачи, памяти и оптимизации компилятора.

### Баланс красоты и производительности
- **Желаемое состояние**: Производительность кода зависит от качества **компилятора/интерпретатора**, а не от качества кода программиста
- **Реальность**: Часто нужно писать код, понимая его производительность
- **Предложение**: Ввести дифференциацию между JavaScript-программистами:
  - Одни пишут красивый продакшн-код
  - Другие пишут код с требованиями по производительности (с использованием специальных `use` директив)

---

## Различие JavaScript и Java

### Культурные особенности JavaScript
**JavaScript имеет множество "первоклассных" сущностей:**
- Функции как первоклассные объекты
- Типы как первоклассные объекты
- Классы как первоклассные объекты

Все эти сущности можно передавать как аргументы и возвращать из функций.

**Java ограничена архитектурой:**
- Нет первоклассных типов/классов
- Строгая типизация была введена для того, чтобы "ломать руки" разработчикам, пишущим неправильный код
- Это позволило быстро писать промышленный код с гарантиями надежности

**Вывод**: JavaScript дает большую свободу, но требует большей ответственности разработчика. Java ограничивает, зато гарантирует определенные стандарты.

---

## Классы в JavaScript и замыкания

### Реальность приватных полей
До появления приватных полей (`#field`) в JavaScript классы практически ничем не отличались от обычных объектов с замыканиями:

```javascript
// Классический способ с замыканиями (эмуляция приватных полей)
function createCounter() {
  let count = 0; // приватное поле через замыкание
  
  return {
    increment() { count++; },
    getCount() { return count; }
  };
}

// Приватные поля в классах (новый синтаксис)
class Counter {
  #count = 0; // приватное поле
  
  increment() { this.#count++; }
  getCount() { return this.#count; }
}
```

### Проблемы приватных полей
1. **Внутренняя реализация**: Приватные поля добавляют дополнительное окружение, что усложняет наследование
2. **Потеря видимости при наследовании**: Если вы добавляете метод через `prototype` (вне класса), он не видит приватные поля класса
3. **Типизация в TypeScript**: TypeScript приватные поля — это фикция (исчезают при компиляции), JavaScript приватные поля — это реальность

**Рекомендация лектора**: Использовать приватные поля только в конечных классах (которые не наследуются), или придерживаться замыканий.

---

## Практический проект: Построение интерпретатора выражений

### Эволюция архитектуры

#### 1. Паттерн Iterator (простые выражения)
**Задача**: Парсить и интерпретировать математические выражения вида `x + y`

Начиная с простого подхода:
```javascript
// Начальный вариант: классы для каждого типа выражения
class Value {
  constructor(value) { this.value = value; }
  interpret() { return this.value; }
  toJavaScript() { return `${this.value}`; }
}

class Variable {
  constructor(name) { this.name = name; }
  interpret(context) { return context[this.name]; }
  toJavaScript() { return this.name; }
}
```

#### 2. Паттерн Composite (сложные структуры)
**Проблема**: Выражение может быть вложенным: `(x + y) * z`
**Решение**: Классы для операций
```javascript
class BinaryOp {
  constructor(left, operator, right) {
    this.left = left;
    this.operator = operator;
    this.right = right;
  }
  
  interpret(context) {
    const leftVal = this.left.interpret(context);
    const rightVal = this.right.interpret(context);
    return this.operator.evaluate(leftVal, rightVal);
  }
}
```

#### 3. Паттерн Strategy (гибкие операторы)
**Проблема**: Жестко закодировать операторы в классе
**Решение**: Коллекция операторов
```javascript
const operators = {
  '+': { name: '+', evaluate: (a, b) => a + b },
  '-': { name: '-', evaluate: (a, b) => a - b },
  '*': { name: '*', evaluate: (a, b) => a * b },
};

// Для добавления нового оператора просто добавьте в коллекцию
operators['%'] = { name: '%', evaluate: (a, b) => a % b };
```

#### 4. Рефакторинг: от классов к функциям
**Наблюдение**: Не все нужно делать классами
**Новый подход**: Использовать классы только где они действительно нужны
```javascript
// Парсер как функция (была классом)
function parse(input) {
  // логика парсинга
  return ast; // абстрактное синтаксическое дерево
}

// Оценка как функция
function evaluate(node, context) {
  // логика вычисления
}
```

---

## Генерация JavaScript кода

### Из дерева выражений в функции

**Идея**: На основе AST (абстрактного синтаксического дерева) сгенерировать JavaScript код, который можно выполнить

```javascript
// Входное дерево (AST)
const ast = new BinaryOp(
  new Variable('x'),
  operators['+'],
  new Variable('y')
);

// Сгенерированный JavaScript код
const code = `(x, y) => x + y`;

// Выполнение через V8
const result = eval(code)(10, 20); // 30
```

### Сбор идентификаторов
Интерпретатор может автоматически определять, какие переменные нужны:

```javascript
// Из дерева (x + y) * z извлекаются идентификаторы: x, y, z
// Генерируется: (x, y, z) => (x + y) * z

// Это позволяет:
// 1. Генерировать правильную сигнатуру функции
// 2. Проверять доступность переменных
// 3. Оптимизировать замыкания
```

---

## Паттерн Template String и производительность

### Использование бэккотов vs кавычек

**Важное уточнение**: С точки зрения производительности в V8, использование обычных строк и template strings эквивалентно:

```javascript
// Эти два варианта работают одинаково быстро
const str1 = 'x + y';
const str2 = `x + y`;

// Но если в template string есть подстановки, V8 может оптимизировать:
const code = `(${params}) => ${expression}`;
```

**Когда template strings дают преимущество:**
- Если перед бэккотом стоит функция (tagged template), тогда это вызов функции с параметрами
- V8 может собрать строку заранее, не интерпретируя в реальности

---

## Приватные поля и наследование

### Проблема наследования
```javascript
class Base {
  #privateField = 10;
  
  getPrivate() { return this.#privateField; }
}

class Derived extends Base {
  // Добавляем метод через prototype (вне класса)
  // Этот метод НЕ ВИДИТ приватные поля класса Base
}

// Добавляем метод на prototype
Derived.prototype.newMethod = function() {
  // this.#privateField недоступно!
};
```

**Решение**: Либо добавлять методы внутри класса, либо использовать замыкания для приватности.

---

## Real-world пример: Паттерн State Machine для заказа такси

### Проблема
Система заказа такси имеет сложное состояние с несколькими переходами:
- "waiting" → "matching" → "en_route" → "arrived" → "completed"
- Каждое состояние имеет разные доступные действия

### Классический подход (много switch/case)
```javascript
switch(state) {
  case 'waiting':
    // код для состояния waiting
    break;
  case 'matching':
    // код для состояния matching
    break;
  // ... много состояний
}
```

**Проблемы**:
- Сложно добавлять новые состояния
- Логика размазана по коду
- Трудно читать и тестировать

### Паттерн State Machine (рекомендованный подход)
**Структура**: Каждое состояние — это класс с методами для действий

```javascript
class Order {
  constructor(id) {
    this.id = id;
    this.state = new WaitingState(this);
  }
  
  confirmDriver(driver) {
    this.state.confirmDriver(driver);
  }
  
  startRide() {
    this.state.startRide(driver);
  }
}

class WaitingState {
  constructor(order) { this.order = order; }
  
  confirmDriver(driver) {
    // Переход в новое состояние
    this.order.state = new EnRouteState(this.order);
  }
}

class EnRouteState {
  constructor(order) { this.order = order; }
  
  arrive() {
    this.order.state = new CompletedState(this.order);
  }
}
```

**Преимущества**:
1. Каждое состояние инкапсулировано в отдельном классе
2. Легко добавлять новые состояния
3. Ясная логика переходов между состояниями
4. Легко тестировать каждое состояние отдельно

### Граф состояний
```
WaitingState
    ↓
MatchingState
    ↓
EnRouteState
    ↓
ArrivedState
    ↓
CompletedState
```

---

## Паттерны Gang of Four и их адаптация

### Переработка классических паттернов для JavaScript

**Наблюдение**: Книга "Design Patterns" (Gang of Four) издана в 1994 году и ориентирована на языки без первоклассных функций.

**Подход лектора**: Переработать паттерны для JavaScript с использованием:
- Объектов вместо классов (где это имеет смысл)
- Функций вместо методов
- Замыканий вместо приватных полей

**В каждом репозитории представлены**:
1. Классическая реализация (как в книге)
2. Адаптированная реализация для JavaScript
3. Примеры использования

### Когда использовать классы в JavaScript
- Для построения деревьев (AST, DOM, иерархии)
- Когда нужна наследуемая функциональность
- Когда структура данных подразумевает иерархию

**НЕ использовать классы**:
- Для простых коллекций данных
- Для двусвязных списков через замыкания (непривычно для людей)
- Когда можно использовать функции
- Где нужна максимальная гибкость

---

## Важные мысли о разработке

### От задачи к решению (не от решения к задаче)
**Проблема в academia**: Сначала дают множество информации (паттерны, примеры), потом человек не знает, что с ней делать, пока не столкнется с реальной задачей.

**Правильный подход**:
1. Предъявить задачу
2. Человек пытается ее решить "в лоб"
3. Столкнувшись с проблемой, показать, как паттерн решает эту проблему
4. Это становится наглядным и понятным

**Пример**: Сначала показываем заказ такси, потом говорим: "Видишь сложность? Вот для этого нужна State Machine"

### Философия качества кода
- **На работе должна быть радость и удовольствие** от происходящего
- Если вы не получаете удовольствия от кодирования, нужно менять профессию
- Красивый код важен, но не если он жертвует функциональностью
- Баланс между читаемостью и производительностью

### Глубина погружения в технологии
**Метафора "Кольской скважины"**: Чем глубже ты погружаешься в исходный код платформы/языка, тем страшнее становится. Тебе видна работа обыкновенных людей, троечников, которые предпочли "написать и забыть". Но это помогает понять, что идеальных решений не существует.

**Примеры пугающих фактов**:
- В микрокоде процессора случаются ошибки (Spectre, Meltdown и другие уязвимости)
- Даже Assemblly (самый простой язык) может привести к неожиданным результатам
- Глубже = страшнее, но и понятнее

---

## Практические советы

### Использование тестов при переработке кода
При рефакторинге архитектуры:
1. Сначала пишите код "в лоб" с нужной функциональностью
2. Потом пишите тесты
3. После тестов можно рефакторить архитектуру
4. Тесты подтверждают, что функциональность не изменилась

### Оптимизация — последний шаг
- Сначала пишите правильный код
- Потом, если нужна оптимизация, анализируйте узкие места
- Не оптимизируйте раньше времени (premature optimization)

### Чтение специфікації
Когда что-то непонятно:
- Читайте официальную спецификацию
- Ищите реализацию спецификации на том же языке (например, JavaScript реализация JavaScript)
- Такой код часто более понятен, чем описание в спеке

---

## Выводы

1. **JavaScript — язык свободы с большой ответственностью**: Много первоклассных сущностей дает гибкость, но требует мудрости в использовании

2. **Паттерны — инструменты, не догмы**: Используйте их когда нужны, не насиловайте JavaScript ООП где это неуместно

3. **Баланс — главное**: Красивый код vs производительность, простота vs гибкость, классы vs функции

4. **От задачи к решению**: Сначала поймите проблему, потом применяйте паттерны

5. **Качество зависит от человека**: Даже базовые инструменты (как State Machine) дают огромное преимущество в сложных системах

6. **Будьте честны в коде**: Код должен быть понятным для вашей команды, даже если он не "красивый" по стандартам"