# Паттерны GRASP для JavaScript, TypeScript и Node.js

## Конспект лекции (часть 1)

---

## Введение

GRASP (General Responsibility Assignment Software Patterns) — набор принципов и шаблонов проектирования, применимых к любому коду: backend, frontend, синхронному или асинхронному. Некоторые элементы GRASP являются принципами, некоторые — паттернами.

---

## 1. Low Coupling и High Cohesion (Низкое зацепление и высокая связность)

### Определения

| Термин | Перевод | Это хорошо/плохо? |
|--------|---------|-------------------|
| **Coupling** | Зацепление | ПЛОХО |
| **Cohesion** | Связность | ХОРОШО |

### Суть принципа

Любая программная абстракция (класс, модуль, компонент) должна быть спроектирована так, чтобы:
- **Внутренняя связка частей** была **сильнее**, чем связи с внешним миром
- **Внешние взаимодействия** были **минимизированы**

### Пример плохой практики (High Coupling)

```javascript
// Плохо: цепочка вызовов через много объектов
request.socket.connection.pool.timeout = 5000;
```

Когда мы видим 10 точек подряд — это признак высокого зацепления. Мы "лезем в душу" объектам, нарушая их инкапсуляцию.

### Почему это важно?

1. **Изменение в одном месте ломает десять других** — код становится хрупким
2. **Невозможно менять компоненты по отдельности** — они работают только в связке
3. **Сложно тестировать** — нужно мокать всю цепочку зависимостей

### Связь с SOLID

| GRASP | SOLID |
|-------|-------|
| Low Coupling / High Cohesion | Single Responsibility Principle (SRP) |
| Взаимодействие через интерфейсы | Interface Segregation Principle (ISP) |

---

## 2. Information Expert (Информационный эксперт)

### Суть принципа

Каждая программная абстракция должна:
- Инкапсулировать собственные данные
- Иметь внутренние методы, недоступные снаружи
- Обладать своей зоной ответственности

### Реализация в JavaScript/TypeScript

```typescript
// Приватные поля (современный способ)
class User {
  #password; // приватное поле

  private validatePassword() { /* ... */ } // TypeScript private
}

// Устаревший способ (соглашение)
class User {
  _password; // подчёркивание = "не трогать снаружи"

  _validatePassword() { /* ... */ }
}
```

### Правило

Если вы обращаетесь к полю или методу с подчёркиванием извне — вы **повышаете зацепление** и делаете систему менее стабильной.

### Связь с асинхронностью

Information Expert снижает coupling, но не влияет напрямую на cohesion. Его задача — обеспечить инкапсуляцию.

---

## 3. Creator (Создатель)

### Суть паттерна

**Кто создаёт — тот и разрушает.**

Ответственность за создание и разрушение объекта должна лежать на одной и той же абстракции.

### Два подхода

| Подход | Создание | Разрушение |
|--------|----------|------------|
| Внедрение зависимостей (DI) | Извне | Не наша ответственность |
| Создание внутри | Мы создаём | Мы должны разрушить |

### Примеры проблем

```javascript
// Плохо: создали логгер, прицепили к сокету, забыли про него
class AuditService {
  constructor() {
    this.logger = new Logger();
    socket.attachLogger(this.logger); // Утечка!
  }
  // Кто теперь закроет logger?
}

// Файловые дескрипторы — не собираются GC!
const fd = fs.openSync('file.txt');
// Если не вызвать fs.closeSync(fd) — дескриптор "повиснет"
```

### Правило для Node.js

- Файловые дескрипторы
- Сокеты
- Коннекты к базе данных

**Все эти ресурсы НЕ собираются Garbage Collector'ом!** Создатель должен явно их закрыть.

### Связь с примесями

В JavaScript из-за примесей (mixins) часто нарушается паттерн Creator. Будьте осторожны при использовании миксинов.

---

## 4. Контракты vs Интерфейсы

### В чём разница?

| Аспект | Интерфейс | Контракт |
|--------|-----------|----------|
| Формат | Формальный (TypeScript interface) | Любой (текст, код, спецификация) |
| Полнота | Описывает структуру | Описывает структуру + поведение |
| Примеры | `interface User { name: string }` | "Метод возвращает Promise, который resolve'ится после завершения транзакции" |

### Контракт шире интерфейса

```typescript
// Интерфейс описывает структуру
interface Iterable<T> {
  [Symbol.iterator](): Iterator<T>;
}

// Но не отвечает на вопросы:
// - Итерация синхронная или асинхронная?
// - Между итерациями происходит отдача кванта времени?
// - Как обрабатываются ошибки?
```

### Асинхронные контракты

Формально описать асинхронные контракты крайне сложно:

```javascript
// Один и тот же интерфейс, разное поведение:

// 1. Синхронный генератор чисел — блокирует event loop
function* syncRandom() { yield Math.random(); }

// 2. Асинхронный генератор — отдаёт управление
async function* asyncRandom() {
  await delay(0);
  yield Math.random();
}
```

TypeScript не может описать такие нюансы поведения.

### Форматы описания контрактов

- JSDoc
- JSON Schema
- TypeScript `.d.ts` файлы
- Человеческий текст (документация)
- Примеры кода

---

## 5. Dependency Injection (Внедрение зависимостей)

### Способы внедрения зависимостей

| Способ | Описание | Оценка |
|--------|----------|--------|
| **Конструктор** | `new Service(logger)` | Хорошо |
| **Метод (setter)** | `service.setLogger(logger)` | Хорошо (с контролем) |
| **Замыкание (фабрика)** | `createService(logger)` | Хорошо |
| **Примесь (mixin)** | `service.logger = logger` | ПЛОХО |
| **Глобальный контекст** | `global.logger` | Допустимо для stateless |

### Почему примеси — плохо?

```javascript
// Опасный сценарий:
class InventoryService {
  async calculateStock() {
    // Длинная асинхронная операция
    await someAsyncWork();
    this.logger.log('Step 1'); // logger может быть уже другим!
  }
}

// Кто-то меняет logger посередине операции:
service.logger = newLogger; // Половина логов в одном месте, половина в другом
```

### Методы дают контроль

```javascript
class InventoryService {
  #pendingConnection = null;

  setConnection(newConnection) {
    if (this.#activeTransaction) {
      // Ждём завершения транзакции
      this.#pendingConnection = newConnection;
      return;
    }
    this.#connection = newConnection;
  }
}
```

### Глобальный контекст в Node.js

Многие зависимости приходят из глобального контекста:
- `console` — логирование
- `process` — информация о процессе
- `setTimeout`, `setInterval` — таймеры

Это стало частью культуры Node.js, но не является лучшей практикой.

### Система модулей как DI

```javascript
// Node.js автоматически создаёт замыкание:
// (function(exports, require, module, __filename, __dirname) {
//   // Ваш код файла
// })

// Это тоже форма dependency injection!
```

### Замыкание как явный DI

```javascript
// Хороший паттерн:
export const createServer = (config, logger) => {
  // logger доступен через замыкание
  return {
    start() {
      logger.info('Server starting...');
    }
  };
};
```

---

## 6. Закон Деметры (Law of Demeter)

### Формулировка

**"Не разговаривайте с незнакомцами"**

Модуль должен знать как можно меньше о других модулях.

### Это не значит "не общаться вообще"

Система не может работать без взаимодействия. Но:
1. Минимизируйте количество взаимодействий
2. Делайте взаимодействия через **контракты/интерфейсы**

### Практический смысл

```javascript
// Плохо: знаем слишком много о внутренностях
user.account.balance.amount

// Хорошо: спрашиваем то, что нам нужно
user.getBalance()
```

---

## 7. Сетевые протоколы и контракты

### Обсуждение gRPC, HTTP, protobuf

Любой RPC-протокол решает одну задачу: **упорядочить контракты для удалённого взаимодействия**.

| Протокол | Формат | Особенности |
|----------|--------|-------------|
| gRPC | Бинарный (protobuf) | Немного компактнее JSON |
| JSON-RPC | Текстовый (JSON) | Читаемый, универсальный |
| SOAP | XML | Устаревший |

### Почему gRPC популярен?

Не потому что он лучше технически. Причины:
1. Маркетинг Google
2. Хорошая документация
3. Готовые инструменты

### Практический вывод

Бинарный формат не даёт существенного выигрыша для большинства приложений:

```javascript
// JSON: 2 байта на кавычки вокруг строки
// Бинарный: нужен заголовок типа

// Для строк разница минимальна
// Для чисел бинарный может быть даже больше!
// Число "58" в JSON = 2 байта
// int32 в бинарном = 4 байта
```

---

## Ключевые выводы

1. **GRASP — это не строгая наука**, а набор инженерных практик "на вкус и здравый смысл"

2. **Coupling vs Cohesion**: стремитесь к низкому зацеплению между модулями и высокой связности внутри них

3. **Кто создаёт — тот разрушает**: помните о ресурсах, которые не собирает GC

4. **Контракт шире интерфейса**: TypeScript не может описать асинхронное поведение

5. **Dependency Injection**: выбирайте явные способы (конструктор, фабрика), избегайте примесей

6. **Закон Деметры**: минимизируйте знание модулей друг о друге

---

## Связь с другими темами

- **SOLID** — дополняет GRASP, особенно SRP и ISP
- **GoF паттерны** — реализуют идеи GRASP (Factory, Singleton)
- **Закон Конвея** — архитектура системы отражает структуру команды
- **Контрактное программирование** — развивает идею интерфейсов

---

*Конспект составлен на основе лекции Тимура Шемсединова*
