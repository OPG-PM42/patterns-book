# Мономорфный и полиморфный код, инлайн-кэш, скрытые классы в JavaScript

## Введение

Добрый день! Сегодня мы попробуем посмотреть какие у нас есть оптимизации, как нам писать более быстрый и хороший код на JavaScript. Посмотрим что такое мономорфный и полиморфный код, договоримся о терминах и посмотрим на inline-кэш и как формируются скрытые классы. Все на примерах кода это дело рассмотрим.

Репозиторий называется "monomorphism" и живет он в организации HowProgrammingWorks. Там куча примеров.

## Мономорфный и полиморфный код для полей объектов

### Базовый пример с функцией getX

Если у нас есть вот такая функция `getX(obj)`, которая считывает свойство `x` из объекта, переданного на вход, объект может быть разным. У нас тип объекта не указывается - что угодно может приходить. В общем смысле мы не можем этот код заранее оптимизировать, не можем его никак скомпилировать, потому что от начала объекта в памяти, где будет поле `x` находиться, по какому смещению - определить невозможно.

Когда у нас есть вот такая функция, то ее откомпилировать в эффективный машинный код практически невозможно. Но когда мы ее несколько раз вызываем, то мы уже можем сделать кучу оптимизаций.

### Inline-кэш и первый вызов

Когда мы передали туда один раз объект с полем `x`, и он типа `Number`, то уже как минимум понятно, что скорее всего эту функцию будут вызывать с объектами похожей формы. То есть у них тоже будет поле `x`, это же будет Number.

При втором вызове уже могут быть переиспользованы те знания, которые runtime JavaScript приобрел при первом вызове. То есть он же при первом вызове вычислил:
- где именно находится эта десяточка
- что 10 это не просто Number, что это Integer
- и что это даже Small Integer
- и он находится по такому-то смещению относительно начала объекта

Все эти знания они будут храниться внутри функции `getX` в так называемых **inline-кэшах**.

### Структура inline-кэшей

Обращение через свойство к свойству `x` - откуда считать эту десяточку - она накапливается внутри этой функции. Внутри этой функции у нас на самом деле наверное будет два таких кэша:
1. Один по обращению `obj.x`
2. Второй кэш - это кэш по результату

То есть у нас из этой функции возвращается значение, можно закешировать вычисления результата.

### Полиморфное состояние

Когда мы вызываем с объектом другой структуры (другой формы) - у него тоже есть `x` и он тоже Number, но у него еще есть `y` - это уже приводит к тому, что обращение к свойству `x` в этом месте становится **полиморфным**.

Если у нас при двух первых вызовах функция вызывается с одинаковыми объектами (объектами одинаковой формы), то она **мономорфная**. Как только появляются другие вызовы, это уже получается обращение к свойству `x` полиморфное.

Можно искать его:
- по смещению, которое запомнилось при первой операции
- или по смещению, которое будет вычислено во время второго/третьего вызова

### Пример с разными формами объектов

```javascript
getX({ x: 10 });           // форма: { x: Number }
getX({ x: 10, y: 20 });    // форма: { x: Number, y: Number }
getX({ y: 30, x: 40 });    // форма: { y: Number, x: Number } - другое смещение!
```

В третьем случае, если поля идут в обратном порядке (сначала `y`, а потом `x`), то смещение хранения `x` будет другое. В этом третьем случае смещение может быть то же самое, но ссылка на форму будет другая.

Знания о том, что `x` находится по определенному смещению относительно начала объекта, может использоваться. То есть если у нас еще где-то будет вызываться `getX` с какими-то другими объектами (там не только с числами, с чем угодно), у которых тоже есть `x` и он тоже первым полем, в принципе эти знания могут быть переиспользованы.

## Скрытые классы (Hidden Classes)

### Создание класса Point

Теперь мы создаем класс `Point` и смотрим, каким образом при создании этого класса, при создании экземпляров этого класса, будут создаваться эти скрытые классы, которые необходимы для ускорения кода.

```javascript
class Point {
  constructor(x, y) {
    this.x = x;  // Шаг 1: связывание с формой { x: Number }
    this.y = y;  // Шаг 2: переход к форме { x: Number, y: Number }
  }
}
```

### Процесс создания скрытых классов

Для ускорения кода нам нужно знать смещение - откуда в памяти относительно начала объекта считывать его свойства.

1. Как только мы попадаем в конструктор - у нас просто пустой объект, практически объект без формы
2. После первой строки этот объект `instance` поинта связывается с уже известной формой, которая вычислилась при этом вызове
3. Эта форма - мы ее нигде не задаем, мы не пишем эти скрытые классы прямо в коде
4. Они **вычисляются во время исполнения**

Как только мы создаем внутри `instance` поле `x` и он тоже типа Number, у нас сразу этот объект связывается с таблицей вот этих скрытых классов - вычисляется форма и связывается с соответствующим скрытым классом.

Как только мы туда добавляем еще одно поле `y`, у нас `instance` поинта **переходит из одного скрытого класса в другой скрытый класс**. То есть он может путешествовать во время исполнения конструктора.

### Динамическое изменение формы

После того как мы сконструировали объект, мы в принципе можем:
- примешивать какие-то поля
- удалять какие-то поля

Естественно, тогда у него форма тоже будет меняться.

Для оптимизации: если у нас есть много объектов, которые тоже проходили таким же путем (им сначала добавляли поля, потом удаляли поля), вся эта история запоминается. Смещение (допустим, игрека относительно начала этого объекта) у всех объектов, которые прошли одинаковую историю изменений, у них у всех будет одинаковое.

Поэтому компилятору эта информация нужна для того, чтобы ускорить обращение к `x` и к `y`.

### Пример с методами

Точно так же происходит и с методами:

```javascript
const p1 = new Point(10, 20); // Создается instance, вычисляются формы

const p2 = {
  x: 10,
  y: 20,
  toString() { return `(${this.x}, ${this.y})`; }
};
```

Только после создания `new Point` вычисляются все эти вещи. Если вы вдруг передадим сюда не 10 и 20, а допустим две строчки или какие-то другие значения, то и оптимизации будут другими.

Мы не можем на этапе задания класса сразу сказать, какие там будут типы и как нужно производить оптимизацию - только при вызове конструктора.

### Совпадение форм

Дальше создаем литерал объекта, у которого будет 3 поля `x`, `y` и `z`. Для него форма вычисляется: `{ x: Number, y: Number, z: Number }`.

Если мы делаем экземпляр `Point`, потом удаляем у него поле `z`:

```javascript
const p3 = new Point(10, 20, 30);
delete p3.z;
```

У него вычисляется новая форма `{ x: Number, y: Number }` - и эта форма **совпадает** с той формой, которая была вычислена для `p1`. То есть эти знания все они не теряются, они используются для обращения к свойствам объектов.

### Накопление знаний о формах в функции

Везде этот объект передается в функцию `getX`, и знания о форме накапливаются именно внутри этой функции. Если мы будем эти объекты передавать в какую-то другую функцию, в ней будут **другие локальные inline-кэши**, и там оптимизация может пойти совершенно по другому пути.

То есть мы знаем, что обращение к свойству `x` может привести:
- к обращению к форме `{ x: Number }`
- или к форме `{ x: Number, y: Number }`
- или к форме `{ y: Number, x: Number }` - их уже получается 3

Дальше `new Point(10, 20)` - это тоже `{ x: Number, y: Number }`. Вот такая форма `{ x: Number, y: Number, z: Number }` - у нас четыре формы на самом деле получилось.

Все они в одну функцию приходят, то есть именно у этого обращения к свойству `x` она имеет четыре разных форм и четыре разных смещения. В некоторых из них формы разные, но смещения одинаковые. Получается всего лишь два разных смещения:
- одно смещение когда `x` первым стоит
- второе смещение когда `y` первым стоит

На самом деле тут это будет считаться четырьмя разными формами, а результат чтения `x` - это везде Number, и в данном случае это везде будет еще и Integer. Поэтому у нас практически **2 inline-кэша** вырабатывается в такой коротенькой функции.

Казалось бы, что тут один inline-кэш - на чтение свойства, и второй - для формирования результата.

## Переход от мономорфного к полиморфному и мегаморфному состоянию

### Пример с пятью формами

Если бы мы еще написали такой вызов:

```javascript
getX({ x: 10, y: 20, z: 30, active: true });
```

Еще одно поле добавили - это уже получается функция у нас будет вызываться с еще одной формой, это уже пятая форма.

### Состояния inline-кэша

Inline-кэш переходит из:

1. **Мономорфного состояния** - после первого вызова была одна форма, с обращением к свойству была связана только одна форма объекта
2. **Полиморфного состояния** - когда мы их несколько раз вызывали, обращение к свойству перешло в полиморфное состояние, накопилось 4 полиморфных состояния
3. **Мегаморфного состояния** - когда мы вызываем с объектом еще 5-го вида, она перейдет к использованию мегаморфных кэшей, которые глобальные для всего JavaScript runtime

В принципе эти знания они тоже не потеряются, они будут накапливаться. Оптимизирующий компилятор кроме локальной таблицы, которая к функции привязана, имеет еще **глобальную таблицу**, и там тоже хранятся формы и соответственно им смещения для обращения к свойствам.

Но естественно, к локальному кэшу быстрее обратиться.

### Inline-кэш для методов и массивов

Это касается свойств. Поэтому на самом деле inline-кэши и полиморфизм в коде касается не только свойств, но еще и:
- методов
- элементов в массиве

## Полиморфизм методов

### Пример с методом toString

```javascript
function stringify(obj) {
  return obj.toString();
}
```

По этой функции мы не можем понять, какой именно объект приходит на вход. Можем вызвать туда:
- Number передать
- String передать
- Boolean передать

У всех этих типов у них есть `toString`, но они разные, потому что все они по-разному могут себя реализовать:
- Number одним способом себя реализует
- String уже реализован - как минимум он должен отдать ссылку на эту строку
- Boolean должен себя превратить в строчку

### Генерация inline-кэшей для методов

После того как мы вот так три раза вызывали, мы видим, что хоть у нас метод `toString` один и тот же, но мы сгенерируем **три разных inline-кэша** для того, чтобы вызывать этот `toString` у трех разных типов.

Хотя у нас это скалярные типы, у них тоже есть методы, и как вызвать этот метод, где его смещение в памяти - компилятор тоже должен вычислять.

### Пример с объектами

Мы можем вот так еще создать `point`:

```javascript
const point = {
  x: 10,
  y: 20,
  toString() {
    return `(${this.x}, ${this.y})`;
  }
};
```

У него будет `x`, `y` и у него будет прямо литерал объекта, и у него сразу есть метод, который мы задаем прямо тут вот так локально. Это уже 4-я форма объекта, и мы ее тоже передаем в функцию `stringify`, и там тоже вызовется `toString`.

В принципе у нас теперь уже есть - понятно что у нас с самого начала эта функция была в полиморфном состоянии. Тут у нее накопилось четыре разных способа вызова с четырьмя разными типами объектов.

### Пример с классом

Еще придумываем еще один способ:

```javascript
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return `(${this.x}, ${this.y})`;
  }
}
```

Это логически ничем не отличается от такого объекта, но то, что в памяти построится - выглядит по-другому:
- `instance` поинта будет иметь только поля `x` и `y`
- потом `instance` поинта будет ссылаться на прототип
- а у прототипа уже будет метод `toString`

То есть `toString` нужно искать в **другом абсолютно месте** в этом случае. Вот мы тоже все это дело передаем в `stringify`.

То есть этот `point` у него `toString` совершенно другой, нежели `toString` в том `point`, заданном как литерал объекта.

Получается, что это у нас уже **пять разных обращений к `toString`**. Это значит, что он тоже перейдет в **мегаморфное состояние**.

### Переходы состояний

- После первого вызова - **мономорфное состояние**
- После второго - **полиморфное**
- После третьего - **полиморфное**
- После четвертого - **полиморфное**
- После этого 5-го вызова уже будет **мегаморфное состояние**

То есть все эти знания они опять-таки перейдут на **глобальную таблицу**.

## Оптимизация массивов

### Общий тип массива

Дело в том, что если мы просто в JavaScript создадим массив и напихаем туда какими-то разными типами:
- строчками
- Boolean'ами
- объектами
- другими массивами
- датами
- инстансами пользовательских классов
- чем угодно

То это у нас будет самый **общий тип массива**, который никак не оптимизируется. То есть это у нас просто массив состоит из элементов, эти элементы всегда боксированы в виде объектов - это все будет объекты.

### PACKED_SMI_ELEMENTS

Но если мы в массив записываем только Integer, то оптимизирующий компилятор может такой массив хранить вообще в виде массива Number'ов.

```javascript
const arr1 = [1, 2, 3]; // PACKED_SMI_ELEMENTS
```

Если он еще более внимательно присмотрится, то увидит, что тут не просто Number, а это **Small Integer**, и все 1, 2 и 3 - это Small Integer. Их даже можно хранить вообще в 1 байт в однобайтовых или двухбайтовых (как он придумает) значениях в памяти, и совершенно не нужно их оборачивать в виде объектов.

### Типизированные массивы

Хотя в JavaScript уже есть такой способ - типизированные массивы, но у нас куча написанного уже старого кода, и он весь написан вот таким способом. В принципе, мы до сих пор нам достаточно удобно таким способом писать, и нам хотелось бы, чтобы такой способ тоже оптимизировался.

Поэтому если у нас мы просто создаем вот такой массив и складываем туда Number:

```javascript
const arr = [1, 2, 3];
```

В принципе при инстанцировании из литерала у нас сразу создастся массив **Small Integer'ов** - это все в порядке.

### PACKED_DOUBLE_ELEMENTS

Если у нас один из элементов (хотя бы один) этого массива - это какое-то дробное число (4/3 - это 1.333... в периоде):

```javascript
const arr = [1, 2, 3, 4/3]; // PACKED_DOUBLE_ELEMENTS
```

То у нас оптимизирующий компилятор создаст массив **DOUBLE'ов**. Это уже как минимум будет массив Number'ов, но Number'ов самых общих - это Double представление числа. Он работает тоже быстрее, чем массив просто каких-то смешанных значений.

### Конвертация типов массива

Нужно заметить: когда мы инстанцируем просто массив, он может быть массивом Integer'ов, потому что мы сразу догадались, что там все целые числа:

```javascript
const arr = [1, 2, 3];
arr.push(1.5); // Конвертация в PACKED_DOUBLE_ELEMENTS!
```

А потом мы туда пушим какое-нибудь дробное число. Что в этом случае происходит?

**Создается новый массив в памяти**, 1, 2 и 3 из Small Integer копируются в Double - это долго. Если у нас большие массивы, это будет медленно. И все это из-за того, что нам нужно весь массив привести к какому-то типу.

То есть мы должны сделать его **однотипным**, потому что когда мы потом этот массив перебирать, нам понадобится оптимизация - мы захотим каждый следующий элемент массива искать по определенному шагу. Сколько там первый элемент занимает байтов, мы должны отступить, прочитать второе, потом опять столько же байтов отступить, прочитать третье из памяти.

То есть для того, чтобы однотипно работать со всеми элементами, мы должны произвести **конвертацию Small Integer в Double**.

### Пример с большим массивом

Если вы сгенерируете сначала массив Small Integer там 10000 элементов, а потом добавите туда один - всего лишь одно дробное значение - какое произойдет при этом копирование памяти огромное!

Чтобы получим потом: тут я в комментах написал (это не то, что выведется при помощи `console.log`) - это то, как показать, что тут хранится:

```javascript
// Внутреннее представление после добавления 1.5:
// [1.0, 2.0, 3.0, 1.5]
// Все числа теперь Double
```

Число я добавил `.0` - тут `1.0`, `2.0` и `3.0` - это все чтобы потом мы имели возможность там хранить одно дробное число.

### PACKED_ELEMENTS (смешанные типы)

Теперь если мы создаем сразу массив с разнотипными элементами, это еще тоже не самый плохой случай:

```javascript
const arr = [1, 2, 3, "hello"];
```

Вот тут мы положили туда три Number'а и еще "привет". Конечно же, как только JavaScript компилятор и интерпретатор (в принципе, сначала) обнаруживают там "hello", он думает: "Как это хранить в памяти разнотипные элементы?" Абсолютно их нужно хранить в виде объектов.

То есть он **боксирует** все эти значения и хранит вот так. То есть там не просто 1, 2, 3 хранить, а каждое будет хранится в специальном контейнере:
- У нас есть для хранения Number'ов контейнер Number
- Для хранения String'ов контейнер String

В принципе, все они объекты, поэтому у нас будет **массив объектов**.

### Еще худший случай - упаковка в объекты

Если вы сначала делаем массив Small Integer'ов, а потом пушим туда "hello":

```javascript
const arr = [1, 2, 3];
arr.push("hello"); // Упаковка ВСЕХ элементов в объекты!
```

Конечно, это для оптимизирующего компилятора просто беда! Он берет и все эти Integer'ы упаковывает в объекты. То есть он опять вызывает конструктор Number. Представьте, если их там огромное количество - это еще дольше, чем Small Integer в Double переводить. В объекты их еще дольше конвертировать.

## Массивы с дырками (HOLEY)

У нас есть еще более плохие массивы - это массивы с дырками. И они тоже имеют несколько разных подтипов.

### HOLEY_SMI_ELEMENTS - литеральное определение

Есть массив с дырками - мы его можем задать при помощи литерала массива:

```javascript
const arr = [1, , 3]; // HOLEY_SMI_ELEMENTS
```

Массив с дырками, но как минимум все числа тут Small Integer. Его как-то можно оптимизировать.

Такой массив называется **HOLEY_SMI_ELEMENTS**.

### HOLEY_SMI_ELEMENTS - динамическое создание

Есть другой способ создания такого массива:

```javascript
const arr = [1, 2, 3];
arr[100] = 4; // Преобразование в HOLEY_SMI_ELEMENTS
```

Вот мы создали сначала массив без дырок, а потом взяли и присвоили в 100-й индекс четверку. Что это произошло? Там накопилось 97 пустых элементов.

То есть у нас был массив **PACKED_SMI_ELEMENTS**, он преобразовался в массив **HOLEY_SMI_ELEMENTS** с дырками. Это в принципе не очень сложно изменение. Работать, конечно, такое обращение к такому массиву будет гораздо медленнее, чем к массиву с дырками, но это гораздо лучше, чем массив, в котором разные типы еще с дырками.

### Разные подтипы HOLEY массивов

Мы имеем еще один тип массивов. То есть мы в JavaScript синтаксически это никак не задаем, но оптимизирующий компилятор для себя вычисляет тип массива.

### PACKED_DOUBLE_ELEMENTS с дыркой

Если мы прямо в литерале массива записываем Double элемент (хотя бы один), у нас все элементы сразу станут Double'ами:

```javascript
const arr = [1.5, , 3]; // HOLEY_DOUBLE_ELEMENTS
```

Всем во всеобщем порядке. Это в принципе может нам быть необходимо. Для чего?

### Предварительная оптимизация типа

Если мы хотим сразу сделать себе какой-нибудь массив, в котором когда-нибудь появится хоть один Double элемент, и чтобы избежать копирования памяти, мы сразу при создании кладем туда один Double:

```javascript
const arr = [4/3];  // PACKED_DOUBLE_ELEMENTS сразу
arr.pop();          // Убираем элемент
// Массив остался типа PACKED_DOUBLE_ELEMENTS (без дырок)
```

Уже сам массив станет массивом Double'ов, и нам не нужно будет потом копировать память. Туда потом дальше будем класть Integer'ы или какие-то - они все равно будут конвертироваться в Double.

То есть мы в принципе, если создадим себе вот какой-то такой массив, туда запихнем `4/3`, а потом возьмем и сделаем `arr.pop()` - вот сейчас.

Таким образом вот этими двумя строчками создали себе пустой массив. Вот туда положили дробное значение, потому забрали, а массив у нас остался массивом **DOUBLE'ов** - массивом Double'ов, но он без дырок в данном случае.

### HOLEY_DOUBLE_ELEMENTS

А если мы сразу напишем вот так - два элемента пропустили, можем один элемент пропустить вот так:

```javascript
const arr = [1.5, , 3.7]; // HOLEY_DOUBLE_ELEMENTS
```

То у нас сразу создался массив **HOLEY_DOUBLE_ELEMENTS** - Double'ов с дырками.

Этого типа мы не можем никак задать синтаксически напрямую в одну строку. Мы можем сделать:

```javascript
const arr = [1.5, 2.5];
arr.pop();
arr.pop();
// Получили пустой массив с типом HOLEY_DOUBLE_ELEMENTS
```

Сначала массив с элементами (нулевым и первым элементом Double), и тогда мы два раза заберем - два раза заберем эти элементы и получим пустой массив с дырками и Double.

Ну это как бы просто для того, чтобы потом этот массив где-нибудь использовать там, где у нас мы заранее знаем, что там будут дырки и Double, чтобы у нас тип массива не конвертировался.

### Использование правильного типа массива

Для того чтобы потом по этому массиву ходить в цикле или передавать его в качестве аргумента в какую-то функцию, нам желательно, чтобы у него не менялся тип. То есть чтобы не пересчитывался этот inline-кэш, и мы сразу можем вот такими вычислениями создавать такие массивы.

### Еще пример преобразования

```javascript
const arr = [1, 2, 3];        // PACKED_SMI_ELEMENTS
arr[100] = 1.5;                // Преобразуется в HOLEY_DOUBLE_ELEMENTS
```

Тут у нас сразу создается массив **PACKED_SMI_ELEMENTS**, а тут я туда 100 элементов опять присваиваю Double значение - преобразуется в массив с дырками и Double'ами.

### HOLEY_ELEMENTS - смешанные типы с дырками

Теперь еще один массив - это уже совершенно смешанные типы:

```javascript
const arr = [1, 2, 3, , "hello"];
```

Тут у нас все значения опять-таки будут храниться внутри коробочек, внутри объектов. Есть дырки и есть разные типы.

Это в памяти будет храниться: тут сейчас поправлю - вот так это будет храниться как:
- сначала три элемента внутри объектов типа Number
- потом два пустых элемента
- потом String

Ну и там третий тип - это когда мы туда "hello" добавляем по индексу:

```javascript
const arr = [1, 2, 3];
arr[5] = "hello";  // HOLEY_ELEMENTS с пропущенными индексами
```

Тоже этот массив (я их везде раньше писал, потом у меня в одну строчку в какой-то одной из строк максимальная длина не поместилась, я решил их так упростить).

## Практические примеры оптимизации

### Запуск примеров

Давайте мы запустим этот третий пример. Мы видим, что если бы `console.log` просто выводим на экран, то мы никак не понимаем, какого типа этот массив.

Это мы можем разве что узнать, добавляя разные ключи в запуск Node, или если бы запускаем V8 с этими ключами, или D8 (отладчик).

То есть мы можем добавлять вот допустим тут `--trace-elements-transitions` - то есть когда будут в массиве изменяться типы, мы сразу увидим какой-то вывод на экран.

### Анализ вывода trace

Давайте это дело тоже запустим. Типы менялись, мы видим целую историю. Но тут на самом деле очень много изменений, которые к нам не относятся, потому что у Node есть же еще какой-то свой загрузчик.

Вот он пока загружался - мы тут видим, что в каких файлах это происходит: `internal/bootstrap`, `internal/loader` - это внутренняя библиотека Node.

Давайте найдем где наш файл. Вот тут вот это уже мы сделали свой массив. Мы видим свой путь - вот этот длинный путь к этому файлу `3-elements.js`. И тут у нас массив **PACKED_SMI_ELEMENTS** превратился в массив с дырками.

Ну вот мы видим, где это произошло. Ну и там куча тоже других случилось преобразований этих массивов - это уже все связано с нашим кодом.

Потом дома запустите если хотите. Иногда эти преобразования происходят, иногда не происходит, потому что некоторые из них могут быть предсказаны, потому что раскрывается парсером во время парсинга.

В принципе какие-то преобразования можно и не делать вообще. Вот когда литерал создается, он целиком парсится и создается сразу - преобразование типа вот в этом случае не происходит. Он сразу создается массивом объектов.

А там, где мы пушим/добавляем - там он происходит преобразование типов.

## Оптимизация функций с массивами

### Пример функции average

Теперь давайте посмотрим, что же у нас происходит с inline-кэшами и как происходит оптимизация, если мы передаем массивы.

```javascript
function average(arr) {
  let sum = 0;
  for (let i = 0; i < arr.length; i++) {
    sum += arr[i];
  }
  return sum / arr.length;
}
```

Вот такие обычные, которые мы уже знаем теперь, что он создается как массив **PACKED_SMI_ELEMENTS**. Теперь если мы его передаем в функцию `average` (это вычисление среднего), в эту функцию попадет не просто массив, а массив Small Integer'ов.

Ходить по нему в цикле будем как? У нас есть у оптимизирующего компилятора опять-таки шаблоны - такие шаблоны, которые умеют оптимально ходить:
- по массиву Small Integer'ов
- по универсальному массиву - один шаблончик есть
- по массиву Double'ов - другой шаблончик
- по массиву Small Integer'ов - третий шаблончик

### Генерация inline-кэшей для цикла

Вот это так, как у нас в эту функцию передается в данном случае только массив Small Integer'ов, поэтому сгенерируется inline-кэш. Вот в этом месте, то есть `for` будет заменен на такой шаблончик, который может эффективно ходить по массиву Small Integer'ов.

Естественно, что каждый раз мы оттуда читаем элемент, и к этому элементу мы обращаемся. У нас еще есть локальная переменная `sum` - тут тоже сгенерируется большое количество inline-кэшей:
- один на `for`
- подобное обращение к этой переменной
- обращение к этой переменной
- на `+=` еще генерируется
- потом на обращение к свойству `length`
- на оператор возврата результата

Тут огромное количество inline-кэшей. Это как бы шаблоны машинного кода, которые хранятся у оптимизирующего компилятора, и он их по типам подбирает.

### Процесс оптимизации

То есть он смотрит, что в данном месте у него приходит всегда объект или переменная определенной формы, он берет шаблончик, подставляет туда эти значения и заменяет неоптимизированный код (байт-код) на оптимизированный байт-код.

После того как несколько раз у нас эта функция вызывается - но тут она первый раз вызвалась, ей дали хороший массив Small Integer'ов - достаточно важно хорошо оптимизировать. И эта функция наполнилась inline-кэшами именно для оптимизации под массив **PACKED_SMI_ELEMENTS**.

### Результат деления

Но в данном случае у нас после деления результат он может быть Double, поэтому понятно, что случилось деление. В данном случае, конечно, у нас `20 + 10 = 30`, `30 + 30 = 60`, делить на 4 будет 25, поэтому получится, что у нас, конечно, первый раз отсюда вернется целое число.

Так как это результат деления, то скорее всего он будет оптимизирован - inline-кэш сюда будет подставлен такой, чтобы оптимизировать это для **Double**.

### Второй вызов с другим массивом

А вот второй раз, когда мы сюда передаем тоже массив Small Integer'ов, и конечно же оптимизирующий компилятор нас оптимизирует для Small Integer'ов. Но возвращаемое значение тут уже точно будет Double.

Результат - давайте это дело запустим - `62.5` получилось. Но в любом случае результат - ну так как это деление, он будет сгенерирован Double.

### Третий вызов с PACKED_DOUBLE_ELEMENTS

Вот в третьем случае мы сразу передаем сюда массив, у которого есть один элемент дробный, а значит это сразу пришел массив **PACKED_DOUBLE_ELEMENTS**. Это значит, что эта функция будет оптимизирована еще одним способом.

У нас уже есть вариант в этой функции, когда у нас цикл по массиву Small Integer'ов. А тут создастся еще один вариант `for` - вариант цикла по массиву из Double'ов.

Практически два варианта исполнения `for` - то есть в машинном коде это будет как два цикла, и скорее всего там будет `if`, и он пойдет или по одной ветке, или по другой ветке в зависимости от того, какие аргументы приходят в функцию:
- то по массиву Double'ов
- то по массиву Small Integer'ов он будет проходить

Результат тут всегда Double. То есть практически inline-кэши, как мы видим, и полиморфность кода достигается и для свойств, и для массивов.

### Полиморфный код

Такие оптимизации возможны. В данном случае у нас код какой будет - полиморфный, потому что у нас сюда приходят два разных типа массива.

Ну да, до мегаморфного не дойдет, потому что 4 разных форм массива не приходят - только 2: Integer'ы и Double.

Если я еще там иногда передавал сюда массив объектов, массив там еще чего-нибудь такого (массив Big Integer'ов, массив String'ов), то в этом случае эта функция бы скорее всего деоптимизировалась.

## Полиморфизм операторов

### Пример с оператором сложения

Теперь можем посмотреть еще что происходит при вызове функций:

```javascript
function sum(a, b) {
  return a + b;
}
```

Вот мы допустим тут будем гонять миллионы итераций и функцию `sum` передавать разные типы:
- Integer и Integer
- Integer и Double
- String и Integer
- String и String

Кучу разных вариантов в эту функцию огромное количество всего передаем.

Мы даже имея столько разных вариантов кэша (потому что оператор `+` для разных типов он же умеет и числа складывать, и строчки конкатенировать, и что угодно делать) - оператор один делает кучу всего. И тут inline-кэшей сгенерируется огромное количество на всех этих типов.

### Запуск примера с trace

Давайте это дело запустим:

```javascript
// Миллион итераций с разными типами
for (let i = 0; i < 1000000; i++) {
  sum(10, 20);        // Number + Number
  sum(10, 1.5);       // Number + Double
  sum("hello", 10);   // String + Number
  sum("a", "b");      // String + String
  // ... и так далее
}
```

Почему-то не хочет запускаться. Давайте посмотрим - у нас миллион итераций произошло. Сначала у нас функция `sum` - вот она, функция `sum` - она маркирована для перекомпиляции в это.

Нашло, что у нас есть один inline-кэш с информацией типов. Вот запись о том, что эта функция перекомпилировалась. Вот запись о том, что после перекомпиляции нас оптимизировалась, и это заняло чуть-чуть совсем.

### Анализ результатов оптимизации

Она еще раз скомпилировалась - это запись о том, что компиляция закончилась. Точно тут запись о том, что компиляция началась. Тут происходит оптимизация, тут компиляция закончилась.

Мы для одной и той же функции можем увидеть адрес памяти, и мы увидим, что это одна и та же функция. Вот это заканчивается на `e devita` - это та же функция. Ну у нее могут быть несколько версий - у этой функции у них как бы имя будет одинаковое, адреса разные.

Мы потом - эта функция у нас еще раз оптимизируются, она маркирована для оптимизации еще раз. И уже мы видим, что у нас есть **15 разных inline-кэшей**.

То есть из-за того, что ее сначала первый раз на первой итерации цикла (а вот вообще во время первого вызова) она подумала, что больше никак и не будем вызывать, кроме как с Integer'ами.

То есть при первом вызове функции сразу скомпилировалась, оптимизировалась. Потом оказалось, что мы ее вызываем еще с огромным количеством всего, и там накопилось целых **15 inline-кэшей**. И это все равно нормально оптимизируется.

Ну как бы конечно, похуже чем мономорфный код. То есть вот тут предполагалось, что у нас будет полиморфный код - только с Integer вызывает. Тут у нее надежды эти рассеялись, и как-то все-таки какую-то оптимизацию провело, и миллион итераций в принципе прошли.

### Время выполнения

Вот мы сейчас опять это запустим. Видите, сначала происходит эта вся оптимизация, потом чуть-чуть ждет (если вы заметили), а потом выходит - миллион операций происходит после оптимизации. Раз в год и по - вышло пару секунд. Уже оптимизированный код проходится.

Хоть там есть и 15 inline-кэшей, это значит, что там целая пачка таких `if`'ов. И она в случае, если находит переменные одних типов, в одной ветке идет; других типов - по другой ветке идет.

## Деоптимизация

### Пример с неожиданным типом

А теперь мы после этого цикла добавим еще один вызов с такими типами, с которыми мы внутри цикла не вызывали:

```javascript
// После миллиона итераций
sum([], {}); // Новая, неожиданная комбинация типов!
```

Вот мы пробуем так вызвать. Давайте ждем и видим, что случилось. Циклы все прошли нормально с оптимизацией, она подождала, а потом на выходе она говорит: "Все, случилось деоптимизация!"

### Почему происходит деоптимизация

Почему так произошло? Потому что мы миллион итераций прокрутили на оптимизированной функции. Она была оптимизирована - вот тут видите, она обнаружила целых (кстати, уже 16 разных типов) - 16 разных inline-кэшей. Это разные варианты с разными комбинациями типов.

Миллион раз прокрутилась оптимально, прокрутилась. И тут ей после цикла - такой прогретой, хорошо прогретой оптимизированной функции - вдруг получает какие-то неожиданные для нее аргументы. И все - случается вот такой вот вылет - это вылет в **деоптимизацию**.

### Fallback к интерпретации

Но код не падает, и тоже JavaScript - у него все случаи есть: интерпретатор. И скорее всего происходит **fallback к интерпретируемому коду**.

Можно почитать, что происходило. Достаточно подробный есть такой вывод. Ну сейчас это не быстро, не будем разбирать. Скорее всего произошел вылет в интерпретацию.

В принципе в виде интерпретации функция `sum` может быть вызвана не только с известными нами типами, а с чего угодно - абсолютно все чтобы туда можем передать. Функция без всякой, как бы один раз исполнится в виде интерпретируемого, без всякой оптимизации, без всякой компиляции.

### Решение проблемы

Если мы перенесем этот вызов сюда и будем вызывать это миллион раз с еще одним вызовом, то мы увидим, что деоптимизации не произойдет. Ведь нормально, потому что этот код успел прогреться.

Вот он уже тут с 16 разными inline-кэшами весь нормально оптимизировался. Вот мы сейчас забираем это дело сюда, перезапускаем, и видим, что же - 15 из 16. Вот этот как раз один - одна из форм вызова функции, вот она в конце, которая приводит потом к деоптимизации.

Ну на самом деле не только к функциям, массивам, к методам и свойствам применяется оптимизация - еще наверное применяется к глобальным свойствам.

## Глобальные переменные и оптимизация

### Пример с глобальной переменной

Ну как бы об этом тоже нужно сказать, хотя это конечно не самый лучший способ:

```javascript
global.x = 10;  // Глобальная переменная

function incGlobalX() {
  x++;
}

// Вызов миллион раз
for (let i = 0; i < 1000000; i++) {
  incGlobalX();
}

console.log(x);
```

Вот допустим тут у нас мы создаем глобальную переменную `x` - внутри `global` она теперь отовсюду будет видна просто как `x` из любых функций, любого места кода.

Теперь делаем две одну функцию - одну функцию `incGlobalX`. И тут мы просто инкрементируем этот `x`, ничего не возвращаем.

Опять-таки крутим миллион раз все это дело. У нас вот эта функция `incGlobalX` - мы же должны знать, какую ячейку в памяти нужно инкрементировать. То есть нам нужно вычислить адрес вот этого икса.

### Inline-кэши для глобальных переменных

Собственно, тут тоже будет сгенерирован inline-кэш. Как бы у этой функции скорее всего будет 2 или 3 inline-кэша:
- один для того, чтобы считывать значение `x`
- второй для того, чтобы записывать
- вполне возможно, что еще и для возвращения значения возвращается

Вполне возможно будет или 2, или 3 inline-кэша сгенерировано.

### Проблема с console.log

Давайте это дело тоже запустим. Тут нам тоже нужно поменять (потому что мы переименовывали эти файлики). Что мы видим? Мы видим, что все это вылетело с деоптимизацией.

Но вначале мы видим, что тут **6 inline-кэшей** генерировалось (точнее, 6 из них имеет заранее имеющуюся информацию про типы), а всего там 9 inline-кэшей.

Как нам избавиться от этой оптимизации, которая тут просто? Давайте посмотрим этот код.

### Устранение проблемы

Во-первых, мы видим, что весь этот код находится он просто в файле, не внутри какой-то функции. Скорее всего оптимизация в скрипте она на уровне функции происходит. Но корневая функция в файле - мы ее не видим. На самом деле файл обернут еще в еще одну функцию - он при считывании в нее оборачивается.

Вот это наружная функция - она может нормально не оптимизироваться. Давайте сделаем тут функцию `main` - мы все это обернем:

```javascript
function main() {
  for (let i = 0; i < 1000000; i++) {
    incGlobalX();
  }
}

main();
console.log(x);
```

Все-таки случается деоптимизация. Давайте вынесем глобальную переменную из функции `main` - все-таки случается до сих пор.

Давайте вынесем саму функцию, которая у нас генерирует кэши, вот так - и только цикл будем крутить внутри `main`. Тоже нехорошо.

Скорее всего вот что нужно сделать: нужна вот эта `console.log` - это `console.log` все портит. А все это дело можно туда и вернуть. Это на самом деле не особо важно уже.

То есть мы сначала `main` вызываем, а потом уже делаем `console.log`. То есть все оптимизации будет происходить внутри функции - этой функции или этой функции.

Видите, теперь уже деоптимизацию не вылетает. Сейчас посмотрим - futures оптимизировались. Вот функция `main` оптимизировалась - у нее три inline-кэша. `incGlobalX` тоже 3 кэша случилось. Вот они маркированы для оптимизации, а тут они скомпилированы - все хорошо.

### Вложенные функции

Давайте посмотрим, что случится, если мы одну функцию в другую положим. Как это смотреть? Я сюда добавил `--trace-deopt` и `--trace-opt` - то есть это мы можем запускать Node в V8 или D8, и с вот этими двумя ключами, чтобы мы могли видеть, что происходит с оптимизацией функции.

Так, ну вот мы переместили одну функцию в другую - положили - и видим, что в принципе она нормально оптимизируется. В каких-то версиях JavaScript старых она не умела так нормально оптимизировать.

Так, ну давайте переместим обращение к глобальной переменной сюда. Посмотрим тоже - как нас оптимизирует? Тоже нормально оптимизируется. Видите, тут просто стало больше inline-кэшей, и естественно почему стало больше - потому что она вот для этой строчки они появились.

Там было 4 из 5 с информацией про типы, там было 3 из 3 с информацией про типы. Ну вот так примерно это дело работает.

## Выводы и рекомендации

### Что мы можем из этого вынести

Что конечно же JavaScript внутри работает очень сложно. Что если мы будем писать JavaScript таким образом, как будто бы этот язык с типами, то он начнет разгоняться.

### Механизм оптимизации

И сам механизм разгона этого JavaScript - это механизм:
1. **Сначала интерпретации** - после интерпретации она пытается по типам догадаться, какие можно взять оптимизации, создать inline-кэши
2. **Потом значит** - мы вызываем эти функции с разными типами, происходит промах/попадание в кэш. То есть если она не находит, она ищет другие способы оптимизации и пытается один и тот же - обращение к свойству, или вызов метода, или оператор - насытить другими inline-кэшами
3. **Как только там их становится больше 4** - в каждом из операторов больше четырех - она тогда будет оптимизировать по глобальному кэшу

### Лучший вариант - мономорфный код

Ну и лучше всего конечно будет мощный тип работы - **мономорфный код работать**, в котором в каждом месте функции там вызывается метод, какое-то обращение к свойству или какой-то оператор вызывается возможно только один тип.

Такой код быстрее всего будет работать. В принципе там после того, как все насытится кэшами, потом еще можно будет произвести разные оптимизации.

### Проверки типов

Дело в том, что у нас перед каждой операцией, которая обращается к которая написана при помощи inline-кэша, происходит **проверка типа** - то есть проверка формы объекта или проверка формы переменной или типа переменной.

Если у нас один и тот же объект внутри функции, там к нему 10 разных обращений (к 10 разным свойствам или разным методам), то у нас проверка на то, является ли этот объект одной и той же формы, 10 раз происходит.

Все эти 10 вызовов можно свести к одному - при входе в функцию проверить тип, а дальше уже не проверять, а просто использовать эти кэши. А если в начале на входе у нас случится промах кэша, в этом случае мы тогда передадим этот код там на интерпретацию.

### Быстрый код

То есть у нас быстрее всего работает код мономорфный, когда у нас вот эти `if`'ы (которые проверяют в машинном коде, можем ли мы переиспользовать оптимизации) - этот код - значит все эти проверки будут выброшены, и он будет быстрее всего работать.

### Полиморфный код

В принципе, даже если у нас inline-кэшей много, то этот полиморфный код (как вы видели сегодня) достаточно хорошо оптимизируется. Он конечно уже не такой быстрый, но все равно оптимизируется.

### Мегаморфный код

Ну и **мегаморфный код** - это когда уже за счет там может быть все что угодно, и она сначала будет искать в каких-то глобальных кэшах. И если уже там не найдет, как с этим с этой формой объекта работать, то уже тогда будет интерпретировать.

Под интерпретацию там любые типы подойдут, всегда случится неявное преобразование типов. Это всегда долго, и такой код будет работать медленно, но тем не менее все равно сработает.

### Итого

Вот примерно такая ситуация у нас в JavaScript. Если у кого-то есть вопросы, то поднимайте руки, и сейчас отдам микрофончик.

## Вопросы и ответы

### Вопрос: Что такое скрытые классы, где их нужно применять?

Вам нигде их не нужно применять. Я как бы уже рассказал, ну я могу еще раз - если это немножко было непонятно.

Вот тут смотрите: **скрытые классы** они вычисляются оптимизирующим компилятором во время инстанцирования объекта или по ходу жизни этого объекта. И это структуры в памяти скрытых классов, которые позволяют заменить интерпретацию какого-то кода на оптимизированный типизированный inline-кэш на машинный код.

Вот в данном случае у нас, когда вызывается конструктор этого `Point`, он связывается с одним скрытым классом. Потом мы модифицируем его - он пересвязывается с другим скрытым классом. Мы нигде не пишем этого класса, мы не создаем этих классов - они **создаются на лету компилятором**.

Когда мы там второе свойство туда дописываем, на выходе из конструктора мы видим, что `instance` этого поинта он попрыгал между тремя скрытыми классами:
- сначала пустой
- потом форма `{ x: Number }`
- потом форма `{ x: Number, y: Number }`

Он три раза перешел из одного скрытого класса в другой.

Если мы начинаем создавать - ну так как бы после того, как вы один раз конструктор вызвали, у нас в памяти будет три скрытых класса. Когда мы второй раз вызываем этот конструктор, они заново не создаются. У нас просто связывается `instance` по ходу выполнения:
- в первой строчке с первым скрытым классом
- во второй строчке опять связывается со вторым
- и потом перепрыгивает на третий

Если мы вдруг вызовем в конструктор в качестве игрека передадим String, то создастся еще 3 скрытых класса после. Ну да, кстати, действительно создастся 3 скрытых класса. Ну и код внутри конструктора станет полиморфным кроме этого.

То есть кроме этого получится так, что вот в этой строчке будет стоять `if` на тип переменной `y` (аргумента `y`). И в случае если `y` одного типа, `point` будет связываться с одним скрытым классом. А если `y` другого типа, `point` будет связываться с другим скрытым классом.

Ну вот где-то так это происходит. То есть это все служебные структуры, с которыми мы не имеем дело. Но мы начинаем - если мы понимаем, как это работает, писать более оптимальный код.

### Рекомендации по написанию кода

Вы должны стараться писать код **мономорфным** и по типам, и думать всегда - представлять себе:
- какие inline-кэши возможны при вызове каждого оператора
- какие скрытые классы, как они будут выглядеть

Вот такое.

### Вопрос про console.log и деоптимизацию

Смотрите, дело в том что сама функция `console.log` - она же обращается к вот этой переменной `x`. И деоптимизация произошла - оптимизация всего файла, вот этой наружной функции как бы.

Мы в, кстати да - мы первым делом сделали там функцию `main` и поместили внутрь `main` `console.log`. Так вот функция `main` она прогрелась без вызова `console.log`.

То есть интерпретатор (точнее, runtime) не думал, что его придется к глобальной переменной `x` обращаться. Он очень долго - эта функция работала без обращения к этой переменной. У него не было обращение к этой переменной заменено на inline-кэш.

Он раньше обращался к этой переменной через вызов функции `incGlobalX` или как там называется - инкремент или что-то такое. То есть он раньше напрямую к этой переменной не обращался - он всегда обращался к другой функции. А то функция уже имела - и у каждой функции свой inline-кэш.

А у функции `main` не было этого inline-кэша, и она уже достаточно прогрелась - долго исполнялась там миллион итераций происходило. А тут вдруг его еще `console.log` делают. Конечно, ему приходится откатываться к интерпретации кода, находить адрес памяти, где находится этот `x`.

Да, да - ну то есть если естественно этот `main` будем еще несколько раз вызывать, то рано или поздно она реоптимизируется или скажет: "Извините, всегда буду интерпретировать эту функцию".

Вот такое. Так еще вопросы? Нет? Ну хорошо, спасибо тогда. Вопросы присылайте в Telegram или под видео. Спасибо!
