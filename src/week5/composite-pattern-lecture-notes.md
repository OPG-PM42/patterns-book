# Паттерн «Композит» (Composite) для JavaScript и TypeScript

## Обзор

**Композит** (Composite) — это структурный паттерн проектирования из набора GoF (Gang of Four), который позволяет работать со сложными иерархическими структурами данных через единый интерфейс. Паттерн скрывает сложность обхода древовидных структур и предоставляет унифицированный способ взаимодействия со всеми уровнями вложенности.

## Назначение паттерна

Паттерн Композит предназначен для:

- **Работы с иерархическими структурами** — упрощает взаимодействие с деревьями объектов
- **Сокрытия сложности** — избавляет от необходимости вручную обходить иерархию
- **Унификации интерфейса** — позволяет работать с отдельными объектами и их группами одинаково
- **Избежания условной логики** — вместо проверки типов через `if` используется полиморфизм

## Ключевая идея

Вместо того чтобы рекурсивно обходить иерархическую структуру и проверять с помощью условий (`if`), к какому классу принадлежит каждый элемент, паттерн Композит предоставляет **единый внешний интерфейс** для взаимодействия со всей вложенностью элементов.

## Практический пример: Корзина товаров

### Описание задачи

Типичный пример использования паттерна Композит — это **корзина товаров в интернет-магазине**, где:

- Есть отдельные **товары** (листья дерева)
- Есть **группы товаров** (узлы дерева)
- Есть **подгруппы** (вложенные узлы)
- У каждого элемента должен быть метод `getPrice()` для получения стоимости

При этом:
- У товара `getPrice()` просто возвращает цену из поля
- У группы `getPrice()` суммирует цены всех вложенных элементов
- У корзины `getPrice()` возвращает общую стоимость всех товаров

Таким образом, **один вызов извне** запускает цепочку вызовов внутри иерархии, и цена собирается из различных уровней глубины.

## Реализация на TypeScript

### Базовый интерфейс

```typescript
// Интерфейс, который будут реализовывать все элементы дерева
interface IPriced {
  readonly price: number;
}
```

**Ключевой момент**: Все элементы иерархии (и товары, и группы) реализуют один и тот же интерфейс `IPriced` с методом получения цены.

### Класс товара (Leaf — листовой элемент)

```typescript
// Листовой элемент — товар
class Product implements IPriced {
  private _price: number;

  constructor(price: number) {
    this._price = price;
  }

  // Геттер просто возвращает значение из поля
  get price(): number {
    return this._price;
  }
}
```

**Объяснение**:
- `Product` — это листовой элемент дерева (не содержит вложенных элементов)
- Метод `get price()` просто читает значение из приватного поля `_price`
- Это самый простой случай — нет вложенности, нет сложной логики

### Класс коллекции (Composite — композитный элемент)

```typescript
// Композитный элемент — коллекция товаров
class ProductCollection implements IPriced {
  private items: IPriced[] = [];

  add(item: IPriced): void {
    this.items.push(item);
  }

  // Геттер итерируется по всем элементам и суммирует их цены
  get price(): number {
    let total = 0;
    for (const item of this.items) {
      total += item.price; // Рекурсивный вызов price для каждого элемента
    }
    return total;
  }
}
```

**Объяснение**:
- `ProductCollection` — это композитный элемент, который содержит коллекцию других элементов
- Массив `items` хранит элементы типа `IPriced` (это могут быть как `Product`, так и другие `ProductCollection`)
- Метод `get price()` содержит цикл, который вызывает `price` для каждого вложенного элемента
- **Рекурсия**: если элемент — это тоже коллекция, то её `price` запустит свой цикл и так далее вглубь

### Использование паттерна

```typescript
// Создаём товары
const product1 = new Product(100);
const product2 = new Product(200);
const product3 = new Product(150);
const product4 = new Product(300);

// Создаём группу "Продукты питания"
const foodGroup = new ProductCollection();
foodGroup.add(product1);
foodGroup.add(product2);
foodGroup.add(product3);
foodGroup.add(product4);

// Создаём товары для другой группы
const textile1 = new Product(500);
const textile2 = new Product(400);

// Создаём группу "Текстиль"
const textileGroup = new ProductCollection();
textileGroup.add(textile1);
textileGroup.add(textile2);

// Создаём общую корзину покупок
const cart = new ProductCollection();
cart.add(foodGroup);
cart.add(textileGroup);

// Получаем общую стоимость одним вызовом
console.log(cart.price); // Выведет: 1650

// Можно получить цену отдельной группы
console.log(foodGroup.price); // Выведет: 750
console.log(textileGroup.price); // Выведет: 900
```

**Ключевые преимущества**:
- Снаружи мы **просто читаем свойство** `cart.price`, как будто это обычное поле
- Внутри же запускается **целая машинерия** рекурсивных вызовов
- Не нужно знать структуру дерева — интерфейс скрывает сложность
- Можно добавлять новые типы элементов без изменения существующего кода (принцип Open/Closed)

## Соблюдение принципов SOLID

### Open/Closed принцип

Благодаря общему интерфейсу `IPriced`:
- Можно добавлять новые классы элементов (например, `DiscountedProduct`, `BundleProduct`)
- Существующий код не нужно изменять
- Все новые классы должны лишь реализовать интерфейс `IPriced`

```typescript
// Новый тип элемента — товар со скидкой
class DiscountedProduct implements IPriced {
  private basePrice: number;
  private discount: number;

  constructor(basePrice: number, discount: number) {
    this.basePrice = basePrice;
    this.discount = discount;
  }

  get price(): number {
    return this.basePrice * (1 - this.discount);
  }
}

// Можно добавить в любую коллекцию без изменения её кода
const discounted = new DiscountedProduct(1000, 0.2); // 20% скидка
foodGroup.add(discounted);
```

## Альтернативный подход: Рекурсия в JavaScript

В JavaScript можно решить подобные задачи без использования классов и паттерна Композит, применяя функциональный подход с рекурсией.

### Простой случай: двухуровневая структура

```javascript
// Структура данных: массив групп, каждая группа содержит массив товаров
const orders = [
  {
    name: 'Продукты',
    items: [
      { name: 'Хлеб', price: 50 },
      { name: 'Молоко', price: 80 },
      { name: 'Яйца', price: 120 }
    ]
  },
  {
    name: 'Текстиль',
    items: [
      { name: 'Полотенце', price: 300 },
      { name: 'Простынь', price: 500 }
    ]
  }
];

// Функция подсчёта общей стоимости
function calculateTotal(orders) {
  let total = 0;

  // Итерируемся по группам (внешний цикл)
  for (const group of orders) {
    // Суммируем цены товаров в каждой группе (reduce)
    total += group.items.reduce((sum, item) => sum + item.price, 0);
  }

  return total;
}

console.log(calculateTotal(orders)); // Выведет: 1050
```

**Особенности**:
- Используется цикл `for...of` для обхода групп
- Используется метод `reduce()` для суммирования цен товаров
- **Небольшая непоследовательность**: два разных способа итерации
- Компактный код благодаря возможностям JavaScript

### Сложный случай: многоуровневая иерархия

Когда структура усложняется (группы могут содержать подгруппы и товары вперемешку):

```javascript
// Сложная структура: группы могут содержать подгруппы и товары
const purchase = {
  electronics: {
    computers: {
      laptop: { price: 50000 },
      desktop: { price: 40000 }
    },
    phones: {
      smartphone: { price: 30000 }
    },
    tablet: { price: 25000 } // Товар напрямую в группе
  },
  clothing: {
    shirts: { price: 1500 },
    pants: { price: 2500 }
  }
};

// Рекурсивная функция для обхода произвольной глубины
function calculateTotal(order) {
  // Приводим к массиву: если массив — оставляем, если объект — берём значения
  const items = Array.isArray(order) ? order : Object.values(order);

  // Проходим по элементам и суммируем
  return items.reduce((sum, item) => {
    // Если есть поле price и оно число — это товар, добавляем к сумме
    if (typeof item.price === 'number') {
      return sum + item.price;
    }
    // Иначе это группа — рекурсивно вызываем для неё calculateTotal
    return sum + calculateTotal(item);
  }, 0);
}

console.log(calculateTotal(purchase)); // Выведет общую сумму всех товаров
```

**Ключевые особенности**:

1. **Приведение к единому интерфейсу**:
   - `Array.isArray(order) ? order : Object.values(order)`
   - Превращаем любую структуру в массив для единообразного обхода

2. **Проверка типа элемента**:
   - `typeof item.price === 'number'` — если есть числовое поле `price`, это товар
   - Иначе это группа, и нужен рекурсивный вызов

3. **Одна логика обхода**:
   - Используется только `reduce()`, нет смешивания разных способов итерации
   - Рекурсия работает на любую глубину вложенности

4. **Консистентность**:
   - Вся логика сводится к одному условию (`if`)
   - Не нужно вручную писать вложенные циклы

## Сравнение подходов

### Паттерн Композит (классы и интерфейсы)

**Преимущества**:
- ✅ Чёткая структура и типизация (особенно в TypeScript)
- ✅ Соответствие принципам ООП (полиморфизм, инкапсуляция)
- ✅ Легко добавлять новые типы элементов (Open/Closed)
- ✅ Понятная семантика — каждый класс имеет явную роль
- ✅ Скрывает сложность обхода дерева

**Недостатки**:
- ❌ Больше кода (классы, интерфейсы, конструкторы)
- ❌ Performance penalty — накладные расходы на абстракции
- ❌ Может быть избыточным для простых задач

### Функциональный подход (рекурсия)

**Преимущества**:
- ✅ Компактный код
- ✅ Меньше абстракций — проще понять
- ✅ Хорошо подходит для JavaScript-экосистемы
- ✅ Нет накладных расходов на создание объектов

**Недостатки**:
- ❌ Требует понимания рекурсии
- ❌ Сложнее добавлять новое поведение
- ❌ Логика обхода смешана с бизнес-логикой
- ❌ Может быть сложно отлаживать при глубокой вложенности

## Когда использовать паттерн Композит

### Используйте, когда:

1. **Иерархическая структура данных** — работаете с древовидными структурами (меню, файловые системы, DOM)
2. **Единый интерфейс** — нужно обрабатывать отдельные объекты и композиции одинаково
3. **Сложная логика** — у разных типов элементов разное поведение, но общий интерфейс
4. **Расширяемость** — планируется добавление новых типов элементов
5. **Типизация важна** — работаете с TypeScript и нужна строгая типизация

### Не используйте, когда:

1. **Простая структура** — всего 1-2 уровня вложенности
2. **Производительность критична** — каждая миллисекунда важна
3. **Функциональный стиль** — проект придерживается функционального программирования
4. **Малый объём кода** — паттерн будет избыточным для простой задачи

## Производительность (Performance Penalty)

### Накладные расходы паттерна Композит:

```typescript
// С паттерном Композит
get price(): number {
  let total = 0;
  for (const item of this.items) {
    total += item.price; // Вызов метода через интерфейс (виртуальный вызов)
  }
  return total;
}

// Прямой доступ к данным (быстрее)
function getPrice(items) {
  let total = 0;
  for (const item of items) {
    total += item.price; // Прямой доступ к свойству
  }
  return total;
}
```

**Что добавляет накладные расходы**:
- Создание объектов классов
- Вызовы методов через интерфейс (виртуальные вызовы)
- Дополнительные проверки типов в runtime
- Память под хранение объектов

**Когда это важно**:
- Обработка больших объёмов данных (тысячи элементов)
- Частые вызовы в горячих путях кода
- Приложения реального времени

**Когда это не критично**:
- Работа с пользовательским интерфейсом
- Бизнес-логика с небольшими объёмами данных
- Код, который выполняется редко

## Преимущества и компромиссы

### Что даёт паттерн Композит

1. **Упрощение и улучшение понятности кода** — скрывает сложность обхода иерархии
2. **Полиморфизм** — можно работать с объектами разных типов через общий интерфейс
3. **Избежание условной логики** — не нужно проверять типы элементов через `if`
4. **Гибкость** — легко добавлять новые типы элементов

### Компромиссы

1. **Дополнительный код** — нужно писать классы, интерфейсы, методы
2. **Накладные расходы** — абстракции требуют дополнительных вычислительных ресурсов
3. **Сложность для простых задач** — может быть избыточным для примитивных структур

## Важные моменты реализации

### 1. Геттеры в TypeScript

```typescript
// Использование геттера делает синтаксис более естественным
get price(): number {
  return this._price;
}

// Вызов выглядит как чтение свойства
console.log(product.price); // Вместо product.getPrice()
```

**В JavaScript это менее распространено** — обычно используют обычные методы:

```javascript
// Более типичный подход для JavaScript
getPrice() {
  return this._price;
}

// Явный вызов метода
console.log(product.getPrice());
```

### 2. Рекурсивные вызовы

```typescript
// Композитный элемент вызывает методы вложенных элементов
get price(): number {
  let total = 0;
  for (const item of this.items) {
    total += item.price; // Может быть как Product, так и ProductCollection
  }
  return total;
}
```

**Важно**: геттер в `ProductCollection` вызывает геттер для каждого элемента, что создаёт рекурсию при наличии вложенных коллекций.

### 3. Типизация в TypeScript

```typescript
// Массив хранит элементы базового типа
private items: IPriced[] = [];

// Можем добавлять любые объекты, реализующие IPriced
add(item: IPriced): void {
  this.items.push(item);
}
```

Благодаря интерфейсу `IPriced` компилятор TypeScript гарантирует, что все элементы имеют свойство `price`.

## Практические примеры использования

### 1. Файловая система

```typescript
interface IFileSystemItem {
  readonly size: number;
  readonly name: string;
}

class File implements IFileSystemItem {
  constructor(
    public readonly name: string,
    public readonly size: number
  ) {}
}

class Directory implements IFileSystemItem {
  private items: IFileSystemItem[] = [];

  constructor(public readonly name: string) {}

  add(item: IFileSystemItem): void {
    this.items.push(item);
  }

  get size(): number {
    return this.items.reduce((sum, item) => sum + item.size, 0);
  }
}

// Использование
const root = new Directory('root');
const documents = new Directory('Documents');
const photos = new Directory('Photos');

documents.add(new File('report.pdf', 1024));
documents.add(new File('notes.txt', 256));

photos.add(new File('photo1.jpg', 2048));
photos.add(new File('photo2.jpg', 3072));

root.add(documents);
root.add(photos);

console.log(root.size); // Общий размер всех файлов
```

### 2. Меню интерфейса

```typescript
interface IMenuItem {
  render(): string;
}

class MenuItem implements IMenuItem {
  constructor(private label: string, private url: string) {}

  render(): string {
    return `<a href="${this.url}">${this.label}</a>`;
  }
}

class MenuGroup implements IMenuItem {
  private items: IMenuItem[] = [];

  constructor(private label: string) {}

  add(item: IMenuItem): void {
    this.items.push(item);
  }

  render(): string {
    const itemsHtml = this.items.map(item => item.render()).join('');
    return `<div class="menu-group">
      <span>${this.label}</span>
      <div class="submenu">${itemsHtml}</div>
    </div>`;
  }
}
```

## Резюме

### Ключевые концепции

1. **Композит** — структурный паттерн для работы с иерархическими структурами
2. **Единый интерфейс** — все элементы дерева реализуют общий интерфейс
3. **Рекурсия** — композитные элементы вызывают методы вложенных элементов
4. **Полиморфизм** — не нужно проверять типы, все работают через интерфейс

### Альтернативы в JavaScript

- **Функциональная рекурсия** — часто более подходящий вариант для JavaScript
- **Методы массивов** — `reduce()`, `map()`, `filter()` упрощают обход структур
- **Object.values()** — позволяет привести объекты к массивам для единообразной обработки

### Выбор подхода

**Композит через классы** — когда важна структура, типизация, расширяемость
**Функциональная рекурсия** — когда важна простота, производительность, стиль JavaScript

### Главное правило

Используйте паттерн Композит, когда **выгода от упрощения и структурирования кода** перевешивает **накладные расходы на дополнительные абстракции**.

## Дополнительные материалы

### Связанные паттерны

- **Iterator** — часто используется вместе с Композитом для обхода дерева
- **Visitor** — позволяет добавлять операции к элементам структуры
- **Decorator** — можно комбинировать для добавления функциональности

### Принципы SOLID

- **Open/Closed** — открыт для расширения, закрыт для модификации
- **Dependency Inversion** — зависимость от абстракции (интерфейса), а не от конкретных классов
- **Interface Segregation** — узкий интерфейс для конкретной задачи

### Когда избегать рекурсии

⚠️ **Ограничение стека вызовов** — при очень глубокой вложенности может произойти переполнение стека

```javascript
// Для очень глубоких структур лучше использовать итеративный подход
function calculateTotalIterative(root) {
  const stack = [root];
  let total = 0;

  while (stack.length > 0) {
    const item = stack.pop();

    if (typeof item.price === 'number') {
      total += item.price;
    } else {
      const children = Object.values(item);
      stack.push(...children);
    }
  }

  return total;
}
```

---

**Автор**: Конспект лекции о паттерне Композит (GoF)
**Язык**: JavaScript, TypeScript
**Уровень**: Средний / Продвинутый
