<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Factory Method - Patterns</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Patterns</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Паттерн-factory-method-Фабричный-метод"><a class="header" href="#Паттерн-factory-method-Фабричный-метод">Паттерн Factory Method (Фабричный метод)</a></h1>
<h2 id="Введение"><a class="header" href="#Введение">Введение</a></h2>
<p><strong>Factory Method</strong> (Фабричный метод) — это порождающий паттерн проектирования из книги Gang of Four, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.</p>
<h3 id="Терминология"><a class="header" href="#Терминология">Терминология</a></h3>
<p>В различных языках программирования и контекстах можно встретить разные названия:</p>
<ul>
<li><strong>Factory Method</strong> — фабричный метод</li>
<li><strong>Factory</strong> — фабрика (иногда так называют этот паттерн, но важно уточнять, что именно имеется в виду)</li>
<li><strong>Abstract Factory</strong> — абстрактная фабрика (это другой паттерн!)</li>
</ul>
<p><strong>Важно</strong>: Всегда уточняйте, о каком именно паттерне идёт речь — Factory Method или Abstract Factory, так как они решают разные задачи.</p>
<hr />
<h2 id="Ключевые-отличия-от-abstract-factory"><a class="header" href="#Ключевые-отличия-от-abstract-factory">Ключевые отличия от Abstract Factory</a></h2>
<h3 id="abstract-factory"><a class="header" href="#abstract-factory">Abstract Factory</a></h3>
<ul>
<li>Имеет <strong>несколько методов</strong> для создания объектов</li>
<li>Каждый метод создаёт экземпляры <strong>разных контрактов</strong></li>
<li>Создаёт семейства связанных объектов</li>
</ul>
<h3 id="factory-method"><a class="header" href="#factory-method">Factory Method</a></h3>
<ul>
<li><strong>Один метод</strong> для создания объектов</li>
<li>Переход от использования оператора <code>new</code> к вызову метода</li>
<li>Создаёт объекты одного контракта, но разных реализаций</li>
</ul>
<hr />
<h2 id="Основная-идея-паттерна"><a class="header" href="#Основная-идея-паттерна">Основная идея паттерна</a></h2>
<h3 id="Проблема"><a class="header" href="#Проблема">Проблема</a></h3>
<p>В коде напрямую используется оператор <code>new</code> для создания экземпляров классов:</p>
<pre><code class="language-javascript">// Проблема: жёсткая связанность с конкретным классом
const product = new ConcreteProduct();
</code></pre>
<p>Это создаёт <strong>сильное зацепление</strong> (tight coupling) между кодом и конкретными классами.</p>
<h3 id="Решение"><a class="header" href="#Решение">Решение</a></h3>
<p>Factory Method предлагает заменить прямое создание объектов вызовом специального метода:</p>
<pre><code class="language-javascript">// Решение: создание через фабричный метод
const product = creator.factoryMethod();
</code></pre>
<h3 id="Цели-паттерна"><a class="header" href="#Цели-паттерна">Цели паттерна</a></h3>
<ol>
<li><strong>Снизить зацепление (coupling)</strong> между компонентами системы</li>
<li><strong>Подставлять различные фабрики</strong> в зависимости от контекста</li>
<li><strong>Делегировать создание объектов</strong> другим частям программы</li>
<li>Подготовить код к использованию паттерна <strong>Strategy</strong></li>
</ol>
<hr />
<h2 id="Классическая-реализация"><a class="header" href="#Классическая-реализация">Классическая реализация</a></h2>
<h3 id="Структура-паттерна"><a class="header" href="#Структура-паттерна">Структура паттерна</a></h3>
<pre><code>AbstractCreator
    └── factoryMethod(): AbstractProduct
         ↑
         |
ConcreteCreator
    └── factoryMethod(): ConcreteProduct
                              ↓
                         (extends AbstractProduct)
</code></pre>
<h3 id="javascript-реализация-классическая"><a class="header" href="#javascript-реализация-классическая">JavaScript реализация (классическая)</a></h3>
<pre><code class="language-javascript">// Абстрактный продукт
class AbstractProduct {
  constructor() {
    if (new.target === AbstractProduct) {
      throw new Error('Cannot instantiate abstract class');
    }
  }

  operation() {
    throw new Error('Abstract method must be implemented');
  }
}

// Конкретный продукт
class ConcreteProduct extends AbstractProduct {
  constructor(value) {
    super();
    this.value = value;
  }

  operation() {
    return `ConcreteProduct operation with value: ${this.value}`;
  }
}

// Абстрактный создатель (Creator)
class AbstractCreator {
  constructor() {
    if (new.target === AbstractCreator) {
      throw new Error('Cannot instantiate abstract class');
    }
  }

  // Фабричный метод — заглушка
  factoryMethod() {
    throw new Error('Abstract factory method must be implemented');
  }

  // Другие методы могут использовать фабричный метод
  someOperation() {
    const product = this.factoryMethod();
    return product.operation();
  }
}

// Конкретный создатель
class ConcreteCreator extends AbstractCreator {
  factoryMethod() {
    // Вызов оператора new скрыт внутри метода
    return new ConcreteProduct('example');
  }
}

// Использование
const creator = new ConcreteCreator();
const product = creator.factoryMethod();
console.log(product.operation());
// Вывод: ConcreteProduct operation with value: example
</code></pre>
<p><strong>Ключевая идея</strong>: Мы переходим от прямого инстанцирования через <code>new</code> к вызову метода, который скрывает детали создания объекта.</p>
<hr />
<h2 id="typescript-реализация"><a class="header" href="#typescript-реализация">TypeScript реализация</a></h2>
<p>TypeScript позволяет использовать настоящие абстрактные классы и методы, что делает код более типобезопасным.</p>
<h3 id="Пример-с-абстрактными-классами"><a class="header" href="#Пример-с-абстрактными-классами">Пример с абстрактными классами</a></h3>
<pre><code class="language-typescript">// Абстрактный продукт
abstract class AbstractProduct {
  abstract operation(): string;
}

// Конкретный продукт
class ConcreteProduct extends AbstractProduct {
  constructor(private value: string) {
    super();
  }

  operation(): string {
    return `ConcreteProduct operation with value: ${this.value}`;
  }
}

// Абстрактный создатель
abstract class AbstractCreator {
  // Абстрактный фабричный метод
  abstract factoryMethod(): AbstractProduct;

  // Конкретный метод, который может использовать фабричный метод
  someOperation(): string {
    const product = this.factoryMethod();
    return product.operation();
  }
}

// Конкретный создатель
class ConcreteCreator extends AbstractCreator {
  factoryMethod(): AbstractProduct {
    return new ConcreteProduct('TypeScript example');
  }
}

// Использование
const creator: AbstractCreator = new ConcreteCreator();
const product = creator.factoryMethod();
console.log(product.operation());
// Вывод: ConcreteProduct operation with value: TypeScript example
</code></pre>
<p><strong>Преимущества TypeScript</strong>:</p>
<ul>
<li>Компилятор проверяет реализацию всех абстрактных методов</li>
<li>Не нужны проверки <code>new.target</code> и выбрасывание ошибок</li>
<li>Лучшая поддержка IDE (автодополнение, рефакторинг)</li>
<li>Типобезопасность на этапе компиляции</li>
</ul>
<h3 id="Замечания-по-абстрактным-классам"><a class="header" href="#Замечания-по-абстрактным-классам">Замечания по абстрактным классам</a></h3>
<p>В абстрактных классах могут быть:</p>
<ul>
<li><strong>Абстрактные методы</strong> — должны быть реализованы в наследниках</li>
<li><strong>Конкретные методы</strong> — наследники могут их переопределить (но не обязаны)</li>
</ul>
<pre><code class="language-typescript">abstract class Creator {
  // Абстрактный метод — обязателен для реализации
  abstract factoryMethod(): Product;

  // Конкретный метод — может быть переопределён
  createProduct(): Product {
    console.log('Default product creation logic');
    return this.factoryMethod();
  }
}
</code></pre>
<hr />
<h2 id="javascript-идиоматичный-подход"><a class="header" href="#javascript-идиоматичный-подход">JavaScript-идиоматичный подход</a></h2>
<p>В JavaScript не обязательно использовать классы. Фабрика может быть простой функцией.</p>
<h3 id="Простая-функция-фабрика"><a class="header" href="#Простая-функция-фабрика">Простая функция-фабрика</a></h3>
<pre><code class="language-javascript">// Продукт — простой объект или класс
class Product {
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }

  describe() {
    return `Product of type "${this.type}" with value: ${this.value}`;
  }
}

// Фабричная функция
function createProduct(type, value) {
  return new Product(type, value);
}

// Экспорт из модуля
export { createProduct };

// Использование
import { createProduct } from './product-factory.js';

const product = createProduct('standard', 100);
console.log(product.describe());
// Вывод: Product of type "standard" with value: 100
</code></pre>
<h3 id="Коллекция-фабрик"><a class="header" href="#Коллекция-фабрик">Коллекция фабрик</a></h3>
<p>Один из распространённых подходов в JavaScript — хранить фабрики в объекте и выбирать нужную по ключу:</p>
<pre><code class="language-javascript">// Разные типы продуктов
class StandardProduct {
  constructor(value) {
    this.type = 'standard';
    this.value = value;
  }

  calculate() {
    return this.value;
  }
}

class PremiumProduct {
  constructor(value) {
    this.type = 'premium';
    this.value = value;
  }

  calculate() {
    return this.value * 1.5; // Премиум-множитель
  }
}

// Коллекция фабрик
const productFactories = {
  standard: (value) =&gt; new StandardProduct(value),
  premium: (value) =&gt; new PremiumProduct(value),
};

// Функция для получения фабрики по ключу
function getFactory(type) {
  const factory = productFactories[type];
  if (!factory) {
    throw new Error(`Unknown product type: ${type}`);
  }
  return factory;
}

// Использование
const factory = getFactory('premium');
const product = factory(100);
console.log(product.calculate()); // Вывод: 150
</code></pre>
<h3 id="Передача-фабрики-как-аргумента"><a class="header" href="#Передача-фабрики-как-аргумента">Передача фабрики как аргумента</a></h3>
<p>Мощная идиома JavaScript — передавать фабрику в другие функции:</p>
<pre><code class="language-javascript">// Функция высшего порядка, принимающая фабрику
function processItems(items, factory) {
  return items.map(item =&gt; {
    const product = factory(item);
    return product.calculate();
  });
}

// Использование с разными фабриками
const standardFactory = (value) =&gt; new StandardProduct(value);
const premiumFactory = (value) =&gt; new PremiumProduct(value);

const values = [10, 20, 30];

const standardResults = processItems(values, standardFactory);
console.log(standardResults); // [10, 20, 30]

const premiumResults = processItems(values, premiumFactory);
console.log(premiumResults); // [15, 30, 45]
</code></pre>
<p><strong>Преимущество</strong>: Инстанцирование происходит не в нашем коде, а в другой части программы, которая получила фабрику как dependency.</p>
<hr />
<h2 id="Практический-пример-database-и-cursor"><a class="header" href="#Практический-пример-database-и-cursor">Практический пример: Database и Cursor</a></h2>
<p>Рассмотрим реалистичный пример работы с базами данных и курсорами.</p>
<h3 id="Структура"><a class="header" href="#Структура">Структура</a></h3>
<pre><code>Database (abstract)
  ├── constructor (abstract)
  ├── select() → Cursor (abstract)
  │
  ├── FileDatabase (concrete)
  │   ├── select() → FileCursor
  │
  └── SqlDatabase (concrete)
      └── select() → SqlCursor

Cursor (abstract)
  └── [Symbol.iterator]() (abstract)
      │
      ├── FileCursor (concrete)
      │   └── итерирует строки из файла
      │
      └── SqlCursor (concrete)
          └── итерирует записи из SQL
</code></pre>
<h3 id="typescript-реализация-1"><a class="header" href="#typescript-реализация-1">TypeScript реализация</a></h3>
<pre><code class="language-typescript">// ========================================
// Абстрактный курсор
// ========================================
abstract class Cursor {
  // Абстрактный итератор
  abstract [Symbol.iterator](): Iterator&lt;any&gt;;
}

// ========================================
// Абстрактная база данных
// ========================================
abstract class Database {
  // Абстрактный конструктор
  constructor() {}

  // Фабричный метод — возвращает курсор
  abstract select(query: string): Cursor;
}

// ========================================
// Конкретная реализация: File Database
// ========================================
class FileCursor extends Cursor {
  constructor(private filePath: string) {
    super();
  }

  *[Symbol.iterator]() {
    // Чтение файла построчно
    const fs = require('fs');
    const lines = fs.readFileSync(this.filePath, 'utf-8').split('\n');

    for (const line of lines) {
      if (line.trim()) {
        yield line;
      }
    }
  }
}

class FileDatabase extends Database {
  constructor(private basePath: string) {
    super();
  }

  // Реализация фабричного метода
  select(query: string): Cursor {
    // query здесь — имя файла
    const filePath = `${this.basePath}/${query}`;
    return new FileCursor(filePath); // Создание курсора через new скрыто здесь
  }
}

// ========================================
// Конкретная реализация: SQL Database (mock)
// ========================================
class SqlCursor extends Cursor {
  constructor(private rows: any[]) {
    super();
  }

  *[Symbol.iterator]() {
    for (const row of this.rows) {
      yield row;
    }
  }
}

class SqlDatabase extends Database {
  constructor(private connectionString: string) {
    super();
  }

  // Реализация фабричного метода
  select(query: string): Cursor {
    // Mock: имитируем выполнение SQL запроса
    console.log(`Executing SQL: ${query}`);
    const mockRows = [
      { id: 1, name: 'Alice' },
      { id: 2, name: 'Bob' },
    ];
    return new SqlCursor(mockRows); // Создание курсора
  }
}

// ========================================
// Использование
// ========================================

// Работа с файловой БД
const fileDb: Database = new FileDatabase('./data');
const fileCursor = fileDb.select('users.txt');

for (const line of fileCursor) {
  console.log('File row:', line);
}

// Работа с SQL БД
const sqlDb: Database = new SqlDatabase('host=localhost;db=test');
const sqlCursor = sqlDb.select('SELECT * FROM users');

for (const row of sqlCursor) {
  console.log('SQL row:', row);
}
</code></pre>
<p><strong>Ключевые моменты</strong>:</p>
<ol>
<li>Клиентский код работает с абстракцией <code>Database</code> и не знает о конкретных классах</li>
<li>Метод <code>select()</code> — это фабричный метод, который создаёт конкретные курсоры</li>
<li>Вместо <code>new FileCursor()</code> в клиентском коде мы вызываем <code>db.select()</code></li>
<li>Легко добавить новые типы БД без изменения клиентского кода</li>
</ol>
<h3 id="javascript-упрощённая-версия"><a class="header" href="#javascript-упрощённая-версия">JavaScript упрощённая версия</a></h3>
<pre><code class="language-javascript">// Фабрики для создания курсоров
function createFileCursor(filePath) {
  const fs = require('fs');
  const lines = fs.readFileSync(filePath, 'utf-8').split('\n');

  return {
    [Symbol.iterator]: function* () {
      for (const line of lines) {
        if (line.trim()) yield line;
      }
    }
  };
}

function createSqlCursor(query) {
  console.log(`Executing SQL: ${query}`);
  const mockRows = [
    { id: 1, name: 'Alice' },
    { id: 2, name: 'Bob' },
  ];

  return {
    [Symbol.iterator]: function* () {
      for (const row of mockRows) {
        yield row;
      }
    }
  };
}

// Фабрика баз данных
function createDatabase(type, config) {
  if (type === 'file') {
    return {
      select(query) {
        return createFileCursor(`${config.basePath}/${query}`);
      }
    };
  }

  if (type === 'sql') {
    return {
      select(query) {
        return createSqlCursor(query);
      }
    };
  }

  throw new Error(`Unknown database type: ${type}`);
}

// Использование
const db = createDatabase('sql', {});
const cursor = db.select('SELECT * FROM users');

for (const row of cursor) {
  console.log('Row:', row);
}
</code></pre>
<hr />
<h2 id="Преимущества-паттерна-factory-method"><a class="header" href="#Преимущества-паттерна-factory-method">Преимущества паттерна Factory Method</a></h2>
<h3 id="1-Снижение-зацепления-low-coupling"><a class="header" href="#1-Снижение-зацепления-low-coupling">1. Снижение зацепления (Low Coupling)</a></h3>
<pre><code class="language-javascript">// ❌ Плохо: жёсткая связанность
class OrderProcessor {
  processOrder(orderData) {
    const order = new StandardOrder(orderData); // Зависимость от конкретного класса
    return order.process();
  }
}

// ✅ Хорошо: слабое зацепление через фабрику
class OrderProcessor {
  constructor(orderFactory) {
    this.orderFactory = orderFactory;
  }

  processOrder(orderData) {
    const order = this.orderFactory.create(orderData); // Абстракция
    return order.process();
  }
}
</code></pre>
<h3 id="2-Гибкость-и-расширяемость"><a class="header" href="#2-Гибкость-и-расширяемость">2. Гибкость и расширяемость</a></h3>
<p>Легко добавлять новые типы продуктов без изменения существующего кода:</p>
<pre><code class="language-javascript">// Добавление нового типа продукта
class ExpressOrder extends Order {
  process() {
    return 'Express order processed with priority!';
  }
}

// Добавление новой фабрики
class ExpressOrderFactory {
  create(data) {
    return new ExpressOrder(data);
  }
}

// Клиентский код не меняется!
const processor = new OrderProcessor(new ExpressOrderFactory());
</code></pre>
<h3 id="3-Единая-точка-создания-объектов"><a class="header" href="#3-Единая-точка-создания-объектов">3. Единая точка создания объектов</a></h3>
<p>Вся логика создания сосредоточена в одном месте:</p>
<pre><code class="language-javascript">class UserFactory {
  create(userData) {
    // Валидация
    if (!userData.email) {
      throw new Error('Email is required');
    }

    // Нормализация данных
    userData.email = userData.email.toLowerCase();

    // Логирование
    console.log('Creating user:', userData.email);

    // Создание
    return new User(userData);
  }
}
</code></pre>
<h3 id="4-Подготовка-к-тестированию"><a class="header" href="#4-Подготовка-к-тестированию">4. Подготовка к тестированию</a></h3>
<p>Легко подменить реальные объекты на mock-объекты:</p>
<pre><code class="language-javascript">// Продакшн
const realDatabase = new SqlDatabase('production-connection');
const service = new DataService(realDatabase);

// Тестирование
const mockDatabase = new MockDatabase();
const service = new DataService(mockDatabase);
</code></pre>
<h3 id="5-Инверсия-управления-ioc"><a class="header" href="#5-Инверсия-управления-ioc">5. Инверсия управления (IoC)</a></h3>
<p>Создание объектов делегируется внешнему коду:</p>
<pre><code class="language-javascript">function processData(items, factory) {
  // Эта функция не знает, какие именно объекты создаются
  return items.map(item =&gt; {
    const processor = factory(item);
    return processor.process();
  });
}

// Внедрение зависимости
const results = processData(data, createStandardProcessor);
</code></pre>
<hr />
<h2 id="Недостатки-и-когда-НЕ-использовать"><a class="header" href="#Недостатки-и-когда-НЕ-использовать">Недостатки и когда НЕ использовать</a></h2>
<h3 id="Недостатки"><a class="header" href="#Недостатки">Недостатки</a></h3>
<ol>
<li><strong>Усложнение кода</strong> — появляется больше классов и абстракций</li>
<li><strong>Избыточность для простых случаев</strong> — если у вас только один тип продукта</li>
<li><strong>Косвенность</strong> — менее очевидно, какой именно класс будет создан</li>
</ol>
<h3 id="Когда-НЕ-использовать"><a class="header" href="#Когда-НЕ-использовать">Когда НЕ использовать</a></h3>
<pre><code class="language-javascript">// ❌ Избыточно для простого случая
class ButtonFactory {
  createButton() {
    return new Button(); // Всегда одна и та же кнопка
  }
}

// ✅ Просто используйте конструктор
const button = new Button();
</code></pre>
<h3 id="Когда-использовать"><a class="header" href="#Когда-использовать">Когда использовать</a></h3>
<ol>
<li><strong>Заранее неизвестен тип создаваемых объектов</strong></li>
<li><strong>Нужно делегировать создание подклассам</strong></li>
<li><strong>Хотите локализовать логику создания</strong> в одном месте</li>
<li><strong>Готовитесь к расширению</strong> системы новыми типами</li>
<li><strong>Нужна возможность переключения</strong> между разными реализациями</li>
</ol>
<hr />
<h2 id="Связь-с-другими-паттернами"><a class="header" href="#Связь-с-другими-паттернами">Связь с другими паттернами</a></h2>
<h3 id="factory-method--strategy"><a class="header" href="#factory-method--strategy">Factory Method + Strategy</a></h3>
<p>Factory Method часто используется совместно с паттерном Strategy:</p>
<pre><code class="language-javascript">// Стратегии обработки
class StandardProcessingStrategy {
  process(data) {
    return data.toUpperCase();
  }
}

class FastProcessingStrategy {
  process(data) {
    return data.substring(0, 10);
  }
}

// Фабрика стратегий
class StrategyFactory {
  create(type) {
    switch (type) {
      case 'standard':
        return new StandardProcessingStrategy();
      case 'fast':
        return new FastProcessingStrategy();
      default:
        throw new Error(`Unknown strategy: ${type}`);
    }
  }
}

// Использование
class DataProcessor {
  constructor(strategyFactory) {
    this.strategyFactory = strategyFactory;
  }

  process(data, strategyType) {
    const strategy = this.strategyFactory.create(strategyType);
    return strategy.process(data);
  }
}

const processor = new DataProcessor(new StrategyFactory());
console.log(processor.process('hello world', 'standard')); // HELLO WORLD
console.log(processor.process('hello world', 'fast'));     // hello worl
</code></pre>
<h3 id="factory-method-vs-abstract-factory"><a class="header" href="#factory-method-vs-abstract-factory">Factory Method vs Abstract Factory</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Аспект</th><th>Factory Method</th><th>Abstract Factory</th></tr></thead><tbody>
<tr><td>Методов</td><td>Один метод</td><td>Несколько методов</td></tr>
<tr><td>Продуктов</td><td>Один тип продукта</td><td>Семейство связанных продуктов</td></tr>
<tr><td>Наследование</td><td>Использует наследование</td><td>Использует композицию</td></tr>
<tr><td>Пример</td><td><code>createButton()</code></td><td><code>createButton()</code>, <code>createInput()</code>, <code>createCheckbox()</code></td></tr>
</tbody></table>
</div>
<h3 id="factory-method--template-method"><a class="header" href="#factory-method--template-method">Factory Method + Template Method</a></h3>
<pre><code class="language-javascript">abstract class DataImporter {
  // Template Method
  import(filePath) {
    const data = this.readFile(filePath);
    const parsed = this.parse(data);
    const validated = this.validate(parsed);
    return this.save(validated);
  }

  // Factory Method
  abstract createParser(): Parser;

  parse(data) {
    const parser = this.createParser(); // Фабричный метод
    return parser.parse(data);
  }

  abstract readFile(path): string;
  abstract validate(data): any;
  abstract save(data): void;
}
</code></pre>
<hr />
<h2 id="Реальные-примеры-из-практики"><a class="header" href="#Реальные-примеры-из-практики">Реальные примеры из практики</a></h2>
<h3 id="Пример-1-Логирование"><a class="header" href="#Пример-1-Логирование">Пример 1: Логирование</a></h3>
<pre><code class="language-javascript">// Абстрактный логгер
class Logger {
  log(message) {
    throw new Error('Method must be implemented');
  }
}

// Конкретные логгеры
class ConsoleLogger extends Logger {
  log(message) {
    console.log(`[CONSOLE] ${new Date().toISOString()} - ${message}`);
  }
}

class FileLogger extends Logger {
  constructor(filePath) {
    super();
    this.filePath = filePath;
  }

  log(message) {
    const fs = require('fs');
    const logEntry = `${new Date().toISOString()} - ${message}\n`;
    fs.appendFileSync(this.filePath, logEntry);
  }
}

class CloudLogger extends Logger {
  log(message) {
    // Отправка в облачный сервис
    console.log(`[CLOUD] Sending to cloud: ${message}`);
  }
}

// Фабрика логгеров
class LoggerFactory {
  static create(type, options = {}) {
    switch (type) {
      case 'console':
        return new ConsoleLogger();
      case 'file':
        return new FileLogger(options.filePath || './app.log');
      case 'cloud':
        return new CloudLogger();
      default:
        throw new Error(`Unknown logger type: ${type}`);
    }
  }
}

// Использование
const logger = LoggerFactory.create('file', { filePath: './logs/app.log' });
logger.log('Application started');

// Легко переключиться на другой логгер
const cloudLogger = LoggerFactory.create('cloud');
cloudLogger.log('Critical error occurred');
</code></pre>
<h3 id="Пример-2-http-клиенты"><a class="header" href="#Пример-2-http-клиенты">Пример 2: HTTP-клиенты</a></h3>
<pre><code class="language-javascript">// Абстрактный HTTP-клиент
class HttpClient {
  get(url) {
    throw new Error('Method must be implemented');
  }

  post(url, data) {
    throw new Error('Method must be implemented');
  }
}

// Реализация с fetch
class FetchHttpClient extends HttpClient {
  async get(url) {
    const response = await fetch(url);
    return response.json();
  }

  async post(url, data) {
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    return response.json();
  }
}

// Реализация с axios
class AxiosHttpClient extends HttpClient {
  constructor() {
    super();
    this.axios = require('axios');
  }

  async get(url) {
    const response = await this.axios.get(url);
    return response.data;
  }

  async post(url, data) {
    const response = await this.axios.post(url, data);
    return response.data;
  }
}

// Фабрика HTTP-клиентов
class HttpClientFactory {
  static create(type = 'fetch') {
    if (type === 'fetch') {
      return new FetchHttpClient();
    }
    if (type === 'axios') {
      return new AxiosHttpClient();
    }
    throw new Error(`Unknown HTTP client type: ${type}`);
  }
}

// API сервис использует фабрику
class ApiService {
  constructor(httpClientFactory) {
    this.httpClient = httpClientFactory.create('fetch');
  }

  async getUsers() {
    return this.httpClient.get('/api/users');
  }

  async createUser(userData) {
    return this.httpClient.post('/api/users', userData);
  }
}
</code></pre>
<h3 id="Пример-3-Парсеры-данных"><a class="header" href="#Пример-3-Парсеры-данных">Пример 3: Парсеры данных</a></h3>
<pre><code class="language-javascript">// Интерфейс парсера
class DataParser {
  parse(data) {
    throw new Error('Method must be implemented');
  }
}

// JSON парсер
class JsonParser extends DataParser {
  parse(data) {
    try {
      return JSON.parse(data);
    } catch (error) {
      throw new Error(`JSON parsing failed: ${error.message}`);
    }
  }
}

// CSV парсер
class CsvParser extends DataParser {
  parse(data) {
    const lines = data.split('\n');
    const headers = lines[0].split(',');

    return lines.slice(1).map(line =&gt; {
      const values = line.split(',');
      return headers.reduce((obj, header, index) =&gt; {
        obj[header.trim()] = values[index]?.trim() || '';
        return obj;
      }, {});
    });
  }
}

// XML парсер (упрощённый)
class XmlParser extends DataParser {
  parse(data) {
    // Упрощённая реализация
    return { xml: 'parsed', data };
  }
}

// Фабрика парсеров по расширению файла
class ParserFactory {
  static createByExtension(filePath) {
    const extension = filePath.split('.').pop().toLowerCase();

    switch (extension) {
      case 'json':
        return new JsonParser();
      case 'csv':
        return new CsvParser();
      case 'xml':
        return new XmlParser();
      default:
        throw new Error(`Unsupported file extension: ${extension}`);
    }
  }
}

// Использование
function loadData(filePath) {
  const fs = require('fs');
  const content = fs.readFileSync(filePath, 'utf-8');

  const parser = ParserFactory.createByExtension(filePath);
  return parser.parse(content);
}

const jsonData = loadData('./data.json');
const csvData = loadData('./data.csv');
</code></pre>
<hr />
<h2 id="Распространённые-ошибки"><a class="header" href="#Распространённые-ошибки">Распространённые ошибки</a></h2>
<h3 id="Ошибка-1-Забывают-скрывать-new"><a class="header" href="#Ошибка-1-Забывают-скрывать-new">Ошибка 1: Забывают скрывать new</a></h3>
<pre><code class="language-javascript">// ❌ Неправильно: клиент всё ещё видит new
class ProductFactory {
  factoryMethod() {
    return Product; // Возвращаем класс, а не экземпляр!
  }
}

const Factory = new ProductFactory();
const product = new (Factory.factoryMethod())(); // Клиент использует new

// ✅ Правильно: new скрыт внутри фабрики
class ProductFactory {
  factoryMethod() {
    return new Product(); // Возвращаем готовый экземпляр
  }
}

const factory = new ProductFactory();
const product = factory.factoryMethod(); // Клиент не знает про new
</code></pre>
<h3 id="Ошибка-2-Путают-factory-method-и-abstract-factory"><a class="header" href="#Ошибка-2-Путают-factory-method-и-abstract-factory">Ошибка 2: Путают Factory Method и Abstract Factory</a></h3>
<pre><code class="language-javascript">// ❌ Это Abstract Factory, а не Factory Method!
class GUIFactory {
  createButton() {
    return new Button();
  }

  createInput() {
    return new Input();
  }

  createCheckbox() {
    return new Checkbox();
  }
}

// ✅ Это Factory Method — один метод для одного типа продукта
class ButtonFactory {
  createButton(type) {
    if (type === 'primary') return new PrimaryButton();
    if (type === 'secondary') return new SecondaryButton();
    throw new Error(`Unknown button type: ${type}`);
  }
}
</code></pre>
<h3 id="Ошибка-3-Чрезмерное-использование"><a class="header" href="#Ошибка-3-Чрезмерное-использование">Ошибка 3: Чрезмерное использование</a></h3>
<pre><code class="language-javascript">// ❌ Избыточно для простого случая
class StringFactory {
  createString(value) {
    return new String(value);
  }
}

// ✅ Просто используйте литералы
const str = 'Hello, world!';
</code></pre>
<hr />
<h2 id="Контрольные-вопросы"><a class="header" href="#Контрольные-вопросы">Контрольные вопросы</a></h2>
<ol>
<li>
<p><strong>В чём главное отличие Factory Method от Abstract Factory?</strong></p>
<ul>
<li>Factory Method — один метод для одного типа продукта</li>
<li>Abstract Factory — множество методов для семейства продуктов</li>
</ul>
</li>
<li>
<p><strong>Почему в JavaScript Factory Method может быть простой функцией?</strong></p>
<ul>
<li>JavaScript не требует строгой иерархии классов</li>
<li>Функции — это объекты первого класса</li>
<li>Можно передавать функции как аргументы</li>
</ul>
</li>
<li>
<p><strong>Когда стоит использовать Factory Method?</strong></p>
<ul>
<li>Тип создаваемого объекта определяется во время выполнения</li>
<li>Нужно делегировать создание подклассам</li>
<li>Хотите изолировать логику создания</li>
</ul>
</li>
<li>
<p><strong>Как Factory Method связан с паттерном Strategy?</strong></p>
<ul>
<li>Factory Method часто создаёт экземпляры стратегий</li>
<li>Позволяет подменять стратегии во время выполнения</li>
</ul>
</li>
</ol>
<hr />
<h2 id="Резюме"><a class="header" href="#Резюме">Резюме</a></h2>
<h3 id="Ключевые-концепции"><a class="header" href="#Ключевые-концепции">Ключевые концепции</a></h3>
<ol>
<li><strong>Замена прямого инстанцирования</strong> методом создания</li>
<li><strong>Снижение зацепления</strong> между компонентами</li>
<li><strong>Делегирование создания</strong> подклассам или внешнему коду</li>
<li><strong>Гибкость</strong> при добавлении новых типов продуктов</li>
</ol>
<h3 id="Когда-использовать-1"><a class="header" href="#Когда-использовать-1">Когда использовать</a></h3>
<ul>
<li>Заранее неизвестен точный тип создаваемых объектов</li>
<li>Нужна возможность расширения системы новыми типами</li>
<li>Хотите централизовать логику создания объектов</li>
<li>Требуется возможность подмены реализации (тестирование, конфигурация)</li>
</ul>
<h3 id="javascript-особенности"><a class="header" href="#javascript-особенности">JavaScript особенности</a></h3>
<ul>
<li>Фабрика может быть простой функцией</li>
<li>Можно передавать фабрики как аргументы (высшие функции)</li>
<li>Коллекции фабрик в объектах — распространённый паттерн</li>
<li>Не обязательно использовать наследование классов</li>
</ul>
<h3 id="typescript-преимущества"><a class="header" href="#typescript-преимущества">TypeScript преимущества</a></h3>
<ul>
<li>Настоящие абстрактные классы и методы</li>
<li>Проверка типов на этапе компиляции</li>
<li>Лучшая поддержка IDE</li>
<li>Не нужны проверки с <code>new.target</code></li>
</ul>
<hr />
<h2 id="Дополнительные-материалы"><a class="header" href="#Дополнительные-материалы">Дополнительные материалы</a></h2>
<h3 id="Связанные-паттерны"><a class="header" href="#Связанные-паттерны">Связанные паттерны</a></h3>
<ul>
<li><strong>Abstract Factory</strong> — создание семейств связанных объектов</li>
<li><strong>Strategy</strong> — выбор алгоритма во время выполнения</li>
<li><strong>Template Method</strong> — определение скелета алгоритма</li>
<li><strong>Prototype</strong> — создание объектов через клонирование</li>
</ul>
<h3 id="Принципы-solid"><a class="header" href="#Принципы-solid">Принципы SOLID</a></h3>
<p>Factory Method помогает соблюдать:</p>
<ul>
<li><strong>Single Responsibility</strong> — одна причина для изменения</li>
<li><strong>Open/Closed</strong> — открыт для расширения, закрыт для модификации</li>
<li><strong>Dependency Inversion</strong> — зависимость от абстракций, а не от конкретных классов</li>
</ul>
<h3 id="Паттерны-grasp"><a class="header" href="#Паттерны-grasp">Паттерны GRASP</a></h3>
<ul>
<li><strong>Creator</strong> — кто отвечает за создание объекта?</li>
<li><strong>Low Coupling</strong> — минимизация зависимостей</li>
<li><strong>High Cohesion</strong> — логика создания в одном месте</li>
<li><strong>Polymorphism</strong> — использование полиморфизма для вариативности</li>
</ul>
<hr />
<h2 id="Практические-упражнения"><a class="header" href="#Практические-упражнения">Практические упражнения</a></h2>
<h3 id="Упражнение-1-Система-уведомлений"><a class="header" href="#Упражнение-1-Система-уведомлений">Упражнение 1: Система уведомлений</a></h3>
<p>Создайте фабрику для системы уведомлений, которая может отправлять уведомления через:</p>
<ul>
<li>Email</li>
<li>SMS</li>
<li>Push-уведомления</li>
<li>Slack</li>
</ul>
<h3 id="Упражнение-2-Обработчики-файлов"><a class="header" href="#Упражнение-2-Обработчики-файлов">Упражнение 2: Обработчики файлов</a></h3>
<p>Реализуйте фабрику обработчиков файлов для различных форматов:</p>
<ul>
<li>Изображения (PNG, JPEG, GIF)</li>
<li>Документы (PDF, DOCX, TXT)</li>
<li>Видео (MP4, AVI, MKV)</li>
</ul>
<h3 id="Упражнение-3-Валидаторы-форм"><a class="header" href="#Упражнение-3-Валидаторы-форм">Упражнение 3: Валидаторы форм</a></h3>
<p>Создайте систему валидаторов с использованием Factory Method:</p>
<ul>
<li>Email валидатор</li>
<li>Телефон валидатор</li>
<li>Дата валидатор</li>
<li>Кастомный валидатор</li>
</ul>
<hr />
<p><strong>Успехов в изучении паттернов проектирования!</strong></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../week4/abstract-factory-lecture-notes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../week4/strategy-pattern-lecture-notes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../week4/abstract-factory-lecture-notes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../week4/strategy-pattern-lecture-notes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
