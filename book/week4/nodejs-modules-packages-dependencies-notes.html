<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Структура приложений: системы модульности, пакеты и зависимости - Patterns</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Patterns</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Структура-приложений-nodejs-модули-пакеты-и-зависимости"><a class="header" href="#Структура-приложений-nodejs-модули-пакеты-и-зависимости">Структура приложений Node.js: модули, пакеты и зависимости</a></h1>
<h2 id="Обзор"><a class="header" href="#Обзор">Обзор</a></h2>
<p>Эта лекция охватывает фундаментальные концепции модульной системы Node.js, включая CommonJS и ECMAScript модули, механизмы загрузки и кэширования модулей, работу с пакетами и создание собственной системы модульности. Мы рассмотрим внутреннее устройство модульной системы Node.js и научимся создавать изолированные окружения выполнения (sandboxes).</p>
<hr />
<h2 id="Основы-модульной-системы-commonjs"><a class="header" href="#Основы-модульной-системы-commonjs">Основы модульной системы CommonJS</a></h2>
<h3 id="Структура-типичного-модуля-commonjs"><a class="header" href="#Структура-типичного-модуля-commonjs">Структура типичного модуля CommonJS</a></h3>
<p>В Node.js каждый файл является отдельным модулем. Модули используют специальные идентификаторы для экспорта и импорта функциональности.</p>
<h4 id="Пример-базового-модуля-file1-exportjs"><a class="header" href="#Пример-базового-модуля-file1-exportjs">Пример базового модуля (file1-export.js)</a></h4>
<pre><code class="language-javascript">// Определяем функции и переменные
const myFunction = () =&gt; {
  console.log('Функция из модуля');
};

const MyClass = class {
  constructor(name) {
    this.name = name;
  }
};

const collection = new Map();

// Экспортируем через module.exports
module.exports = {
  myFunction,
  MyClass,
  collection
};
</code></pre>
<p><strong>Важно</strong>: Идентификатор <code>module</code> не объявлен в коде явно - он внедряется загрузчиком Node.js через механизм <code>vm.createScript</code>.</p>
<h3 id="Встроенные-идентификаторы-модулей"><a class="header" href="#Встроенные-идентификаторы-модулей">Встроенные идентификаторы модулей</a></h3>
<p>Каждый CommonJS модуль имеет доступ к следующим встроенным идентификаторам:</p>
<ul>
<li><code>module</code> - объект текущего модуля</li>
<li><code>exports</code> - ссылка на <code>module.exports</code></li>
<li><code>require</code> - функция для загрузки модулей</li>
<li><code>__filename</code> - абсолютный путь к текущему файлу</li>
<li><code>__dirname</code> - абсолютный путь к директории файла</li>
</ul>
<p>Все эти идентификаторы внедряются извне загрузчиком Node.js.</p>
<hr />
<h2 id="Загрузка-модулей-через-require"><a class="header" href="#Загрузка-модулей-через-require">Загрузка модулей через require</a></h2>
<h3 id="Загрузка-встроенных-модулей-nodejs"><a class="header" href="#Загрузка-встроенных-модулей-nodejs">Загрузка встроенных модулей Node.js</a></h3>
<h4 id="Традиционный-способ"><a class="header" href="#Традиционный-способ">Традиционный способ</a></h4>
<pre><code class="language-javascript">const fs = require('fs');
const events = require('events');
const timers = require('timers');
</code></pre>
<h4 id="Современный-способ-с-nodejs-16"><a class="header" href="#Современный-способ-с-nodejs-16">Современный способ (с Node.js 16+)</a></h4>
<pre><code class="language-javascript">// Использование префикса node: для явного указания встроенного модуля
const fs = require('node:fs');
const events = require('node:events');
const timers = require('node:timers/promises'); // подмодуль с промисами
</code></pre>
<p><strong>Преимущества префикса <code>node:</code>:</strong></p>
<ul>
<li>Защита от конфликтов с npm-пакетами с такими же именами</li>
<li>Явное указание, что загружается встроенный модуль Node.js</li>
<li>Рекомендуется использовать всегда для встроенных модулей</li>
</ul>
<h3 id="Загрузка-npm-пакетов"><a class="header" href="#Загрузка-npm-пакетов">Загрузка npm-пакетов</a></h3>
<pre><code class="language-javascript">// Загрузка пакета из node_modules
const WebSocket = require('ws');
</code></pre>
<h3 id="Загрузка-локальных-модулей"><a class="header" href="#Загрузка-локальных-модулей">Загрузка локальных модулей</a></h3>
<pre><code class="language-javascript">// Относительный путь
const myModule = require('./file1-export');

// Абсолютный путь
const myModule = require('/absolute/path/to/module');
</code></pre>
<hr />
<h2 id="Функция-require-и-её-свойства"><a class="header" href="#Функция-require-и-её-свойства">Функция require и её свойства</a></h2>
<h3 id="requireresolve"><a class="header" href="#requireresolve">require.resolve()</a></h3>
<p>Преобразует относительный путь к модулю в абсолютный без загрузки модуля.</p>
<pre><code class="language-javascript">const modulePath = require.resolve('./file1-export');
console.log(modulePath); // Выведет абсолютный путь к файлу
</code></pre>
<h3 id="requirecache"><a class="header" href="#requirecache">require.cache</a></h3>
<p>Объект-коллекция всех загруженных и закэшированных модулей.</p>
<pre><code class="language-javascript">// Просмотр информации о кэшированном модуле
const modulePath = require.resolve('./file1-export');
const cachedModule = require.cache[modulePath];

console.log(cachedModule);
// {
//   id: '/абсолютный/путь/к/модулю',
//   path: '/абсолютный/путь/к/директории',
//   exports: { /* экспортированное содержимое */ },
//   filename: '/абсолютный/путь/к/модулю',
//   loaded: true,
//   children: [ /* зависимости этого модуля */ ],
//   paths: [ /* пути поиска модулей */ ]
// }
</code></pre>
<hr />
<h2 id="Кэширование-модулей-и-паттерн-singleton"><a class="header" href="#Кэширование-модулей-и-паттерн-singleton">Кэширование модулей и паттерн Singleton</a></h2>
<h3 id="Принцип-работы-кэша"><a class="header" href="#Принцип-работы-кэша">Принцип работы кэша</a></h3>
<p><strong>Ключевая особенность</strong>: Когда модуль загружается через <code>require</code>, он загружается только один раз и затем кэшируется. Все последующие вызовы <code>require</code> возвращают один и тот же объект (ссылку).</p>
<h4 id="Демонстрация-синглтона"><a class="header" href="#Демонстрация-синглтона">Демонстрация синглтона</a></h4>
<p><strong>Модуль file1-export.js:</strong></p>
<pre><code class="language-javascript">const collection = new Map();

module.exports = {
  collection
};
</code></pre>
<p><strong>Файл 5-singleton.js:</strong></p>
<pre><code class="language-javascript">const module1 = require('./file1-export');

// Модифицируем коллекцию
module1.collection.set('key', 'value');

console.log(module1.collection.get('key')); // 'value'
</code></pre>
<p><strong>Файл 6-global.js:</strong></p>
<pre><code class="language-javascript">// Сначала загружаем файл, который модифицирует модуль
require('./5-singleton');

// Теперь загружаем тот же модуль
const module2 = require('./file1-export');

console.log(module2.collection.get('key')); // 'value' - изменения сохранились!
</code></pre>
<p><strong>Вывод</strong>: <code>module1.collection</code> и <code>module2.collection</code> указывают на один и тот же объект Map в памяти.</p>
<h3 id="Опасности-мутабельности"><a class="header" href="#Опасности-мутабельности">Опасности мутабельности</a></h3>
<p>Из-за кэширования возможны следующие проблемы:</p>
<ol>
<li>
<p><strong>Непредсказуемые изменения состояния</strong></p>
<ul>
<li>Один модуль может изменить экспортированный объект</li>
<li>Эти изменения будут видны во всех модулях, которые его импортируют</li>
</ul>
</li>
<li>
<p><strong>Сложность отладки</strong></p>
<ul>
<li>Трудно отследить, кто и когда изменил состояние</li>
<li>Особенно проблематично с транзитивными зависимостями</li>
</ul>
</li>
</ol>
<h4 id="Пример-monkey-patching-встроенных-модулей"><a class="header" href="#Пример-monkey-patching-встроенных-модулей">Пример: Monkey Patching встроенных модулей</a></h4>
<pre><code class="language-javascript">const fs = require('node:fs');

// Сохраняем оригинальную функцию
const originalReadFile = fs.readFile;

// Подменяем функцию
fs.readFile = function(path, options, callback) {
  console.log('Перехвачено чтение файла:', path);

  // Вызываем оригинальную функцию
  return originalReadFile.call(this, path, options, (...args) =&gt; {
    console.log('Файл прочитан, размер буфера:', args[1]?.length);
    callback(...args);
  });
};

// Теперь в любом месте приложения, где используется fs.readFile,
// будет выполняться наша обёртка!
</code></pre>
<p><strong>Опасность</strong>: Любая зависимость может модифицировать встроенные модули Node.js или глобальные прототипы, что приведёт к:</p>
<ul>
<li>Непредсказуемому поведению</li>
<li>Сложности в аудите безопасности</li>
<li>Проблемам с отладкой</li>
</ul>
<h3 id="Очистка-кэша"><a class="header" href="#Очистка-кэша">Очистка кэша</a></h3>
<p>Можно вручную удалить модуль из кэша для повторной загрузки:</p>
<pre><code class="language-javascript">const module1 = require('./file1-export');

// Удаляем из кэша
const modulePath = require.resolve('./file1-export');
delete require.cache[modulePath];

// Загружаем снова - будет создан новый объект
const module2 = require('./file1-export');

console.log(module1 === module2); // false - разные объекты!
</code></pre>
<p><strong>Ограничение</strong>: Это не защищает полностью от модификаций, так как:</p>
<ul>
<li>Другие зависимости могли загрузить модуль до или после очистки</li>
<li>Невозможно контролировать момент загрузки во всех зависимостях</li>
</ul>
<hr />
<h2 id="Алгоритм-поиска-модулей"><a class="header" href="#Алгоритм-поиска-модулей">Алгоритм поиска модулей</a></h2>
<h3 id="Последовательность-поиска-для-require"><a class="header" href="#Последовательность-поиска-для-require">Последовательность поиска для require()</a></h3>
<p>Когда вызывается <code>require('module-name')</code> (без префикса <code>./</code> или <code>/</code>), Node.js ищет модуль в следующих директориях:</p>
<pre><code class="language-javascript">// Пример массива paths из кэшированного модуля
[
  '/path/to/current/directory/node_modules',
  '/path/to/parent/directory/node_modules',
  '/path/to/grandparent/directory/node_modules',
  // ... до корня файловой системы
  '/node_modules'
]
</code></pre>
<p><strong>Процесс поиска:</strong></p>
<ol>
<li>Текущая директория → <code>./node_modules</code></li>
<li>Родительская директория → <code>../node_modules</code></li>
<li>Директория выше → <code>../../node_modules</code></li>
<li>Продолжается до корня файловой системы</li>
</ol>
<h3 id="Порядок-разрешения-расширений-файлов"><a class="header" href="#Порядок-разрешения-расширений-файлов">Порядок разрешения расширений файлов</a></h3>
<p>Если расширение не указано, Node.js пробует в следующем порядке:</p>
<ol>
<li><code>.js</code> - JavaScript-файл (CommonJS)</li>
<li><code>.json</code> - JSON-файл</li>
<li><code>.node</code> - нативное расширение C++</li>
<li><code>.mjs</code> - ECMAScript-модуль (если используется ECMAScript modules)</li>
</ol>
<p><strong>Рекомендация</strong>: Всегда указывайте расширение явно для ускорения загрузки и избежания неоднозначности.</p>
<hr />
<h2 id="ecmascript-модули-esm"><a class="header" href="#ecmascript-модули-esm">ECMAScript модули (ESM)</a></h2>
<h3 id="Отличия-от-commonjs"><a class="header" href="#Отличия-от-commonjs">Отличия от CommonJS</a></h3>
<p><strong>Синтаксис экспорта:</strong></p>
<pre><code class="language-javascript">// CommonJS
module.exports = {
  myFunction,
  MyClass
};

// ECMAScript модули
export {
  myFunction,
  MyClass
};
</code></pre>
<p><strong>Синтаксис импорта:</strong></p>
<pre><code class="language-javascript">// CommonJS
const { myFunction, MyClass } = require('./module');

// ECMAScript модули
import { myFunction, MyClass } from './module.mjs';
</code></pre>
<h3 id="Расширения-файлов"><a class="header" href="#Расширения-файлов">Расширения файлов</a></h3>
<ul>
<li><code>.mjs</code> - ECMAScript модуль</li>
<li><code>.cjs</code> - CommonJS модуль (явное указание)</li>
<li><code>.js</code> - зависит от настройки <code>type</code> в <code>package.json</code></li>
</ul>
<h3 id="Пример-ecmascript-модуля-file1-exportmjs"><a class="header" href="#Пример-ecmascript-модуля-file1-exportmjs">Пример ECMAScript модуля (file1-export.mjs)</a></h3>
<pre><code class="language-javascript">// Экспорт именованных идентификаторов
export const myFunction = () =&gt; {
  console.log('ES модуль функция');
};

export class MyClass {
  constructor(name) {
    this.name = name;
  }
}

export const collection = new Map();
</code></pre>
<h3 id="Импорт-ecmascript-модулей"><a class="header" href="#Импорт-ecmascript-модулей">Импорт ECMAScript модулей</a></h3>
<pre><code class="language-javascript">// Импорт именованных экспортов
import { myFunction, MyClass, collection } from './file1-export.mjs';

// Импорт встроенных модулей
import * as events from 'node:events';
</code></pre>
<h3 id="Совместимость-импорт-commonjs-из-esm"><a class="header" href="#Совместимость-импорт-commonjs-из-esm">Совместимость: импорт CommonJS из ESM</a></h3>
<p>ECMAScript модули могут импортировать CommonJS модули:</p>
<pre><code class="language-javascript">// Импорт CommonJS модуля из ESM
import fs from 'node:fs'; // default import для CommonJS
import { readFile } from 'node:fs'; // именованный импорт

// Импорт локального CommonJS модуля
import myModule from './commonjs-module.js';
</code></pre>
<p><strong>Важно</strong>: Результат импорта идентичен, независимо от того, откуда импортируется (CommonJS или ESM).</p>
<hr />
<h2 id="Динамический-импорт"><a class="header" href="#Динамический-импорт">Динамический импорт</a></h2>
<h3 id="Синтаксис-и-использование"><a class="header" href="#Синтаксис-и-использование">Синтаксис и использование</a></h3>
<p>Динамический импорт возвращает Promise и может использоваться как в CommonJS, так и в ESM.</p>
<pre><code class="language-javascript">// Динамический импорт возвращает Promise
const eventsPromise = import('node:events');

eventsPromise.then((events) =&gt; {
  console.log(events); // модуль events
});

// С async/await
const events = await import('node:events');
console.log(events);
</code></pre>
<h3 id="top-level-await"><a class="header" href="#top-level-await">Top-level await</a></h3>
<p><strong>В ECMAScript модулях (.mjs):</strong></p>
<pre><code class="language-javascript">// Можно использовать await в корне файла
const events = await import('node:events');
console.log(events.EventEmitter);
</code></pre>
<p><strong>В CommonJS модулях (.js с "use strict"):</strong></p>
<pre><code class="language-javascript">'use strict';

// await нельзя использовать в корне
// await import('node:events'); // Ошибка!

// Но можно внутри async функции
(async () =&gt; {
  const events = await import('node:events');
  console.log(events);
})();
</code></pre>
<hr />
<h2 id="Получение-require-в-ecmascript-модулях"><a class="header" href="#Получение-require-в-ecmascript-модулях">Получение require в ECMAScript модулях</a></h2>
<p>ECMAScript модули не имеют встроенного <code>require</code>. Для его использования нужно создать вручную:</p>
<pre><code class="language-javascript">import { createRequire } from 'node:module';
import { fileURLToPath } from 'node:url';

// Получаем путь к текущему файлу через import.meta.url
const __filename = fileURLToPath(import.meta.url);

// Создаём require для текущего модуля
const require = createRequire(import.meta.url);

// Теперь можно использовать require
const fs = require('node:fs');
const ws = require('ws'); // npm пакет
</code></pre>
<h3 id="importmeta"><a class="header" href="#importmeta">import.meta</a></h3>
<p>Объект <code>import.meta</code> содержит метаданные о текущем модуле:</p>
<pre><code class="language-javascript">console.log(import.meta);
// {
//   url: 'file:///absolute/path/to/module.mjs'
// }
</code></pre>
<p><strong>Применение:</strong></p>
<ul>
<li>Получение пути к текущему файлу</li>
<li>Создание <code>require</code> в ESM</li>
<li>Загрузка ресурсов относительно модуля</li>
</ul>
<hr />
<h2 id="Создание-собственной-системы-модульности"><a class="header" href="#Создание-собственной-системы-модульности">Создание собственной системы модульности</a></h2>
<h3 id="Наивная-реализация-commonjs"><a class="header" href="#Наивная-реализация-commonjs">Наивная реализация CommonJS</a></h3>
<p>Рассмотрим, как создать простую систему модульности, похожую на CommonJS:</p>
<pre><code class="language-javascript">const fs = require('node:fs').promises;
const vm = require('node:vm');

async function load(filename, sandbox = {}) {
  // 1. Читаем содержимое файла
  const source = await fs.readFile(filename, 'utf8');

  // 2. Оборачиваем исходник в функцию
  const wrapper =
    `(require, module, __filename, __dirname) =&gt; {\n` +
    source +
    `\n}`;

  // 3. Создаём скрипт
  const script = new vm.Script(wrapper, { filename });

  // 4. Создаём изолированный контекст (sandbox)
  const context = vm.createContext(
    Object.freeze({ ...sandbox })
  );

  // 5. Выполняем скрипт в контексте
  const wrappedFunction = script.runInContext(context, {
    timeout: 5000,
    displayErrors: false
  });

  // 6. Создаём объект module для экспорта
  const module = { exports: {} };

  // 7. Создаём псевдо-require (заглушку)
  const require = (name) =&gt; {
    console.log('Вызван require для:', name);
    // Здесь может быть рекурсивная загрузка
  };

  // 8. Вызываем обёрнутую функцию с нужными параметрами
  wrappedFunction(
    require,
    module,
    filename,
    path.dirname(filename)
  );

  // 9. Возвращаем экспортированное содержимое
  return module.exports;
}

// Использование
const myModule = await load('./file1-export.js', {
  // Можем подменить глобальные идентификаторы
  Map: class PseudoMap extends Map {
    constructor() {
      super();
      console.log('Создан PseudoMap!');
    }
  }
});
</code></pre>
<p><strong>Как это работает:</strong></p>
<ol>
<li><strong>Чтение файла</strong> - получаем исходный код модуля</li>
<li><strong>Обёртка</strong> - добавляем параметры <code>require</code>, <code>module</code>, <code>__filename</code>, <code>__dirname</code></li>
<li><strong>Компиляция</strong> - создаём VM-скрипт из обёрнутого кода</li>
<li><strong>Изоляция</strong> - создаём отдельный контекст выполнения (sandbox)</li>
<li><strong>Выполнение</strong> - запускаем скрипт с внедрёнными зависимостями</li>
<li><strong>Экспорт</strong> - возвращаем <code>module.exports</code></li>
</ol>
<h3 id="Реальная-реализация-в-nodejs"><a class="header" href="#Реальная-реализация-в-nodejs">Реальная реализация в Node.js</a></h3>
<p>Это упрощённая версия. В реальном загрузчике Node.js (lib/internal/modules/cjs/loader.js):</p>
<pre><code class="language-javascript">// Из исходников Node.js
const wrapper = [
  '(function (exports, require, module, __filename, __dirname) { ',
  '\n});'
];

function wrap(script) {
  return wrapper[0] + script + wrapper[1];
}
</code></pre>
<p><strong>Отличия от нашей реализации:</strong></p>
<ul>
<li>Использует обычную функцию вместо стрелочной</li>
<li>Более сложная обработка ошибок</li>
<li>Интеграция с кэшем модулей</li>
<li>Поддержка циклических зависимостей</li>
</ul>
<hr />
<h2 id="Альтернативная-система-модульности"><a class="header" href="#Альтернативная-система-модульности">Альтернативная система модульности</a></h2>
<p>Создадим систему модульности, где модуль - это просто объект с методами:</p>
<h3 id="Формат-модуля-examplemm"><a class="header" href="#Формат-модуля-examplemm">Формат модуля (example.mm)</a></h3>
<pre><code class="language-javascript">({
  // Обычные методы
  method1() {
    console.log('Method 1');
  },

  // Асинхронные методы
  async method2() {
    return 'Result';
  },

  // Свойства
  constant: 42,
  collection: new Map()
})
</code></pre>
<h3 id="Загрузчик-для-альтернативной-системы"><a class="header" href="#Загрузчик-для-альтернативной-системы">Загрузчик для альтернативной системы</a></h3>
<pre><code class="language-javascript">const fs = require('node:fs').promises;
const vm = require('node:vm');

async function loadModule(filename, sandbox = {}) {
  // 1. Читаем исходник
  const source = await fs.readFile(filename, 'utf8');

  // 2. Добавляем перевод строки (для отладки)
  const wrappedSource = '\n' + source + '\n';

  // 3. Создаём скрипт
  const script = new vm.Script(wrappedSource, { filename });

  // 4. Создаём контекст
  const context = vm.createContext({ ...sandbox });

  // 5. Выполняем и сразу возвращаем результат
  return script.runInContext(context, {
    timeout: 5000
  });
}

// Использование
const myModule = await loadModule('./example.mm', {
  console // передаём console в sandbox
});

console.log(myModule.constant); // 42
myModule.method1(); // 'Method 1'
</code></pre>
<p><strong>Преимущества:</strong></p>
<ul>
<li>Проще, чем CommonJS (нет обёртки в функцию)</li>
<li>Модуль сразу возвращает объект</li>
<li>Меньше замыканий</li>
<li>Можно писать код до объявления объекта</li>
</ul>
<p><strong>Недостатки:</strong></p>
<ul>
<li>Нет стандартизации</li>
<li>Меньше экосистемной поддержки</li>
</ul>
<hr />
<h2 id="Работа-с-пакетами-packages"><a class="header" href="#Работа-с-пакетами-packages">Работа с пакетами (packages)</a></h2>
<h3 id="Структура-пакета"><a class="header" href="#Структура-пакета">Структура пакета</a></h3>
<p>Пакет - это директория с файлом <code>package.json</code>, который описывает пакет.</p>
<h4 id="Базовый-packagejson"><a class="header" href="#Базовый-packagejson">Базовый package.json</a></h4>
<pre><code class="language-json">{
  "name": "my-package",
  "version": "1.0.0",
  "author": "Author Name",
  "main": "main.js"
}
</code></pre>
<p><strong>Ключевые поля:</strong></p>
<ul>
<li><code>name</code> - имя пакета</li>
<li><code>version</code> - версия (semver)</li>
<li><code>main</code> - точка входа (по умолчанию <code>index.js</code>)</li>
<li><code>author</code> - автор пакета</li>
</ul>
<h3 id="Различные-способы-загрузки-пакетов"><a class="header" href="#Различные-способы-загрузки-пакетов">Различные способы загрузки пакетов</a></h3>
<h4 id="1-Загрузка-корня-пакета"><a class="header" href="#1-Загрузка-корня-пакета">1. Загрузка корня пакета</a></h4>
<pre><code class="language-javascript">// Все эквивалентны - загрузят main.js из package.json
require('./package1');
require('./package1/');
require('./package1/.');
</code></pre>
<h4 id="2-Загрузка-конкретного-файла"><a class="header" href="#2-Загрузка-конкретного-файла">2. Загрузка конкретного файла</a></h4>
<pre><code class="language-javascript">// Явно указываем файл - package.json игнорируется
require('./package1/main');
require('./package1/main.js');
</code></pre>
<h4 id="3-Загрузка-из-node_modules"><a class="header" href="#3-Загрузка-из-node_modules">3. Загрузка из node_modules</a></h4>
<pre><code class="language-javascript">// Ищет в node_modules по алгоритму поиска
const pkg = require('package-name');
</code></pre>
<h4 id="4-Загрузка-подмодулей"><a class="header" href="#4-Загрузка-подмодулей">4. Загрузка подмодулей</a></h4>
<pre><code class="language-javascript">// Загрузит utils.js из пакета
require('./package1/utils');
require('./package1/utils.js');
</code></pre>
<p><strong>Порядок проверки расширений:</strong></p>
<ol>
<li>Проверяет директорию <code>utils/</code> с <code>package.json</code></li>
<li>Проверяет файл <code>utils.json</code></li>
<li>Проверяет файл <code>utils.js</code></li>
<li>Проверяет файл <code>utils.cjs</code></li>
</ol>
<p><strong>Рекомендация:</strong> Всегда указывайте <code>.js</code> расширение для файлов, чтобы избежать лишних проверок.</p>
<h3 id="Загрузка-json-файлов"><a class="header" href="#Загрузка-json-файлов">Загрузка JSON файлов</a></h3>
<p>CommonJS <code>require</code> умеет загружать JSON:</p>
<pre><code class="language-javascript">// Загрузка package.json как объект
const packageInfo = require('./package1/package.json');

console.log(packageInfo.name); // 'my-package'
console.log(packageInfo.version); // '1.0.0'
</code></pre>
<hr />
<h2 id="ecmascript-пакеты"><a class="header" href="#ecmascript-пакеты">ECMAScript пакеты</a></h2>
<h3 id="Указание-типа-модульной-системы"><a class="header" href="#Указание-типа-модульной-системы">Указание типа модульной системы</a></h3>
<p>В <code>package.json</code> можно указать <code>type</code>:</p>
<pre><code class="language-json">{
  "name": "esm-package",
  "version": "1.0.0",
  "type": "module",
  "main": "main.js"
}
</code></pre>
<p><strong>Эффект:</strong></p>
<ul>
<li>Файлы <code>.js</code> теперь трактуются как ECMAScript модули</li>
<li>Для CommonJS нужно использовать расширение <code>.cjs</code></li>
<li>Можно использовать <code>import</code>/<code>export</code> в <code>.js</code> файлах</li>
</ul>
<h3 id="Пример-mainjs-с-type-module"><a class="header" href="#Пример-mainjs-с-type-module">Пример main.js с type: "module"</a></h3>
<pre><code class="language-javascript">// main.js воспринимается как ESM благодаря "type": "module"
export const myFunction = () =&gt; {
  console.log('ESM функция');
};

export class MyClass {
  constructor() {
    console.log('ESM класс');
  }
}
</code></pre>
<hr />
<h2 id="Экспорт-нескольких-точек-входа"><a class="header" href="#Экспорт-нескольких-точек-входа">Экспорт нескольких точек входа</a></h2>
<h3 id="Поле-exports-в-packagejson"><a class="header" href="#Поле-exports-в-packagejson">Поле exports в package.json</a></h3>
<p>Современный способ определения точек входа:</p>
<pre><code class="language-json">{
  "name": "multi-entry-package",
  "version": "1.0.0",
  "type": "module",
  "exports": {
    ".": "./main.mjs",
    "./utils": "./utils.mjs"
  }
}
</code></pre>
<p><strong>Использование:</strong></p>
<pre><code class="language-javascript">// Загружает main.mjs
import pkg from 'multi-entry-package';

// Загружает utils.mjs
import utils from 'multi-entry-package/utils';
</code></pre>
<h3 id="conditional-exports-условный-экспорт"><a class="header" href="#conditional-exports-условный-экспорт">Conditional Exports (условный экспорт)</a></h3>
<p>Можно определять разные точки входа для разных систем модулей:</p>
<pre><code class="language-json">{
  "name": "universal-package",
  "version": "1.0.0",
  "exports": {
    ".": {
      "import": "./main.mjs",
      "require": "./main.cjs"
    }
  }
}
</code></pre>
<p><strong>Поведение:</strong></p>
<pre><code class="language-javascript">// Из ECMAScript модуля - загрузит main.mjs
import pkg from 'universal-package';

// Из CommonJS модуля - загрузит main.cjs
const pkg = require('universal-package');
</code></pre>
<p><strong>Применение:</strong></p>
<ul>
<li>Создание универсальных библиотек</li>
<li>Оптимизация для разных окружений</li>
<li>Поддержка legacy кода</li>
</ul>
<hr />
<h2 id="Кэширование-и-изоляция-модулей"><a class="header" href="#Кэширование-и-изоляция-модулей">Кэширование и изоляция модулей</a></h2>
<h3 id="Общий-кэш-для-require-и-import"><a class="header" href="#Общий-кэш-для-require-и-import">Общий кэш для require и import?</a></h3>
<p>Проверим, используют ли <code>require</code> и динамический <code>import</code> один кэш:</p>
<pre><code class="language-javascript">import { createRequire } from 'node:module';

// Создаём require в ESM
const require = createRequire(import.meta.url);

// Загружаем модуль через import
const m1 = await import('node:module');

// Загружаем через динамический import снова
const m2 = await import('node:module');

// Загружаем через require
const m3 = require('node:module');

// Загружаем через require снова
const m4 = require('node:module');

// Проверяем идентичность
console.log(m1 === m2); // true - динамический import кэширует
console.log(m3 === m4); // true - require тоже кэширует
console.log(m1 === m3); // false (!) - разные кэши!
</code></pre>
<p><strong>Вывод:</strong></p>
<ul>
<li><code>import</code> и <code>require</code> используют <strong>разные кэши</strong></li>
<li>Каждая система модулей имеет свой cache</li>
<li>Это может привести к загрузке одного модуля дважды</li>
</ul>
<h3 id="conditional-exports-и-кэш"><a class="header" href="#conditional-exports-и-кэш">Conditional exports и кэш</a></h3>
<p>При использовании conditional exports:</p>
<pre><code class="language-javascript">// package.json:
// "exports": {
//   ".": {
//     "import": "./main.mjs",
//     "require": "./main.cjs"
//   }
// }

const m1 = require('package'); // загружает main.cjs
const m2 = await import('package'); // загружает main.mjs

console.log(m1 === m2); // false - это разные файлы!
</code></pre>
<p><strong>Важно:</strong> Если пакет имеет разные точки входа для <code>import</code> и <code>require</code>, они загружаются как отдельные модули и имеют отдельное состояние.</p>
<hr />
<h2 id="Песочница-sandbox-и-изоляция-кода"><a class="header" href="#Песочница-sandbox-и-изоляция-кода">Песочница (Sandbox) и изоляция кода</a></h2>
<h3 id="Создание-изолированного-контекста"><a class="header" href="#Создание-изолированного-контекста">Создание изолированного контекста</a></h3>
<p>Используя <code>vm.createContext</code>, можно создать изолированное окружение:</p>
<pre><code class="language-javascript">const vm = require('node:vm');

// Создаём sandbox с ограниченным API
const sandbox = {
  console: {
    log: (...args) =&gt; {
      console.log('[SANDBOX]', ...args);
    }
  },
  // Подменяем встроенные классы
  Map: class RestrictedMap extends Map {
    set(key, value) {
      console.log('Map.set вызван:', key, value);
      return super.set(key, value);
    }
  }
};

// Создаём контекст
const context = vm.createContext(sandbox);

// Код, который выполнится в песочнице
const code = `
  const map = new Map();
  map.set('key', 'value');
  console.log(map.get('key'));
`;

// Выполняем в изолированном контексте
vm.runInContext(code, context, {
  timeout: 5000,
  displayErrors: false
});
</code></pre>
<p><strong>Применение:</strong></p>
<ul>
<li>Выполнение ненадёжного кода</li>
<li>Изоляция плагинов</li>
<li>Ограничение доступа к API</li>
<li>Тестирование с mock-объектами</li>
</ul>
<h3 id="Ограничения-песочниц"><a class="header" href="#Ограничения-песочниц">Ограничения песочниц</a></h3>
<p><strong>Важно:</strong> Песочницы VM в Node.js не являются полноценной защитой:</p>
<ul>
<li>Возможен выход через прототипы</li>
<li>Доступ к нативным функциям</li>
<li>Не защищает от DoS (расход CPU/памяти)</li>
</ul>
<p>Для настоящей изоляции используйте:</p>
<ul>
<li>Worker Threads</li>
<li>Child Processes</li>
<li>Контейнеры (Docker)</li>
<li>Виртуальные машины</li>
</ul>
<hr />
<h2 id="Защита-от-модификаций-и-monkey-patching"><a class="header" href="#Защита-от-модификаций-и-monkey-patching">Защита от модификаций и monkey patching</a></h2>
<h3 id="Проблема"><a class="header" href="#Проблема">Проблема</a></h3>
<p>Любая зависимость может модифицировать:</p>
<ul>
<li>Встроенные модули Node.js</li>
<li>Глобальные прототипы (<code>Array.prototype</code>, <code>Object.prototype</code>)</li>
<li>Глобальные объекты</li>
</ul>
<h3 id="Решения"><a class="header" href="#Решения">Решения</a></h3>
<h4 id="1-Использование-objectfreeze"><a class="header" href="#1-Использование-objectfreeze">1. Использование Object.freeze</a></h4>
<pre><code class="language-javascript">// Заморозка экспортируемых объектов
const API = Object.freeze({
  method1() { },
  method2() { }
});

module.exports = API;
</code></pre>
<h4 id="2-Использование-песочниц"><a class="header" href="#2-Использование-песочниц">2. Использование песочниц</a></h4>
<pre><code class="language-javascript">// Запуск зависимостей в изолированном контексте
const vm = require('node:vm');

const sandbox = vm.createContext({
  // Контролируемое окружение
});

// Загрузка модуля в песочнице
</code></pre>
<h4 id="3-Аудит-зависимостей"><a class="header" href="#3-Аудит-зависимостей">3. Аудит зависимостей</a></h4>
<ul>
<li>Регулярная проверка зависимостей</li>
<li>Использование <code>npm audit</code></li>
<li>Минимизация зависимостей</li>
<li>Code review важных зависимостей</li>
</ul>
<h4 id="4-immutable-exports"><a class="header" href="#4-immutable-exports">4. Immutable exports</a></h4>
<pre><code class="language-javascript">// Экспортируем только функции (не объекты)
module.exports = {
  createInstance() {
    return { /* новый объект каждый раз */ };
  }
};
</code></pre>
<hr />
<h2 id="Лучшие-практики-модульной-системы"><a class="header" href="#Лучшие-практики-модульной-системы">Лучшие практики модульной системы</a></h2>
<h3 id="1-Явное-указание-расширений-и-префиксов"><a class="header" href="#1-Явное-указание-расширений-и-префиксов">1. Явное указание расширений и префиксов</a></h3>
<pre><code class="language-javascript">// Хорошо
const fs = require('node:fs');
const myModule = require('./module.js');

// Плохо
const fs = require('fs'); // может конфликтовать с npm пакетом
const myModule = require('./module'); // лишние проверки расширений
</code></pre>
<h3 id="2-immutable-exports"><a class="header" href="#2-immutable-exports">2. Immutable exports</a></h3>
<pre><code class="language-javascript">// Хорошо - неизменяемый API
module.exports = Object.freeze({
  method1: () =&gt; {},
  method2: () =&gt; {}
});

// Плохо - мутабельный объект
module.exports = {
  data: new Map() // может быть изменён извне
};
</code></pre>
<h3 id="3-Избегайте-глобального-состояния"><a class="header" href="#3-Избегайте-глобального-состояния">3. Избегайте глобального состояния</a></h3>
<pre><code class="language-javascript">// Плохо - глобальное состояние в модуле
let counter = 0;

module.exports = {
  increment() { counter++; },
  getCount() { return counter; }
};

// Хорошо - фабрика экземпляров
module.exports = {
  createCounter() {
    let counter = 0;
    return {
      increment() { counter++; },
      getCount() { return counter; }
    };
  }
};
</code></pre>
<h3 id="4-Документирование-контрактов-модулей"><a class="header" href="#4-Документирование-контрактов-модулей">4. Документирование контрактов модулей</a></h3>
<pre><code class="language-javascript">/**
 * Модуль для работы с пользователями
 * @module users
 */

/**
 * Создаёт нового пользователя
 * @param {string} name - Имя пользователя
 * @param {string} email - Email пользователя
 * @returns {Object} Объект пользователя
 */
function createUser(name, email) {
  return { name, email };
}

module.exports = { createUser };
</code></pre>
<h3 id="5-Используйте-esm-для-новых-проектов"><a class="header" href="#5-Используйте-esm-для-новых-проектов">5. Используйте ESM для новых проектов</a></h3>
<pre><code class="language-javascript">// Современный подход - ECMAScript модули
// package.json: "type": "module"

// Явный импорт
import { readFile } from 'node:fs/promises';
import { createServer } from 'node:http';

// Асинхронная загрузка
const config = await import('./config.js');
</code></pre>
<hr />
<h2 id="Структура-приложения-и-слои"><a class="header" href="#Структура-приложения-и-слои">Структура приложения и слои</a></h2>
<h3 id="Применение-модульной-системы-для-чистой-архитектуры"><a class="header" href="#Применение-модульной-системы-для-чистой-архитектуры">Применение модульной системы для чистой архитектуры</a></h3>
<p>Модульная система позволяет организовать код по принципам:</p>
<ol>
<li>
<p><strong>Разделение ответственности</strong></p>
<ul>
<li>Бизнес-логика в отдельных модулях</li>
<li>Инфраструктурный код изолирован</li>
</ul>
</li>
<li>
<p><strong>Dependency Injection через sandbox</strong></p>
<ul>
<li>Внедрение зависимостей через параметры модуля</li>
<li>Изоляция слоёв приложения</li>
</ul>
</li>
<li>
<p><strong>Минимизация coupling</strong></p>
<ul>
<li>Модули знают минимум друг о друге</li>
<li>Зависимости через интерфейсы</li>
</ul>
</li>
</ol>
<p><strong>Пример структуры:</strong></p>
<pre><code>app/
  ├── domain/          # Бизнес-логика (чистые функции)
  │   ├── user.js
  │   └── order.js
  ├── services/        # Сервисы приложения
  │   ├── userService.js
  │   └── orderService.js
  ├── infrastructure/  # Детали реализации
  │   ├── database.js
  │   ├── http.js
  │   └── logger.js
  └── main.js         # Точка входа, композиция
</code></pre>
<hr />
<h2 id="Итоги-и-ключевые-моменты"><a class="header" href="#Итоги-и-ключевые-моменты">Итоги и ключевые моменты</a></h2>
<h3 id="Основные-концепции"><a class="header" href="#Основные-концепции">Основные концепции</a></h3>
<ol>
<li>
<p><strong>Системы модульности в Node.js</strong></p>
<ul>
<li>CommonJS - традиционная система (<code>require</code>/<code>module.exports</code>)</li>
<li>ECMAScript Modules - современный стандарт (<code>import</code>/<code>export</code>)</li>
<li>Обе системы могут сосуществовать в одном проекте</li>
</ul>
</li>
<li>
<p><strong>Механизм загрузки</strong></p>
<ul>
<li>Модули оборачиваются в функции с внедрёнными зависимостями</li>
<li>Используется <code>vm.Script</code> для выполнения в изолированном контексте</li>
<li>Алгоритм поиска модулей идёт от текущей директории вверх</li>
</ul>
</li>
<li>
<p><strong>Кэширование</strong></p>
<ul>
<li><code>require</code> кэширует модули (паттерн Singleton)</li>
<li><code>import</code> имеет отдельный кэш</li>
<li>Очистка кэша возможна, но не решает все проблемы</li>
</ul>
</li>
<li>
<p><strong>Пакеты</strong></p>
<ul>
<li>Описываются через <code>package.json</code></li>
<li>Поддерживают множественные точки входа (<code>exports</code>)</li>
<li>Могут иметь условный экспорт для разных систем модулей</li>
</ul>
</li>
<li>
<p><strong>Безопасность</strong></p>
<ul>
<li>Monkey patching - серьёзная угроза</li>
<li>Песочницы обеспечивают базовую изоляцию</li>
<li>Требуется аудит зависимостей</li>
</ul>
</li>
</ol>
<h3 id="Рекомендации"><a class="header" href="#Рекомендации">Рекомендации</a></h3>
<ol>
<li>Используйте префикс <code>node:</code> для встроенных модулей</li>
<li>Указывайте расширения файлов явно</li>
<li>Делайте экспорты неизменяемыми (immutable)</li>
<li>Избегайте глобального состояния в модулях</li>
<li>Документируйте контракты модулей</li>
<li>Применяйте ESM для новых проектов</li>
<li>Используйте песочницы для ненадёжного кода</li>
</ol>
<h3 id="Дальнейшее-изучение"><a class="header" href="#Дальнейшее-изучение">Дальнейшее изучение</a></h3>
<ul>
<li>Документация Node.js по модулям: https://nodejs.org/api/modules.html</li>
<li>ECMAScript Modules: https://nodejs.org/api/esm.html</li>
<li>VM API: https://nodejs.org/api/vm.html</li>
<li>Package.json exports: https://nodejs.org/api/packages.html#exports</li>
</ul>
<hr />
<h2 id="Практические-задания"><a class="header" href="#Практические-задания">Практические задания</a></h2>
<ol>
<li>
<p><strong>Создайте свою систему модульности</strong></p>
<ul>
<li>Реализуйте функцию <code>load()</code> с поддержкой кэша</li>
<li>Добавьте рекурсивную загрузку зависимостей</li>
<li>Реализуйте песочницу с ограничениями</li>
</ul>
</li>
<li>
<p><strong>Исследуйте кэш модулей</strong></p>
<ul>
<li>Загрузите модуль и изучите структуру <code>require.cache</code></li>
<li>Попробуйте очистить кэш и перезагрузить модуль</li>
<li>Проверьте, как кэшируются циклические зависимости</li>
</ul>
</li>
<li>
<p><strong>Создайте универсальный пакет</strong></p>
<ul>
<li>Напишите пакет с поддержкой CommonJS и ESM</li>
<li>Используйте conditional exports</li>
<li>Добавьте множественные точки входа</li>
</ul>
</li>
<li>
<p><strong>Защита от модификаций</strong></p>
<ul>
<li>Создайте модуль с immutable API</li>
<li>Реализуйте песочницу с ограниченными возможностями</li>
<li>Напишите тесты, проверяющие невозможность модификации</li>
</ul>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../week4.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../week4/nodejs-architecture-layers-di-lecture-notes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../week4.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../week4/nodejs-architecture-layers-di-lecture-notes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
