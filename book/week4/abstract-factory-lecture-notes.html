<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Abstract Factory - Patterns</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Patterns</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Паттерн-abstract-factory-Абстрактная-фабрика"><a class="header" href="#Паттерн-abstract-factory-Абстрактная-фабрика">Паттерн Abstract Factory (Абстрактная фабрика)</a></h1>
<h2 id="Обзор"><a class="header" href="#Обзор">Обзор</a></h2>
<p><strong>Abstract Factory</strong> (Абстрактная фабрика) — это порождающий паттерн проектирования из «Банды четырёх» (GoF), который предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов без указания их конкретных классов.</p>
<h3 id="Основная-задача-паттерна"><a class="header" href="#Основная-задача-паттерна">Основная задача паттерна</a></h3>
<p>Создание <strong>семейства объектов</strong> с одинаковым контрактом, где таких семейств может быть много. Паттерн позволяет:</p>
<ul>
<li>Создавать несколько классов для доступа к одной базе данных и такое же количество классов с аналогичным контрактом для доступа к другой базе данных</li>
<li>Работать с разными провайдерами сервисов (например, AWS, Azure, Google Cloud)</li>
<li>Создавать компоненты пользовательского интерфейса для разных платформ</li>
<li>Абстрагироваться от конкретных реализаций backend-компонентов</li>
</ul>
<hr />
<h2 id="Применение-паттерна"><a class="header" href="#Применение-паттерна">Применение паттерна</a></h2>
<p>Abstract Factory применяется в самых разных областях:</p>
<ul>
<li><strong>Frontend</strong>: Рендеринг UI-компонентов для разных платформ (Web, Mobile, Desktop)</li>
<li><strong>Backend</strong>: Работа с различными базами данных, файловыми системами, облачными провайдерами</li>
<li><strong>Кросс-платформенные решения</strong>: Создание унифицированного API для разных операционных систем</li>
</ul>
<hr />
<h2 id="Соблюдение-принципов-solid"><a class="header" href="#Соблюдение-принципов-solid">Соблюдение принципов SOLID</a></h2>
<p>Паттерн Abstract Factory помогает соблюдать важные принципы проектирования:</p>
<ol>
<li><strong>Single Responsibility Principle (SRP)</strong> — каждая фабрика отвечает только за создание своего семейства объектов</li>
<li><strong>Low Coupling</strong> — слабое зацепление между клиентским кодом и конкретными реализациями</li>
<li><strong>Dependency Inversion Principle</strong> — зависимость от абстракций, а не от конкретных классов</li>
</ol>
<hr />
<h2 id="Структура-паттерна"><a class="header" href="#Структура-паттерна">Структура паттерна</a></h2>
<h3 id="Классическая-реализация-для-языков-с-интерфейсами"><a class="header" href="#Классическая-реализация-для-языков-с-интерфейсами">Классическая реализация (для языков с интерфейсами)</a></h3>
<pre><code>┌─────────────────────────┐
│  AbstractFactory        │ ◄──── Абстрактная фабрика
├─────────────────────────┤
│ + createProductA()      │
│ + createProductB()      │
└─────────────────────────┘
           △
           │
           │ Наследование
           │
┌──────────┴──────────┐
│                     │
┌─────────────────────┴─────┐    ┌─────────────────────────────┐
│  ConcreteFactory1         │    │  ConcreteFactory2           │
├───────────────────────────┤    ├─────────────────────────────┤
│ + createProductA()        │    │ + createProductA()          │
│ + createProductB()        │    │ + createProductB()          │
└───────────────────────────┘    └─────────────────────────────┘
         │                                  │
         │ Создаёт                          │ Создаёт
         ▼                                  ▼
┌─────────────────────┐            ┌─────────────────────┐
│ ConcreteProductA1   │            │ ConcreteProductA2   │
└─────────────────────┘            └─────────────────────┘
         △                                  △
         │                                  │
         │ Реализует                        │ Реализует
         │                                  │
┌─────────────────────┐            ┌─────────────────────┐
│  AbstractProductA   │            │  AbstractProductA   │
└─────────────────────┘            └─────────────────────┘
</code></pre>
<h3 id="Две-иерархии-классов"><a class="header" href="#Две-иерархии-классов">Две иерархии классов</a></h3>
<p>Паттерн использует <strong>две параллельные иерархии</strong>:</p>
<ol>
<li>
<p><strong>Абстрактная иерархия</strong>:</p>
<ul>
<li><code>AbstractFactory</code> — определяет методы создания</li>
<li><code>AbstractProductA</code>, <code>AbstractProductB</code> — определяют контракты продуктов</li>
</ul>
</li>
<li>
<p><strong>Конкретная иерархия</strong>:</p>
<ul>
<li><code>ConcreteFactory1</code>, <code>ConcreteFactory2</code> — реализации фабрик</li>
<li><code>ConcreteProductA1</code>, <code>ConcreteProductB1</code> — конкретные продукты для семейства 1</li>
<li><code>ConcreteProductA2</code>, <code>ConcreteProductB2</code> — конкретные продукты для семейства 2</li>
</ul>
</li>
</ol>
<hr />
<h2 id="Реализация-для-javascripttypescript"><a class="header" href="#Реализация-для-javascripttypescript">Реализация для JavaScript/TypeScript</a></h2>
<h3 id="Проблема-с-абстрактными-классами-в-javascript"><a class="header" href="#Проблема-с-абстрактными-классами-в-javascript">Проблема с абстрактными классами в JavaScript</a></h3>
<p>В JavaScript <strong>нет встроенной поддержки</strong> интерфейсов и абстрактных классов. Поэтому для имитации абстрактности используются следующие подходы:</p>
<h4 id="Имитация-абстрактного-класса"><a class="header" href="#Имитация-абстрактного-класса">Имитация абстрактного класса</a></h4>
<pre><code class="language-javascript">class AbstractFactory {
  constructor() {
    // Бросаем исключение при попытке создания экземпляра абстрактного класса
    if (new.target === AbstractFactory) {
      throw new Error('Cannot instantiate abstract class AbstractFactory');
    }
  }

  createProductA() {
    // Бросаем исключение для абстрактного метода
    throw new Error('Method createProductA() must be implemented');
  }

  createProductB() {
    throw new Error('Method createProductB() must be implemented');
  }
}

class AbstractProductA {
  constructor() {
    if (new.target === AbstractProductA) {
      throw new Error('Cannot instantiate abstract class');
    }
  }

  operation() {
    throw new Error('Method operation() must be implemented');
  }
}
</code></pre>
<h3 id="Упрощённая-реализация-для-javascript"><a class="header" href="#Упрощённая-реализация-для-javascript">Упрощённая реализация для JavaScript</a></h3>
<p>Для JavaScript можно значительно упростить реализацию, <strong>избавившись от абстрактных классов</strong>:</p>
<pre><code class="language-javascript">// Конкретные классы продуктов (без абстрактных базовых классов)
class FileStorageDatabase {
  constructor(filename) {
    this.filename = filename;
  }

  select(filters) {
    // Создаём курсор для итерации по файлу
    return new FileStorageCursor(this.filename, filters);
  }
}

class FileStorageCursor {
  constructor(filename, filters) {
    this.filename = filename;
    this.filters = filters;
  }

  // Асинхронный итератор для построчного чтения
  async *[Symbol.asyncIterator]() {
    const fs = require('fs');
    const readline = require('readline');

    const fileStream = fs.createReadStream(this.filename);
    const rl = readline.createInterface({
      input: fileStream,
      crlfDelay: Infinity
    });

    for await (const line of rl) {
      const data = JSON.parse(line);

      // Фильтрация данных
      if (this.matchesFilters(data)) {
        yield data;
      }
    }
  }

  matchesFilters(data) {
    // Проверка соответствия фильтрам
    for (const [field, value] of Object.entries(this.filters)) {
      if (data[field] !== value) {
        return false;
      }
    }
    return true;
  }
}

// Фабрика как простой объект с методами
const fsDataAccessLayer = {
  createDatabase(filename) {
    return new FileStorageDatabase(filename);
  },

  createCursor(filename, filters) {
    return new FileStorageCursor(filename, filters);
  }
};

// Экспортируем фабрику
module.exports = fsDataAccessLayer;
</code></pre>
<hr />
<h2 id="Практический-пример-Работа-с-базами-данных"><a class="header" href="#Практический-пример-Работа-с-базами-данных">Практический пример: Работа с базами данных</a></h2>
<h3 id="Полная-реализация-с-файловым-хранилищем"><a class="header" href="#Полная-реализация-с-файловым-хранилищем">Полная реализация с файловым хранилищем</a></h3>
<p>Рассмотрим реальный пример создания абстракции для работы с данными, где одна реализация использует файловую систему, а другая может использовать PostgreSQL или MySQL.</p>
<h4 id="Шаг-1-Абстрактная-фабрика-для-языков-с-интерфейсами"><a class="header" href="#Шаг-1-Абстрактная-фабрика-для-языков-с-интерфейсами">Шаг 1: Абстрактная фабрика (для языков с интерфейсами)</a></h4>
<pre><code class="language-javascript">class AbstractDataAccessLayer {
  constructor() {
    if (new.target === AbstractDataAccessLayer) {
      throw new Error('Cannot instantiate abstract factory');
    }
  }

  createDatabase() {
    throw new Error('Method createDatabase() must be implemented');
  }

  createCursor() {
    throw new Error('Method createCursor() must be implemented');
  }
}
</code></pre>
<h4 id="Шаг-2-Абстрактные-продукты"><a class="header" href="#Шаг-2-Абстрактные-продукты">Шаг 2: Абстрактные продукты</a></h4>
<pre><code class="language-javascript">// Абстрактная база данных
class AbstractDatabase {
  constructor() {
    if (new.target === AbstractDatabase) {
      throw new Error('Cannot instantiate abstract class');
    }
  }

  select(filters) {
    throw new Error('Method select() must be implemented');
  }
}

// Абстрактный курсор
class AbstractCursor {
  constructor() {
    if (new.target === AbstractCursor) {
      throw new Error('Cannot instantiate abstract class');
    }
  }

  async *[Symbol.asyncIterator]() {
    throw new Error('Async iterator must be implemented');
  }
}
</code></pre>
<h4 id="Шаг-3-Конкретная-реализация--filestorage"><a class="header" href="#Шаг-3-Конкретная-реализация--filestorage">Шаг 3: Конкретная реализация — FileStorage</a></h4>
<pre><code class="language-javascript">const fs = require('fs');
const readline = require('readline');

// Конкретная база данных для файлового хранилища
class FileStorageDatabase extends AbstractDatabase {
  constructor(filename) {
    super();
    this.filename = filename;
  }

  select(filters) {
    // Создаём курсор с фильтрами
    return new FileStorageCursor(this.filename, filters);
  }
}

// Конкретный курсор для файлового хранилища
class FileStorageCursor extends AbstractCursor {
  constructor(filename, filters) {
    super();
    this.filename = filename;
    this.filters = filters;
  }

  // Асинхронный итератор для построчного чтения и парсинга
  async *[Symbol.asyncIterator]() {
    const fileStream = fs.createReadStream(this.filename);
    const rl = readline.createInterface({
      input: fileStream,
      crlfDelay: Infinity
    });

    for await (const line of rl) {
      try {
        const record = JSON.parse(line);

        // Проверяем соответствие фильтрам
        if (this.matchesFilters(record)) {
          yield record;
        }
      } catch (error) {
        // Пропускаем невалидные строки
        console.error('Invalid JSON line:', line);
      }
    }
  }

  matchesFilters(record) {
    // Если фильтров нет — возвращаем все записи
    if (!this.filters || Object.keys(this.filters).length === 0) {
      return true;
    }

    // Проверяем каждое поле в фильтре
    for (const [field, value] of Object.entries(this.filters)) {
      if (record[field] !== value) {
        return false;
      }
    }

    return true;
  }
}
</code></pre>
<h4 id="Шаг-4-Конкретная-фабрика"><a class="header" href="#Шаг-4-Конкретная-фабрика">Шаг 4: Конкретная фабрика</a></h4>
<pre><code class="language-javascript">// Конкретная фабрика для файлового хранилища
class FSDataAccessLayer extends AbstractDataAccessLayer {
  createDatabase(filename) {
    return new FileStorageDatabase(filename);
  }

  createCursor(filename, filters) {
    return new FileStorageCursor(filename, filters);
  }
}

module.exports = FSDataAccessLayer;
</code></pre>
<h4 id="Шаг-5-Использование"><a class="header" href="#Шаг-5-Использование">Шаг 5: Использование</a></h4>
<pre><code class="language-javascript">// Создаём экземпляр фабрики
const fsDAL = new FSDataAccessLayer();

// Создаём базу данных
const db = fsDAL.createDatabase('./data/users.jsonl');

// Выполняем select с фильтром
const cursor = db.select({ city: 'Moscow' });

// Итерируемся по результатам
(async () =&gt; {
  for await (const user of cursor) {
    console.log(`User: ${user.name}, City: ${user.city}`);
  }
})();
</code></pre>
<p><strong>Преимущества такого подхода:</strong></p>
<ul>
<li>Очень большой файл читается <strong>построчно</strong> (не загружается целиком в память)</li>
<li>Используется <strong>асинхронный итератор</strong> для эффективной работы с I/O</li>
<li>Данные <strong>фильтруются на лету</strong> во время чтения</li>
<li>Код легко расширить для работы с другими источниками данных (PostgreSQL, MongoDB, S3)</li>
</ul>
<hr />
<h2 id="Упрощённая-реализация-для-javascript-без-абстракций"><a class="header" href="#Упрощённая-реализация-для-javascript-без-абстракций">Упрощённая реализация для JavaScript (без абстракций)</a></h2>
<p>Для JavaScript можно полностью отказаться от абстрактных классов и использовать <strong>простые объекты и функции</strong>:</p>
<h3 id="Вариант-1-Объект-с-методами"><a class="header" href="#Вариант-1-Объект-с-методами">Вариант 1: Объект с методами</a></h3>
<pre><code class="language-javascript">// fs-dal.js — Модуль для файловой системы
const fs = require('fs');
const readline = require('readline');

class FileStorageDatabase {
  constructor(filename) {
    this.filename = filename;
  }

  select(filters) {
    return new FileStorageCursor(this.filename, filters);
  }
}

class FileStorageCursor {
  constructor(filename, filters) {
    this.filename = filename;
    this.filters = filters;
  }

  async *[Symbol.asyncIterator]() {
    const fileStream = fs.createReadStream(this.filename);
    const rl = readline.createInterface({
      input: fileStream,
      crlfDelay: Infinity
    });

    for await (const line of rl) {
      const record = JSON.parse(line);
      if (this.matchesFilters(record)) {
        yield record;
      }
    }
  }

  matchesFilters(record) {
    if (!this.filters) return true;
    return Object.entries(this.filters).every(
      ([key, value]) =&gt; record[key] === value
    );
  }
}

// Экспортируем фабрику как объект с методами
module.exports = {
  createDatabase(filename) {
    return new FileStorageDatabase(filename);
  },

  createCursor(filename, filters) {
    return new FileStorageCursor(filename, filters);
  }
};
</code></pre>
<h3 id="Коллекция-фабрик-паттерн-strategy"><a class="header" href="#Коллекция-фабрик-паттерн-strategy">Коллекция фабрик (паттерн Strategy)</a></h3>
<p>Для переключения между различными реализациями используем <strong>коллекцию фабрик</strong>:</p>
<pre><code class="language-javascript">// data-access-factories.js
const fsDAL = require('./fs-dal');
const pgDAL = require('./pg-dal');
const mysqlDAL = require('./mysql-dal');

// Коллекция фабрик для разных хранилищ
const factories = {
  fs: fsDAL,
  postgres: pgDAL,
  mysql: mysqlDAL
};

// Функция для выбора нужной фабрики
function getFactory(storageType) {
  const factory = factories[storageType];

  if (!factory) {
    throw new Error(`Unknown storage type: ${storageType}`);
  }

  return factory;
}

module.exports = { factories, getFactory };
</code></pre>
<h3 id="Использование-с-выбором-стратегии"><a class="header" href="#Использование-с-выбором-стратегии">Использование с выбором стратегии</a></h3>
<pre><code class="language-javascript">const { getFactory } = require('./data-access-factories');

// Выбираем стратегию (можно из конфига или переменных окружения)
const storageType = process.env.STORAGE_TYPE || 'fs';
const dal = getFactory(storageType);

// Создаём базу данных
const db = dal.createDatabase('./data/users.jsonl');

// Выполняем запрос
const cursor = db.select({ city: 'Moscow' });

// Используем результаты
(async () =&gt; {
  for await (const user of cursor) {
    console.log(`User: ${user.name}, Email: ${user.email}`);
  }
})();
</code></pre>
<p><strong>Важно:</strong> Здесь сочетаются два паттерна:</p>
<ul>
<li><strong>Abstract Factory</strong> — для создания семейства объектов (Database + Cursor)</li>
<li><strong>Strategy</strong> — для выбора конкретной фабрики из коллекции</li>
</ul>
<hr />
<h2 id="Реализация-с-typescript"><a class="header" href="#Реализация-с-typescript">Реализация с TypeScript</a></h2>
<p>TypeScript позволяет использовать <strong>интерфейсы</strong> для строгой типизации:</p>
<pre><code class="language-typescript">// Интерфейсы для продуктов
interface IDatabase {
  select(filters: Record&lt;string, any&gt;): ICursor;
}

interface ICursor {
  [Symbol.asyncIterator](): AsyncIterator&lt;any&gt;;
}

// Интерфейс для фабрики
interface IDataAccessLayer {
  createDatabase(config: any): IDatabase;
  createCursor(config: any, filters: Record&lt;string, any&gt;): ICursor;
}

// Реализация для файлового хранилища
class FileStorageDatabase implements IDatabase {
  constructor(private filename: string) {}

  select(filters: Record&lt;string, any&gt;): ICursor {
    return new FileStorageCursor(this.filename, filters);
  }
}

class FileStorageCursor implements ICursor {
  constructor(
    private filename: string,
    private filters: Record&lt;string, any&gt;
  ) {}

  async *[Symbol.asyncIterator](): AsyncIterator&lt;any&gt; {
    const fs = await import('fs');
    const readline = await import('readline');

    const fileStream = fs.createReadStream(this.filename);
    const rl = readline.createInterface({
      input: fileStream,
      crlfDelay: Infinity
    });

    for await (const line of rl) {
      const record = JSON.parse(line);
      if (this.matchesFilters(record)) {
        yield record;
      }
    }
  }

  private matchesFilters(record: any): boolean {
    if (!this.filters || Object.keys(this.filters).length === 0) {
      return true;
    }

    return Object.entries(this.filters).every(
      ([key, value]) =&gt; record[key] === value
    );
  }
}

// Конкретная фабрика
class FSDataAccessLayer implements IDataAccessLayer {
  createDatabase(filename: string): IDatabase {
    return new FileStorageDatabase(filename);
  }

  createCursor(filename: string, filters: Record&lt;string, any&gt;): ICursor {
    return new FileStorageCursor(filename, filters);
  }
}

// Использование
const dal: IDataAccessLayer = new FSDataAccessLayer();
const db: IDatabase = dal.createDatabase('./data/users.jsonl');
const cursor: ICursor = db.select({ city: 'Moscow' });

(async () =&gt; {
  for await (const user of cursor) {
    console.log(user);
  }
})();
</code></pre>
<p><strong>Преимущества TypeScript-реализации:</strong></p>
<ul>
<li>✅ <strong>Строгая типизация</strong> всех методов и возвращаемых значений</li>
<li>✅ <strong>Автодополнение</strong> в IDE на основе интерфейсов</li>
<li>✅ <strong>Проверка на этапе компиляции</strong> — ошибки находятся до выполнения</li>
<li>✅ <strong>Явные контракты</strong> через интерфейсы</li>
</ul>
<hr />
<h2 id="Классический-пример-ui-библиотека-для-разных-платформ"><a class="header" href="#Классический-пример-ui-библиотека-для-разных-платформ">Классический пример: UI-библиотека для разных платформ</a></h2>
<h3 id="Задача"><a class="header" href="#Задача">Задача</a></h3>
<p>Создать библиотеку UI-компонентов, которая может рендерить элементы для:</p>
<ul>
<li>Web (HTML/CSS)</li>
<li>Windows (WinAPI)</li>
<li>macOS (Cocoa)</li>
</ul>
<h3 id="Реализация"><a class="header" href="#Реализация">Реализация</a></h3>
<pre><code class="language-typescript">// Интерфейсы продуктов
interface IButton {
  render(): void;
  onClick(callback: () =&gt; void): void;
}

interface ICheckbox {
  render(): void;
  toggle(): void;
  isChecked(): boolean;
}

// Интерфейс абстрактной фабрики
interface IUIFactory {
  createButton(label: string): IButton;
  createCheckbox(label: string): ICheckbox;
}

// Реализация для Web
class WebButton implements IButton {
  constructor(private label: string) {}

  render(): void {
    console.log(`&lt;button&gt;${this.label}&lt;/button&gt;`);
  }

  onClick(callback: () =&gt; void): void {
    console.log(`Attached click handler to button: ${this.label}`);
  }
}

class WebCheckbox implements ICheckbox {
  private checked = false;

  constructor(private label: string) {}

  render(): void {
    console.log(`&lt;input type="checkbox" /&gt; ${this.label}`);
  }

  toggle(): void {
    this.checked = !this.checked;
  }

  isChecked(): boolean {
    return this.checked;
  }
}

// Фабрика для Web
class WebUIFactory implements IUIFactory {
  createButton(label: string): IButton {
    return new WebButton(label);
  }

  createCheckbox(label: string): ICheckbox {
    return new WebCheckbox(label);
  }
}

// Реализация для Windows
class WindowsButton implements IButton {
  constructor(private label: string) {}

  render(): void {
    console.log(`[Win32 Button: ${this.label}]`);
  }

  onClick(callback: () =&gt; void): void {
    console.log(`Attached WM_COMMAND handler to: ${this.label}`);
  }
}

class WindowsCheckbox implements ICheckbox {
  private checked = false;

  constructor(private label: string) {}

  render(): void {
    console.log(`[Win32 Checkbox: ${this.label}]`);
  }

  toggle(): void {
    this.checked = !this.checked;
  }

  isChecked(): boolean {
    return this.checked;
  }
}

// Фабрика для Windows
class WindowsUIFactory implements IUIFactory {
  createButton(label: string): IButton {
    return new WindowsButton(label);
  }

  createCheckbox(label: string): ICheckbox {
    return new WindowsCheckbox(label);
  }
}

// Клиентский код
class Application {
  private button: IButton;
  private checkbox: ICheckbox;

  constructor(factory: IUIFactory) {
    this.button = factory.createButton('Submit');
    this.checkbox = factory.createCheckbox('Remember me');
  }

  render(): void {
    this.button.render();
    this.checkbox.render();
  }
}

// Использование
function main() {
  const platform = process.platform;

  let factory: IUIFactory;

  if (platform === 'win32') {
    factory = new WindowsUIFactory();
  } else {
    factory = new WebUIFactory();
  }

  const app = new Application(factory);
  app.render();
}

main();
</code></pre>
<hr />
<h2 id="Преимущества-паттерна-abstract-factory"><a class="header" href="#Преимущества-паттерна-abstract-factory">Преимущества паттерна Abstract Factory</a></h2>
<h3 id="-1-Изоляция-конкретных-классов"><a class="header" href="#-1-Изоляция-конкретных-классов">✅ 1. Изоляция конкретных классов</a></h3>
<p>Клиентский код работает только с интерфейсами, не зная о конкретных реализациях:</p>
<pre><code class="language-javascript">// Клиент знает только об интерфейсах
function processData(factory) {
  const db = factory.createDatabase(config);
  const cursor = db.select({ status: 'active' });

  // Не важно, используется PostgreSQL, MySQL или файловая система
  for await (const record of cursor) {
    console.log(record);
  }
}
</code></pre>
<h3 id="-2-Гарантия-совместимости-продуктов"><a class="header" href="#-2-Гарантия-совместимости-продуктов">✅ 2. Гарантия совместимости продуктов</a></h3>
<p>Все продукты одной фабрики <strong>гарантированно совместимы</strong> между собой:</p>
<pre><code class="language-typescript">// FileStorageDatabase всегда создаёт FileStorageCursor
// PostgresDatabase всегда создаёт PostgresCursor
// Нет риска смешать курсор от одной БД с соединением к другой
</code></pre>
<h3 id="-3-Лёгкость-добавления-новых-семейств"><a class="header" href="#-3-Лёгкость-добавления-новых-семейств">✅ 3. Лёгкость добавления новых семейств</a></h3>
<p>Для добавления новой реализации (например, MongoDB) нужно:</p>
<ol>
<li>Создать классы продуктов (<code>MongoDatabase</code>, <code>MongoCursor</code>)</li>
<li>Создать фабрику (<code>MongoDataAccessLayer</code>)</li>
<li>Добавить её в коллекцию</li>
</ol>
<p><strong>Существующий код не меняется!</strong></p>
<h3 id="-4-Соответствие-принципу-openclosed"><a class="header" href="#-4-Соответствие-принципу-openclosed">✅ 4. Соответствие принципу Open/Closed</a></h3>
<ul>
<li><strong>Open for extension</strong> — легко добавить новую фабрику</li>
<li><strong>Closed for modification</strong> — не нужно менять существующий код</li>
</ul>
<hr />
<h2 id="Недостатки-и-ограничения"><a class="header" href="#Недостатки-и-ограничения">Недостатки и ограничения</a></h2>
<h3 id="-1-Сложность-кода"><a class="header" href="#-1-Сложность-кода">❌ 1. Сложность кода</a></h3>
<p>Добавление каждого нового типа продукта требует изменений во <strong>всех фабриках</strong>:</p>
<pre><code class="language-typescript">// Если нужно добавить createIndex(), придётся изменить:
interface IDataAccessLayer {
  createDatabase(config: any): IDatabase;
  createCursor(config: any, filters: any): ICursor;
  createIndex(config: any): IIndex; // ← Новый метод
}

// И все реализации:
class FSDataAccessLayer implements IDataAccessLayer {
  // Нужно реализовать createIndex()
}

class PostgresDataAccessLayer implements IDataAccessLayer {
  // Нужно реализовать createIndex()
}
</code></pre>
<h3 id="-2-Излишняя-абстракция-для-простых-случаев"><a class="header" href="#-2-Излишняя-абстракция-для-простых-случаев">❌ 2. Излишняя абстракция для простых случаев</a></h3>
<p>Если нужно создать только <strong>один класс</strong>, Abstract Factory избыточен. В таких случаях достаточно <strong>Factory Method</strong> или простой функции.</p>
<hr />
<h2 id="Отличие-от-factory-method"><a class="header" href="#Отличие-от-factory-method">Отличие от Factory Method</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Характеристика</th><th>Factory Method</th><th>Abstract Factory</th></tr></thead><tbody>
<tr><td><strong>Количество продуктов</strong></td><td>Один тип продукта</td><td>Семейство продуктов</td></tr>
<tr><td><strong>Структура</strong></td><td>Один метод <code>create()</code></td><td>Несколько методов создания</td></tr>
<tr><td><strong>Применение</strong></td><td>Когда нужна вариативность одного объекта</td><td>Когда нужно создавать взаимосвязанные объекты</td></tr>
<tr><td><strong>Пример</strong></td><td>Создание логгера (FileLogger, ConsoleLogger)</td><td>Создание UI-компонентов (Button + Checkbox)</td></tr>
</tbody></table>
</div>
<h3 id="Пример-factory-method"><a class="header" href="#Пример-factory-method">Пример Factory Method</a></h3>
<pre><code class="language-javascript">// Простая фабричная функция
function createLogger(type) {
  switch (type) {
    case 'file':
      return new FileLogger();
    case 'console':
      return new ConsoleLogger();
    default:
      throw new Error('Unknown logger type');
  }
}
</code></pre>
<h3 id="Пример-abstract-factory"><a class="header" href="#Пример-abstract-factory">Пример Abstract Factory</a></h3>
<pre><code class="language-javascript">// Фабрика создаёт целое семейство
const uiFactory = new WebUIFactory();
const button = uiFactory.createButton('OK');
const checkbox = uiFactory.createCheckbox('Agree');
const textbox = uiFactory.createTextbox('Enter name');
</code></pre>
<hr />
<h2 id="Когда-использовать-abstract-factory"><a class="header" href="#Когда-использовать-abstract-factory">Когда использовать Abstract Factory</a></h2>
<h3 id="-Используйте-когда"><a class="header" href="#-Используйте-когда">✅ Используйте, когда:</a></h3>
<ol>
<li>
<p><strong>Нужно создать семейство взаимосвязанных объектов</strong></p>
<ul>
<li>UI-компоненты одной темы (Light/Dark)</li>
<li>Классы доступа к одной БД (Connection + Cursor + Transaction)</li>
</ul>
</li>
<li>
<p><strong>Система должна быть независима от способа создания объектов</strong></p>
<ul>
<li>Подмена реализации через конфигурацию</li>
<li>Тестирование с моками</li>
</ul>
</li>
<li>
<p><strong>Требуется обеспечить совместимость продуктов</strong></p>
<ul>
<li>Все объекты из одной фабрики гарантированно работают вместе</li>
</ul>
</li>
<li>
<p><strong>Нужно предоставить библиотеку, скрывающую детали реализации</strong></p>
<ul>
<li>Клиент работает только с интерфейсами</li>
</ul>
</li>
</ol>
<h3 id="-Не-используйте-когда"><a class="header" href="#-Не-используйте-когда">❌ Не используйте, когда:</a></h3>
<ol>
<li>Нужно создать <strong>один объект</strong> — используйте Factory Method</li>
<li>Объекты <strong>не связаны</strong> между собой — используйте отдельные фабрики</li>
<li><strong>Простая система</strong> без вариативности реализаций</li>
</ol>
<hr />
<h2 id="Комбинация-с-другими-паттернами"><a class="header" href="#Комбинация-с-другими-паттернами">Комбинация с другими паттернами</a></h2>
<h3 id="1-abstract-factory--strategy"><a class="header" href="#1-abstract-factory--strategy">1. Abstract Factory + Strategy</a></h3>
<pre><code class="language-javascript">// Коллекция фабрик — это паттерн Strategy
const factories = {
  development: new MockDataAccessLayer(),
  production: new PostgresDataAccessLayer(),
  testing: new InMemoryDataAccessLayer()
};

const factory = factories[process.env.NODE_ENV];
</code></pre>
<h3 id="2-abstract-factory--singleton"><a class="header" href="#2-abstract-factory--singleton">2. Abstract Factory + Singleton</a></h3>
<pre><code class="language-javascript">class DatabaseFactory {
  static #instance = null;

  static getInstance() {
    if (!DatabaseFactory.#instance) {
      const type = process.env.DB_TYPE || 'postgres';
      DatabaseFactory.#instance = factories[type];
    }
    return DatabaseFactory.#instance;
  }
}

// Использование
const factory = DatabaseFactory.getInstance();
const db = factory.createDatabase(config);
</code></pre>
<h3 id="3-abstract-factory--builder"><a class="header" href="#3-abstract-factory--builder">3. Abstract Factory + Builder</a></h3>
<pre><code class="language-javascript">// Фабрика создаёт Builder для сложных объектов
class QueryBuilderFactory {
  createQueryBuilder() {
    return new PostgresQueryBuilder();
  }
}

const factory = new QueryBuilderFactory();
const builder = factory.createQueryBuilder();

const query = builder
  .select(['name', 'email'])
  .from('users')
  .where({ active: true })
  .build();
</code></pre>
<hr />
<h2 id="Резюме"><a class="header" href="#Резюме">Резюме</a></h2>
<h3 id="Ключевые-моменты"><a class="header" href="#Ключевые-моменты">Ключевые моменты</a></h3>
<ol>
<li><strong>Abstract Factory</strong> создаёт <strong>семейства объектов</strong> с общим контрактом</li>
<li>Использует <strong>две иерархии</strong>: абстрактную и конкретную</li>
<li>В <strong>JavaScript</strong> можно упростить, убрав абстрактные классы</li>
<li>В <strong>TypeScript</strong> лучше использовать интерфейсы для строгой типизации</li>
<li>Часто комбинируется с паттерном <strong>Strategy</strong> для выбора фабрики</li>
</ol>
<h3 id="Основные-принципы"><a class="header" href="#Основные-принципы">Основные принципы</a></h3>
<ul>
<li><strong>Слабое зацепление</strong> (Low Coupling) — клиент не зависит от конкретных классов</li>
<li><strong>Single Responsibility</strong> — каждая фабрика отвечает за своё семейство</li>
<li><strong>Open/Closed Principle</strong> — легко добавлять новые фабрики без изменения существующего кода</li>
</ul>
<h3 id="Практическое-применение"><a class="header" href="#Практическое-применение">Практическое применение</a></h3>
<p>Abstract Factory идеально подходит для:</p>
<ul>
<li>Работы с <strong>разными базами данных</strong> (PostgreSQL, MySQL, MongoDB, FileSystem)</li>
<li>Рендеринга <strong>UI для разных платформ</strong> (Web, Desktop, Mobile)</li>
<li>Абстрагирования <strong>облачных провайдеров</strong> (AWS, Azure, GCP)</li>
<li>Создания <strong>тестовых моков</strong> вместо реальных сервисов</li>
</ul>
<hr />
<h2 id="Дополнительные-ресурсы"><a class="header" href="#Дополнительные-ресурсы">Дополнительные ресурсы</a></h2>
<ul>
<li><a href="https://refactoring.guru/design-patterns/abstract-factory">Refactoring Guru: Abstract Factory</a></li>
<li><a href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">GoF Design Patterns Book</a></li>
<li><a href="https://github.com/refactoringguru/design-patterns-typescript">TypeScript Design Patterns Repository</a></li>
</ul>
<hr />
<h2 id="Примеры-кода-из-лекции"><a class="header" href="#Примеры-кода-из-лекции">Примеры кода из лекции</a></h2>
<p>Все примеры кода из лекции доступны по ссылке в описании видео. Рекомендуется:</p>
<ol>
<li><strong>Скачать исходники</strong> и запустить их локально</li>
<li><strong>Модифицировать</strong> код, добавив новые фабрики (например, для PostgreSQL)</li>
<li><strong>Попробовать</strong> реализовать Abstract Factory для своего проекта</li>
<li><strong>Поэкспериментировать</strong> с комбинацией паттернов (Strategy + Abstract Factory)</li>
</ol>
<hr />
<p><strong>Автор конспекта:</strong> Claude Code
<strong>Дата создания:</strong> 2025-12-18
<strong>Источник:</strong> Лекция по паттерну Abstract Factory для JavaScript/TypeScript</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../week4/nodejs-architecture-layers-di-lecture-notes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../week4/factory-method-pattern-notes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../week4/nodejs-architecture-layers-di-lecture-notes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../week4/factory-method-pattern-notes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
