<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Disposable - Patterns</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Patterns</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Явное-управление-ресурсами-при-помощи-using-и-symboldispose-в-javascript-typescript-nodejs"><a class="header" href="#Явное-управление-ресурсами-при-помощи-using-и-symboldispose-в-javascript-typescript-nodejs">Явное управление ресурсами при помощи Using и Symbol.dispose в JavaScript, TypeScript, Node.js</a></h1>
<h2 id="Обзор"><a class="header" href="#Обзор">Обзор</a></h2>
<p>Данная лекция посвящена новым механизмам явного управления ресурсами в JavaScript и TypeScript. Основные темы включают:</p>
<ul>
<li>Новые символы <code>Symbol.dispose</code> и <code>Symbol.asyncDispose</code></li>
<li>Конструкции <code>using</code> и <code>await using</code></li>
<li>Сравнение с традиционными подходами (try/finally, Finalization Registry)</li>
<li>Синхронное и асинхронное освобождение ресурсов</li>
<li>Практические примеры и вложенные контексты</li>
</ul>
<hr />
<h2 id="Содержание"><a class="header" href="#Содержание">Содержание</a></h2>
<ol>
<li><a href="#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81%D0%B0%D0%BC%D0%B8">Введение: зачем нужно управление ресурсами</a></li>
<li><a href="#%D1%82%D1%80%D0%B0%D0%B4%D0%B8%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B4%D1%85%D0%BE%D0%B4-tryfinally">Традиционный подход: try/finally</a></li>
<li><a href="#finalization-registry">Finalization Registry</a></li>
<li><a href="#%D0%BD%D0%BE%D0%B2%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B4%D1%85%D0%BE%D0%B4-using-%D0%B8-symboldispose">Новый подход: using и Symbol.dispose</a></li>
<li><a href="#%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BE%D1%81%D0%B2%D0%BE%D0%B1%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-await-using">Асинхронное освобождение: await using</a></li>
<li><a href="#%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%B8%D1%8F-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D1%8B%D0%BC-%D0%B8-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D1%8B%D0%BC-dispose">Различия между синхронным и асинхронным dispose</a></li>
<li><a href="#%D0%B2%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%D1%8B">Вложенные контексты</a></li>
<li><a href="#%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0-dispose">Порядок вызова dispose</a></li>
<li><a href="#%D1%80%D0%B5%D0%B7%D1%8E%D0%BC%D0%B5">Резюме</a></li>
</ol>
<hr />
<h2 id="Введение-зачем-нужно-управление-ресурсами"><a class="header" href="#Введение-зачем-нужно-управление-ресурсами">Введение: зачем нужно управление ресурсами</a></h2>
<h3 id="Проблематика"><a class="header" href="#Проблематика">Проблематика</a></h3>
<p>При работе с ресурсами (файлы, сетевые соединения, базы данных) необходимо обеспечить их корректное освобождение:</p>
<ul>
<li>Предотвратить утечки памяти</li>
<li>Закрыть файловые дескрипторы</li>
<li>Освободить системные ресурсы</li>
<li>Обработать ошибки при освобождении</li>
</ul>
<p><strong>Ключевой момент</strong>: ресурс нужно освободить независимо от того, была ли ошибка во время его использования.</p>
<hr />
<h2 id="Традиционный-подход-tryfinally"><a class="header" href="#Традиционный-подход-tryfinally">Традиционный подход: try/finally</a></h2>
<h3 id="Пример-работа-с-логером-через-tryfinally"><a class="header" href="#Пример-работа-с-логером-через-tryfinally">Пример: работа с логером через try/finally</a></h3>
<pre><code class="language-javascript">async function usingSection() {
  let logger = null;

  try {
    // Создание ресурса (может выбросить ошибку)
    logger = await new Logger('./app.log');

    // Использование ресурса (может выбросить ошибку)
    await logger.write('Starting application...');
    await logger.write('Processing data...');

  } catch (error) {
    console.error('Error occurred:', error);

  } finally {
    // Обязательная очистка ресурса
    if (logger) {
      await logger.close();
      console.log('Logger closed in finally block');
    }
  }
}
</code></pre>
<h3 id="Недостатки-традиционного-подхода"><a class="header" href="#Недостатки-традиционного-подхода">Недостатки традиционного подхода</a></h3>
<ol>
<li><strong>Громоздкость</strong>: требуется явная проверка существования ресурса</li>
<li><strong>Дублирование кода</strong>: логика очистки повторяется для каждого ресурса</li>
<li><strong>Сложность</strong>: при множественных ресурсах код становится трудночитаемым</li>
<li><strong>Ошибки</strong>: легко забыть добавить finally или проверку на null</li>
</ol>
<p><strong>Пример проблемы с несколькими ресурсами:</strong></p>
<pre><code class="language-javascript">async function multipleResources() {
  let connection = null;
  let file = null;
  let cache = null;

  try {
    connection = await openDatabase();
    file = await openFile('./data.txt');
    cache = await createCache();

    // Работа с ресурсами...

  } finally {
    // Нужно закрыть все ресурсы в обратном порядке
    if (cache) await cache.flush();
    if (file) await file.close();
    if (connection) await connection.close();
  }
}
</code></pre>
<hr />
<h2 id="finalization-registry"><a class="header" href="#finalization-registry">Finalization Registry</a></h2>
<h3 id="Концепция"><a class="header" href="#Концепция">Концепция</a></h3>
<p><code>FinalizationRegistry</code> — это механизм, позволяющий выполнить код при сборке мусора, когда на объект больше нет ссылок.</p>
<h3 id="Пример-использования"><a class="header" href="#Пример-использования">Пример использования</a></h3>
<pre><code class="language-javascript">// Создание глобального реестра финализации
const registry = new FinalizationRegistry((resource) =&gt; {
  console.log('Finalization callback triggered');
  if (resource &amp;&amp; resource.close) {
    resource.close();
    console.log('File closed by FinalizationRegistry');
  }
});

class Logger {
  #handle;

  constructor(path) {
    this.#handle = fs.openSync(path, 'a');

    // Регистрация ресурса для автоматической очистки
    registry.register(
      this,           // Объект, за которым следим
      this.#handle    // Данные для callback
    );
  }

  write(message) {
    fs.writeSync(this.#handle, message + '\n');
  }
}

// Использование
function example() {
  const logger = new Logger('./app.log');
  logger.write('Message');
  // logger выходит из области видимости
}

example();

// Принудительный вызов сборщика мусора (только с флагом --expose-gc)
if (global.gc) {
  global.gc();
}
</code></pre>
<h3 id="Запуск-с-флагом-expose-gc"><a class="header" href="#Запуск-с-флагом-expose-gc">Запуск с флагом expose-gc</a></h3>
<pre><code class="language-bash"># Для запуска с возможностью ручного вызова GC
node --expose-gc example1-finalization.js
</code></pre>
<h3 id="Проблемы-finalizationregistry"><a class="header" href="#Проблемы-finalizationregistry">Проблемы FinalizationRegistry</a></h3>
<ol>
<li><strong>Непредсказуемость</strong>: нельзя точно знать, когда вызовется callback</li>
<li><strong>Задержки</strong>: GC может не запуститься долгое время</li>
<li><strong>Нет гарантий</strong>: callback может вообще не вызваться</li>
<li><strong>Зависимость от памяти</strong>: пока есть свободная память, GC не торопится</li>
<li><strong>Старые объекты</strong>: объекты в old generation собираются редко</li>
</ol>
<p><strong>Важно</strong>: FinalizationRegistry НЕ подходит для критичных ресурсов (файлы, соединения), которые нужно закрыть немедленно.</p>
<hr />
<h2 id="Новый-подход-using-и-symboldispose"><a class="header" href="#Новый-подход-using-и-symboldispose">Новый подход: using и Symbol.dispose</a></h2>
<h3 id="Основная-идея"><a class="header" href="#Основная-идея">Основная идея</a></h3>
<p>Конструкция <code>using</code> автоматически вызывает метод <code>Symbol.dispose</code> при выходе из блока видимости, где объявлена переменная.</p>
<h3 id="Базовый-пример"><a class="header" href="#Базовый-пример">Базовый пример</a></h3>
<pre><code class="language-javascript">class Logger {
  #handle;

  constructor(path) {
    this.#handle = fs.openSync(path, 'a');
    console.log(`Logger created for ${path}`);
  }

  write(message) {
    fs.writeSync(this.#handle, message + '\n');
  }

  // Метод для синхронного освобождения ресурса
  [Symbol.dispose]() {
    console.log('Disposing logger (sync)');
    if (this.#handle) {
      fs.closeSync(this.#handle);
      console.log('File closed');
    }
  }
}

// Использование с using
function main() {
  using logger = new Logger('./app.log');

  logger.write('Application started');
  logger.write('Processing...');

  // При выходе из функции автоматически вызовется logger[Symbol.dispose]()
}

main();
console.log('After main completed');
</code></pre>
<h3 id="Как-это-работает"><a class="header" href="#Как-это-работает">Как это работает</a></h3>
<ol>
<li><strong>Объявление</strong>: <code>using logger = new Logger(...)</code> создает ресурс</li>
<li><strong>Использование</strong>: работаем с ресурсом в пределах блока</li>
<li><strong>Автоматическая очистка</strong>: при достижении закрывающей скобки <code>}</code> вызывается <code>logger[Symbol.dispose]()</code></li>
<li><strong>Гарантия выполнения</strong>: dispose вызывается даже при ошибках</li>
</ol>
<h3 id="Эквивалентный-код-без-using"><a class="header" href="#Эквивалентный-код-без-using">Эквивалентный код без using</a></h3>
<pre><code class="language-javascript">function main() {
  const logger = new Logger('./app.log');

  try {
    logger.write('Application started');
    logger.write('Processing...');
  } finally {
    logger[Symbol.dispose]();
  }
}
</code></pre>
<h3 id="Ключевые-особенности-using"><a class="header" href="#Ключевые-особенности-using">Ключевые особенности using</a></h3>
<p><strong>1. Привязка к области видимости</strong></p>
<pre><code class="language-javascript">function example() {
  using resource = createResource();

  // resource доступен здесь
  console.log('Using resource');

} // &lt;-- resource[Symbol.dispose]() вызывается ЗДЕСЬ
</code></pre>
<p><strong>2. Работа с блоками</strong></p>
<pre><code class="language-javascript">function blockScopes() {
  console.log('Start');

  {
    using temp = createTempResource();
    console.log('Inside block');
  } // temp.dispose() вызывается здесь

  console.log('After block');
}
</code></pre>
<p><strong>3. Передача ссылки не влияет на dispose</strong></p>
<pre><code class="language-javascript">let externalRef;

function example() {
  using resource = createResource();
  externalRef = resource; // Сохранили ссылку во внешней переменной

} // resource[Symbol.dispose]() ВСЁ РАВНО вызовется здесь!

// externalRef теперь указывает на "disposed" объект
</code></pre>
<p><strong>Важное отличие от Finalization Registry</strong>: <code>using</code> освобождает ресурс при выходе из блока, а не при отсутствии ссылок!</p>
<hr />
<h2 id="Асинхронное-освобождение-await-using"><a class="header" href="#Асинхронное-освобождение-await-using">Асинхронное освобождение: await using</a></h2>
<h3 id="symbolasyncdispose"><a class="header" href="#symbolasyncdispose">Symbol.asyncDispose</a></h3>
<p>Для асинхронной очистки ресурсов используется <code>Symbol.asyncDispose</code> в комбинации с <code>await using</code>.</p>
<h3 id="Пример-с-асинхронным-dispose"><a class="header" href="#Пример-с-асинхронным-dispose">Пример с асинхронным dispose</a></h3>
<pre><code class="language-javascript">class AsyncLogger {
  #handle;
  #buffer = [];

  constructor(path) {
    this.#handle = fs.openSync(path, 'a');
    console.log(`AsyncLogger created`);
  }

  write(message) {
    this.#buffer.push(message);
  }

  // Асинхронный метод очистки
  async [Symbol.asyncDispose]() {
    console.log('Disposing logger (async)');

    // Шаг 1: Сбросить буфер в файл
    for (const msg of this.#buffer) {
      fs.writeSync(this.#handle, msg + '\n');
    }

    // Шаг 2: Закрыть файл
    fs.closeSync(this.#handle);

    // Шаг 3: Отправить уведомление (асинхронная операция)
    await this.sendNotification();

    console.log('Async disposal completed');
  }

  async sendNotification() {
    return new Promise(resolve =&gt; {
      setTimeout(() =&gt; {
        console.log('Notification sent');
        resolve();
      }, 100);
    });
  }
}

// Использование с await using
async function main() {
  await using logger = new AsyncLogger('./app.log');

  logger.write('Message 1');
  logger.write('Message 2');

  // При выходе ждем завершения logger[Symbol.asyncDispose]()
}

await main();
console.log('Auto dispose completed');
</code></pre>
<h3 id="Зачем-нужен-асинхронный-dispose"><a class="header" href="#Зачем-нужен-асинхронный-dispose">Зачем нужен асинхронный dispose?</a></h3>
<p>Асинхронный dispose позволяет:</p>
<ol>
<li><strong>Сбросить кэш</strong> в хранилище</li>
<li><strong>Отправить уведомления</strong> о закрытии ресурса</li>
<li><strong>Дождаться завершения</strong> фоновых операций</li>
<li><strong>Корректно закрыть</strong> сетевые соединения</li>
<li><strong>Запустить обработчики</strong> логов или метрик</li>
</ol>
<h3 id="Пример-со-сложной-асинхронной-логикой"><a class="header" href="#Пример-со-сложной-асинхронной-логикой">Пример со сложной асинхронной логикой</a></h3>
<pre><code class="language-javascript">class DatabaseConnection {
  #connection;

  async [Symbol.asyncDispose]() {
    console.log('Starting database cleanup...');

    // 1. Завершить активные транзакции
    await this.#connection.commitPendingTransactions();

    // 2. Сбросить кэш
    await this.#connection.flushCache();

    // 3. Закрыть соединение
    await this.#connection.close();

    // 4. Уведомить monitoring систему
    await this.notifyMonitoring('connection_closed');

    console.log('Database cleanup completed');
  }
}
</code></pre>
<hr />
<h2 id="Различия-между-синхронным-и-асинхронным-dispose"><a class="header" href="#Различия-между-синхронным-и-асинхронным-dispose">Различия между синхронным и асинхронным dispose</a></h2>
<h3 id="Таблица-приоритетов"><a class="header" href="#Таблица-приоритетов">Таблица приоритетов</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Конструкция</th><th>Есть Symbol.asyncDispose</th><th>Нет Symbol.asyncDispose</th></tr></thead><tbody>
<tr><td><code>await using</code></td><td>Вызывается <code>Symbol.asyncDispose</code></td><td>Вызывается <code>Symbol.dispose</code></td></tr>
<tr><td><code>using</code></td><td>Вызывается <code>Symbol.dispose</code></td><td>Вызывается <code>Symbol.dispose</code></td></tr>
</tbody></table>
</div>
<h3 id="Правила-выбора-метода-dispose"><a class="header" href="#Правила-выбора-метода-dispose">Правила выбора метода dispose</a></h3>
<p><strong>Правило 1</strong>: <code>await using</code> предпочитает асинхронный метод</p>
<pre><code class="language-javascript">class Resource {
  [Symbol.dispose]() {
    console.log('Sync dispose');
  }

  async [Symbol.asyncDispose]() {
    console.log('Async dispose');
  }
}

async function test() {
  await using r = new Resource();
} // Вызовется: Async dispose
</code></pre>
<p><strong>Правило 2</strong>: <code>using</code> всегда использует синхронный метод</p>
<pre><code class="language-javascript">async function test() {
  using r = new Resource(); // Даже если есть asyncDispose
} // Вызовется: Sync dispose
</code></pre>
<p><strong>Правило 3</strong>: Если нужного метода нет — ошибка</p>
<pre><code class="language-javascript">class NoDispose {
  // Нет ни Symbol.dispose, ни Symbol.asyncDispose
}

async function test() {
  await using r = new NoDispose();
  // TypeError: Cannot find Symbol.dispose method
}
</code></pre>
<h3 id="Пример-проверка-всех-комбинаций"><a class="header" href="#Пример-проверка-всех-комбинаций">Пример: проверка всех комбинаций</a></h3>
<pre><code class="language-javascript">// Пример 1: Оба метода определены, await using
class BothMethods {
  [Symbol.dispose]() {
    console.log('Sync dispose');
  }

  async [Symbol.asyncDispose]() {
    console.log('Async dispose');
  }
}

async function example1() {
  await using r = new BothMethods();
}
// Вывод: Async dispose

// Пример 2: Оба метода определены, using
function example2() {
  using r = new BothMethods();
}
// Вывод: Sync dispose

// Пример 3: Только sync dispose, await using
class OnlySync {
  [Symbol.dispose]() {
    console.log('Sync dispose');
  }
}

async function example3() {
  await using r = new OnlySync();
}
// Вывод: Sync dispose (откат к синхронному)

// Пример 4: Только async dispose, using
class OnlyAsync {
  async [Symbol.asyncDispose]() {
    console.log('Async dispose');
  }
}

function example4() {
  using r = new OnlyAsync();
  // ОШИБКА: не найден Symbol.dispose
}
</code></pre>
<hr />
<h2 id="Порядок-вызова-dispose"><a class="header" href="#Порядок-вызова-dispose">Порядок вызова dispose</a></h2>
<h3 id="Важная-особенность-синхронного-dispose-с-await-внутри"><a class="header" href="#Важная-особенность-синхронного-dispose-с-await-внутри">Важная особенность синхронного dispose с await внутри</a></h3>
<p>Если в синхронном <code>Symbol.dispose</code> используется <code>await</code>, выполнение разрывается!</p>
<h4 id="Пример-4-Разрыв-выполнения"><a class="header" href="#Пример-4-Разрыв-выполнения">Пример 4: Разрыв выполнения</a></h4>
<pre><code class="language-javascript">class Logger {
  [Symbol.dispose]() {
    console.log('Dispose: before await');

    await new Promise(resolve =&gt; setTimeout(resolve, 100));

    console.log('Dispose: after await');
  }
}

function main() {
  using logger = new Logger();
  console.log('Inside main');
}

main();
console.log('Auto dispose');
</code></pre>
<p><strong>Вывод:</strong></p>
<pre><code>Inside main
Dispose: before await
Auto dispose              &lt;-- Управление передалось сюда!
Dispose: after await      &lt;-- А это выполнится позже
</code></pre>
<p><strong>Объяснение</strong>: Синхронный dispose с <code>await</code> разрывается на две части. Управление передается дальше после первого <code>await</code>, не дожидаясь завершения dispose.</p>
<h4 id="Пример-5-Правильный-асинхронный-dispose"><a class="header" href="#Пример-5-Правильный-асинхронный-dispose">Пример 5: Правильный асинхронный dispose</a></h4>
<pre><code class="language-javascript">class Logger {
  async [Symbol.asyncDispose]() {
    console.log('Async dispose: before await');

    await new Promise(resolve =&gt; setTimeout(resolve, 100));

    console.log('Async dispose: after await');
  }
}

async function main() {
  await using logger = new Logger();
  console.log('Inside main');
}

await main();
console.log('Auto dispose');
</code></pre>
<p><strong>Вывод:</strong></p>
<pre><code>Inside main
Async dispose: before await
Async dispose: after await    &lt;-- Полностью выполнился
Auto dispose                   &lt;-- Только потом управление передалось
</code></pre>
<p><strong>Вывод</strong>: Используйте <code>Symbol.asyncDispose</code> с <code>await using</code>, если внутри dispose есть асинхронные операции!</p>
<hr />
<h2 id="Вложенные-контексты"><a class="header" href="#Вложенные-контексты">Вложенные контексты</a></h2>
<h3 id="Порядок-освобождения-lifo-last-in-first-out"><a class="header" href="#Порядок-освобождения-lifo-last-in-first-out">Порядок освобождения: LIFO (Last In, First Out)</a></h3>
<p>Ресурсы освобождаются в порядке стека — последний созданный освобождается первым.</p>
<h3 id="Пример-с-вложенными-блоками"><a class="header" href="#Пример-с-вложенными-блоками">Пример с вложенными блоками</a></h3>
<pre><code class="language-javascript">function createDisposable(id) {
  console.log(`Creating ${id}`);
  return {
    [Symbol.dispose]() {
      console.log(`Disposing ${id}`);
    }
  };
}

function nestedExample() {
  console.log('=== Start ===');

  using a = createDisposable('A');
  using b = createDisposable('B');

  {
    using c = createDisposable('C');
    using d = createDisposable('D');
    console.log('Inside inner block');
  } // &lt;-- D и C освобождаются здесь

  console.log('Back to outer block');

  using e = createDisposable('E');

  console.log('=== End ===');
} // &lt;-- E, B и A освобождаются здесь

nestedExample();
</code></pre>
<p><strong>Вывод:</strong></p>
<pre><code>=== Start ===
Creating A
Creating B
Creating C
Creating D
Inside inner block
Disposing D       &lt;-- Последний созданный в блоке
Disposing C       &lt;-- Первый созданный в блоке
Back to outer block
Creating E
=== End ===
Disposing E       &lt;-- Последний в функции
Disposing B       &lt;-- Второй в функции
Disposing A       &lt;-- Первый в функции
</code></pre>
<h3 id="Асинхронный-пример-с-вложенностью"><a class="header" href="#Асинхронный-пример-с-вложенностью">Асинхронный пример с вложенностью</a></h3>
<pre><code class="language-javascript">function loggy(id) {
  console.log(`Constructing ${id}`);
  return {
    async [Symbol.asyncDispose]() {
      console.log(`Disposing (async) ${id}`);
      await new Promise(resolve =&gt; setTimeout(resolve, 100));
    }
  };
}

async function func() {
  await using a = loggy('a');
  await using b = loggy('b');

  {
    await using c = loggy('c');
    await using d = loggy('d');
  } // c и d утилизируются здесь

  await using e = loggy('e');

  return;

  // Недостижимый код
  await using f = loggy('f'); // НЕ создастся, НЕ утилизируется
}

await func();
</code></pre>
<p><strong>Вывод:</strong></p>
<pre><code>Constructing a
Constructing b
Constructing c
Constructing d
Disposing (async) d
Disposing (async) c
Constructing e
Disposing (async) e
Disposing (async) b
Disposing (async) a
</code></pre>
<h3 id="Визуализация-порядка"><a class="header" href="#Визуализация-порядка">Визуализация порядка</a></h3>
<pre><code>Функция func():
┌─────────────────────────────────────┐
│ await using a                       │ ← Создан первым
│ await using b                       │ ← Создан вторым
│                                     │
│ ┌─────────────────────────────┐    │
│ │ Вложенный блок:             │    │
│ │ await using c               │    │ ← Создан третьим
│ │ await using d               │    │ ← Создан четвертым
│ │                             │    │
│ └─────────────────────────────┘    │
│   ↑ Dispose d (4)                   │
│   ↑ Dispose c (3)                   │
│                                     │
│ await using e                       │ ← Создан пятым
│                                     │
└─────────────────────────────────────┘
  ↑ Dispose e (5)
  ↑ Dispose b (2)
  ↑ Dispose a (1)
</code></pre>
<h3 id="Перекрытие-идентификаторов-shadowing"><a class="header" href="#Перекрытие-идентификаторов-shadowing">Перекрытие идентификаторов (shadowing)</a></h3>
<pre><code class="language-javascript">function shadowingExample() {
  using console = createDisposable('outer console');

  {
    using console = createDisposable('inner console');
    // Здесь доступен inner console
  } // inner console освобождается

  // Здесь снова доступен outer console
} // outer console освобождается
</code></pre>
<hr />
<h2 id="Практические-сценарии-использования"><a class="header" href="#Практические-сценарии-использования">Практические сценарии использования</a></h2>
<h3 id="Сценарий-1-Работа-с-файлами"><a class="header" href="#Сценарий-1-Работа-с-файлами">Сценарий 1: Работа с файлами</a></h3>
<pre><code class="language-javascript">class TempFile {
  #path;
  #handle;

  constructor(path) {
    this.#path = path;
    this.#handle = fs.openSync(path, 'w+');
    console.log(`Opened temp file: ${path}`);
  }

  write(data) {
    fs.writeSync(this.#handle, data);
  }

  read() {
    const stats = fs.fstatSync(this.#handle);
    const buffer = Buffer.alloc(stats.size);
    fs.readSync(this.#handle, buffer, 0, stats.size, 0);
    return buffer.toString();
  }

  [Symbol.dispose]() {
    fs.closeSync(this.#handle);
    fs.unlinkSync(this.#path);
    console.log(`Deleted temp file: ${this.#path}`);
  }
}

function processTempData() {
  using tempFile = new TempFile('./temp_data.tmp');

  tempFile.write('Important data');
  const content = tempFile.read();
  console.log('Content:', content);

  // Файл автоматически удалится при выходе
}
</code></pre>
<h3 id="Сценарий-2-Трассировка-выполнения"><a class="header" href="#Сценарий-2-Трассировка-выполнения">Сценарий 2: Трассировка выполнения</a></h3>
<pre><code class="language-javascript">class TraceActivity {
  #name;
  #startTime;

  constructor(name) {
    this.#name = name;
    this.#startTime = Date.now();
    console.log(`→ Entering: ${name}`);
  }

  [Symbol.dispose]() {
    const duration = Date.now() - this.#startTime;
    console.log(`← Exiting: ${this.#name} (${duration}ms)`);
  }
}

function businessLogic() {
  using _trace = new TraceActivity('businessLogic');

  // Бизнес-логика
  for (let i = 0; i &lt; 1000000; i++) {
    Math.sqrt(i);
  }
}

businessLogic();
// Вывод:
// → Entering: businessLogic
// ← Exiting: businessLogic (15ms)
</code></pre>
<h3 id="Сценарий-3-Управление-транзакциями"><a class="header" href="#Сценарий-3-Управление-транзакциями">Сценарий 3: Управление транзакциями</a></h3>
<pre><code class="language-javascript">class Transaction {
  #db;
  #committed = false;

  constructor(db) {
    this.#db = db;
    this.#db.begin();
    console.log('Transaction started');
  }

  commit() {
    this.#db.commit();
    this.#committed = true;
    console.log('Transaction committed');
  }

  [Symbol.dispose]() {
    if (!this.#committed) {
      this.#db.rollback();
      console.log('Transaction rolled back');
    }
  }
}

function updateDatabase(db) {
  using transaction = new Transaction(db);

  db.update('users', { name: 'John' });
  db.update('orders', { status: 'completed' });

  // Если ошибка — автоматический rollback
  if (someCondition()) {
    transaction.commit();
  }
  // Иначе — rollback при выходе
}
</code></pre>
<h3 id="Сценарий-4-Блокировки-и-мьютексы"><a class="header" href="#Сценарий-4-Блокировки-и-мьютексы">Сценарий 4: Блокировки и мьютексы</a></h3>
<pre><code class="language-javascript">class Lock {
  #resource;

  constructor(resource) {
    this.#resource = resource;
    resource.acquire();
    console.log('Lock acquired');
  }

  [Symbol.dispose]() {
    this.#resource.release();
    console.log('Lock released');
  }
}

function criticalSection(resource) {
  using lock = new Lock(resource);

  // Критическая секция — только один поток может быть здесь
  modifySharedData();

  // Блокировка автоматически освободится
}
</code></pre>
<hr />
<h2 id="reference-counting-предварительно"><a class="header" href="#reference-counting-предварительно">Reference Counting (предварительно)</a></h2>
<p>Лектор упоминает, что <code>using</code> <strong>не реализует автоматический подсчет ссылок</strong> (reference counting), как в некоторых других языках.</p>
<h3 id="Что-это-значит"><a class="header" href="#Что-это-значит">Что это значит?</a></h3>
<pre><code class="language-javascript">let externalRef;

function example() {
  using resource = createResource();
  externalRef = resource; // Создали дополнительную ссылку

} // resource.dispose() вызовется, даже если externalRef еще жива!

// externalRef теперь указывает на "мертвый" объект
</code></pre>
<p><strong>Планы</strong>: Лектор обещает отдельную лекцию о том, как реализовать reference counting поверх <code>using</code>.</p>
<hr />
<h2 id="Совместимость-и-полифиллы"><a class="header" href="#Совместимость-и-полифиллы">Совместимость и полифиллы</a></h2>
<h3 id="Проверка-поддержки"><a class="header" href="#Проверка-поддержки">Проверка поддержки</a></h3>
<pre><code class="language-javascript">// Проверка наличия Symbol.dispose
if (typeof Symbol.dispose === 'undefined') {
  // Полифилл
  Symbol.dispose = Symbol('Symbol.dispose');
}

if (typeof Symbol.asyncDispose === 'undefined') {
  Symbol.asyncDispose = Symbol('Symbol.asyncDispose');
}
</code></pre>
<h3 id="Полифилл-от-typescript"><a class="header" href="#Полифилл-от-typescript">Полифилл от TypeScript</a></h3>
<p>TypeScript предоставляет полифиллы для окружений без нативной поддержки:</p>
<pre><code class="language-typescript">Symbol.dispose ??= Symbol("Symbol.dispose");
Symbol.asyncDispose ??= Symbol("Symbol.asyncDispose");
</code></pre>
<h3 id="Поддержка-в-рантаймах"><a class="header" href="#Поддержка-в-рантаймах">Поддержка в рантаймах</a></h3>
<p>На момент записи лекции (упоминается в конце):</p>
<ul>
<li><strong>Node.js 24</strong>: Полная поддержка ✅</li>
<li><strong>Chrome/Chromium</strong>: Полная поддержка ✅</li>
<li><strong>TypeScript 5.2+</strong>: Полная поддержка ✅</li>
</ul>
<hr />
<h2 id="Обработка-ошибок"><a class="header" href="#Обработка-ошибок">Обработка ошибок</a></h2>
<h3 id="suppressederror"><a class="header" href="#suppressederror">SuppressedError</a></h3>
<p>Если ошибка происходит и в основном коде, и в <code>dispose</code>, создается специальный <code>SuppressedError</code>:</p>
<pre><code class="language-javascript">class ErrorThrower {
  [Symbol.dispose]() {
    throw new Error('Error in dispose');
  }
}

function test() {
  using resource = new ErrorThrower();
  throw new Error('Error in main code');
}

try {
  test();
} catch (e) {
  console.log(e.name);              // SuppressedError
  console.log(e.message);           // An error was suppressed during disposal
  console.log(e.error.message);     // Error in dispose
  console.log(e.suppressed.message); // Error in main code
}
</code></pre>
<h3 id="Множественные-ошибки-dispose"><a class="header" href="#Множественные-ошибки-dispose">Множественные ошибки dispose</a></h3>
<pre><code class="language-javascript">function multipleErrors() {
  using a = { [Symbol.dispose]() { throw new Error('A failed'); } };
  using b = { [Symbol.dispose]() { throw new Error('B failed'); } };
}

try {
  multipleErrors();
} catch (e) {
  // Обе ошибки будут собраны в цепочку SuppressedError
}
</code></pre>
<hr />
<h2 id="Использование-в-циклах"><a class="header" href="#Использование-в-циклах">Использование в циклах</a></h2>
<h3 id="for-loop"><a class="header" href="#for-loop">For loop</a></h3>
<pre><code class="language-javascript">function processFiles(files) {
  for (using file = openFile(files[0]); file.hasNext(); file.next()) {
    console.log(file.read());
  } // file закрывается после цикла
}
</code></pre>
<h3 id="forof-loop"><a class="header" href="#forof-loop">For...of loop</a></h3>
<pre><code class="language-javascript">function* createResources() {
  yield new Resource('A');
  yield new Resource('B');
  yield new Resource('C');
}

function processResources() {
  for (using resource of createResources()) {
    console.log(resource.use());
    // Каждый resource автоматически освобождается после итерации
  }
}
</code></pre>
<hr />
<h2 id="Резюме"><a class="header" href="#Резюме">Резюме</a></h2>
<h3 id="Основные-концепции"><a class="header" href="#Основные-концепции">Основные концепции</a></h3>
<ol>
<li>
<p><strong><code>using</code> объявление</strong></p>
<ul>
<li>Автоматически вызывает <code>Symbol.dispose</code> при выходе из блока</li>
<li>Работает синхронно</li>
<li>Гарантирует освобождение ресурса даже при ошибках</li>
</ul>
</li>
<li>
<p><strong><code>await using</code> объявление</strong></p>
<ul>
<li>Автоматически вызывает <code>Symbol.asyncDispose</code> при выходе из блока</li>
<li>Ожидает завершения асинхронной очистки</li>
<li>Откатывается к <code>Symbol.dispose</code>, если асинхронного метода нет</li>
</ul>
</li>
<li>
<p><strong>Порядок освобождения</strong></p>
<ul>
<li>LIFO (Last In, First Out) — стековый порядок</li>
<li>Вложенные контексты освобождаются корректно</li>
</ul>
</li>
<li>
<p><strong>Отличия от других подходов</strong></p>
<ul>
<li><strong>vs try/finally</strong>: Меньше кода, автоматическая очистка</li>
<li><strong>vs FinalizationRegistry</strong>: Детерминированное время освобождения</li>
<li><strong>vs GC</strong>: Явный контроль, не зависит от сборщика мусора</li>
</ul>
</li>
</ol>
<h3 id="Когда-использовать"><a class="header" href="#Когда-использовать">Когда использовать</a></h3>
<p>✅ <strong>Используйте <code>using</code>:</strong></p>
<ul>
<li>Файловые дескрипторы</li>
<li>Сетевые соединения</li>
<li>Блокировки и мьютексы</li>
<li>Временные ресурсы</li>
<li>Трассировка и профилирование</li>
</ul>
<p>✅ <strong>Используйте <code>await using</code>:</strong></p>
<ul>
<li>Когда нужно дождаться асинхронной очистки</li>
<li>Сброс кэша в БД</li>
<li>Отправка метрик</li>
<li>Корректное закрытие соединений</li>
</ul>
<p>❌ <strong>Не используйте для:</strong></p>
<ul>
<li>Обычных объектов без внешних ресурсов</li>
<li>Объектов, управляемых GC</li>
<li>Ситуаций, где нужен reference counting (требует доп. обертки)</li>
</ul>
<h3 id="Преимущества"><a class="header" href="#Преимущества">Преимущества</a></h3>
<ul>
<li><strong>Читаемость</strong>: Меньше boilerplate кода</li>
<li><strong>Надежность</strong>: Автоматическая очистка даже при ошибках</li>
<li><strong>Предсказуемость</strong>: Детерминированное время освобождения</li>
<li><strong>Композируемость</strong>: Легко работать с множественными ресурсами</li>
</ul>
<h3 id="Ограничения"><a class="header" href="#Ограничения">Ограничения</a></h3>
<ul>
<li>Нет автоматического reference counting</li>
<li>Требует явной реализации <code>Symbol.dispose</code> / <code>Symbol.asyncDispose</code></li>
<li>Относительно новая возможность (Node.js 24+, современные браузеры)</li>
</ul>
<h3 id="Дальнейшее-изучение"><a class="header" href="#Дальнейшее-изучение">Дальнейшее изучение</a></h3>
<p>Лектор обещает следующие темы:</p>
<ol>
<li><strong>Reference Counting</strong> — реализация подсчета ссылок поверх <code>using</code></li>
<li><strong>Расширенные паттерны</strong> — сложные сценарии использования</li>
<li><strong>Интеграция с фреймворками</strong> — примеры из реальных проектов</li>
</ol>
<hr />
<h2 id="Полезные-ссылки"><a class="header" href="#Полезные-ссылки">Полезные ссылки</a></h2>
<h3 id="Документация"><a class="header" href="#Документация">Документация</a></h3>
<ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html">TypeScript 5.2 Release Notes - using</a></li>
<li><a href="https://github.com/tc39/proposal-explicit-resource-management">ECMAScript Explicit Resource Management Proposal</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry">MDN: FinalizationRegistry</a></li>
</ul>
<h3 id="Флаги-для-запуска-примеров"><a class="header" href="#Флаги-для-запуска-примеров">Флаги для запуска примеров</a></h3>
<pre><code class="language-bash"># Включить ручной вызов Garbage Collection
node --expose-gc script.js

# Проверить версию Node.js
node --version  # Должна быть 24+
</code></pre>
<h3 id="Типы-typescript"><a class="header" href="#Типы-typescript">Типы TypeScript</a></h3>
<pre><code class="language-typescript">interface Disposable {
  [Symbol.dispose](): void;
}

interface AsyncDisposable {
  [Symbol.asyncDispose](): void | Promise&lt;void&gt;;
}
</code></pre>
<hr />
<h2 id="Практические-задания"><a class="header" href="#Практические-задания">Практические задания</a></h2>
<h3 id="Задание-1-Базовое-использование"><a class="header" href="#Задание-1-Базовое-использование">Задание 1: Базовое использование</a></h3>
<p>Создайте класс <code>DatabaseConnection</code> с методом <code>Symbol.dispose</code>, который логирует закрытие соединения.</p>
<h3 id="Задание-2-Асинхронная-очистка"><a class="header" href="#Задание-2-Асинхронная-очистка">Задание 2: Асинхронная очистка</a></h3>
<p>Реализуйте класс <code>CachedLogger</code>, который при dispose:</p>
<ol>
<li>Сбрасывает буфер в файл</li>
<li>Закрывает файл</li>
<li>Отправляет метрики (асинхронно)</li>
</ol>
<h3 id="Задание-3-Вложенные-контексты"><a class="header" href="#Задание-3-Вложенные-контексты">Задание 3: Вложенные контексты</a></h3>
<p>Напишите функцию с вложенными <code>using</code> блоками и проверьте порядок освобождения.</p>
<h3 id="Задание-4-Обработка-ошибок"><a class="header" href="#Задание-4-Обработка-ошибок">Задание 4: Обработка ошибок</a></h3>
<p>Создайте класс, который выбрасывает ошибку в <code>dispose</code>, и обработайте <code>SuppressedError</code>.</p>
<hr />
<h2 id="Заключение"><a class="header" href="#Заключение">Заключение</a></h2>
<p>Механизм явного управления ресурсами через <code>using</code> и <code>Symbol.dispose</code> — это мощное дополнение к JavaScript/TypeScript, которое:</p>
<ul>
<li>Делает код чище и безопаснее</li>
<li>Гарантирует освобождение ресурсов</li>
<li>Упрощает работу со сложными сценариями</li>
<li>Приближает JavaScript к языкам с RAII (Resource Acquisition Is Initialization)</li>
</ul>
<p>Начинайте использовать эту возможность в новых проектах уже сейчас!</p>
<hr />
<p><strong>Дата создания конспекта</strong>: 2025-12-09
<strong>Версия Node.js</strong>: 24+
<strong>Версия TypeScript</strong>: 5.2+</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../week2/promise-contract-lecture-notes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../week2/reference-counter-using-disposable.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../week2/promise-contract-lecture-notes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../week2/reference-counter-using-disposable.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
