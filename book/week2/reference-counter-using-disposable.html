<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Reference counting with using &amp; Disposable - Patterns</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Patterns</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Подсчет-ссылок-на-ресурс-при-помощи-using-и-disposable-в-javascript"><a class="header" href="#Подсчет-ссылок-на-ресурс-при-помощи-using-и-disposable-в-javascript">Подсчет ссылок на ресурс при помощи Using и Disposable в JavaScript</a></h1>
<h2 id="Обзор"><a class="header" href="#Обзор">Обзор</a></h2>
<p>Данная лекция посвящена реализации паттерна Reference Counter (счетчик ссылок) с использованием новых возможностей JavaScript — <code>using</code> и <code>disposable</code>. Эти механизмы появились недавно (Node.js v24, современные версии Chrome) и позволяют управлять жизненным циклом ресурсов более явно и безопасно, чем традиционные подходы.</p>
<p><strong>Основные темы:</strong></p>
<ul>
<li>Explicit Resource Management (явное управление ресурсами)</li>
<li>Реализация Reference Counter на базе <code>using</code> и <code>disposable</code></li>
<li>Автоматическое освобождение ресурсов при выходе из блока</li>
<li>Сравнение с подходом на базе Finalization Registry</li>
<li>Практические примеры с файловыми дескрипторами и логированием</li>
</ul>
<hr />
<h2 id="Введение-в-explicit-resource-management"><a class="header" href="#Введение-в-explicit-resource-management">Введение в Explicit Resource Management</a></h2>
<h3 id="Что-такое-explicit-resource-management"><a class="header" href="#Что-такое-explicit-resource-management">Что такое Explicit Resource Management?</a></h3>
<p><strong>Explicit Resource Management</strong> — это паттерн явного управления ресурсами, который позволяет гарантировать освобождение ресурсов (файлы, соединения, память) при выходе из области видимости.</p>
<h3 id="Ключевые-концепции"><a class="header" href="#Ключевые-концепции">Ключевые концепции</a></h3>
<p><strong><code>using</code> declaration</strong> — специальное объявление переменной, которое автоматически вызывает метод <code>Symbol.dispose</code> при выходе из блока.</p>
<p><strong><code>Symbol.dispose</code></strong> — специальный символ, определяющий метод очистки ресурса.</p>
<p><strong>Disposable объект</strong> — объект, имеющий метод <code>[Symbol.dispose]()</code>, который вызывается автоматически.</p>
<h4 id="Базовый-пример-использования"><a class="header" href="#Базовый-пример-использования">Базовый пример использования</a></h4>
<pre><code class="language-javascript">// Объект с методом dispose
const resource = {
  value: 'some data',
  [Symbol.dispose]() {
    console.log('Resource disposed');
    // Здесь происходит очистка ресурса
  }
};

// Использование using
{
  using myResource = resource;
  console.log(myResource.value); // 'some data'
  // При выходе из блока автоматически вызовется resource[Symbol.dispose]()
}
// Вывод: 'Resource disposed'
</code></pre>
<p><strong>Преимущества:</strong></p>
<ul>
<li>Автоматическое освобождение ресурсов</li>
<li>Защита от утечек памяти</li>
<li>Работает даже при выбросе исключений</li>
<li>Более короткий и понятный синтаксис по сравнению с <code>try...finally</code></li>
</ul>
<hr />
<h2 id="reference-counter-Базовая-реализация"><a class="header" href="#reference-counter-Базовая-реализация">Reference Counter: Базовая реализация</a></h2>
<h3 id="Концепция-reference-counter"><a class="header" href="#Концепция-reference-counter">Концепция Reference Counter</a></h3>
<p><strong>Reference Counter (счетчик ссылок)</strong> — паттерн, который отслеживает количество активных ссылок на ресурс и автоматически освобождает ресурс, когда счетчик достигает нуля.</p>
<h3 id="Структура-reference-counter"><a class="header" href="#Структура-reference-counter">Структура Reference Counter</a></h3>
<pre><code class="language-javascript">class ReferenceCounter {
  #resource = null;      // Сам ресурс (например, консоль)
  #context = null;       // Контекст с данными для финализации
  #counter = 0;          // Счетчик активных ссылок
  #create = null;        // Функция создания ресурса
  #dispose = null;       // Функция освобождения ресурса

  constructor(create, dispose) {
    this.#create = create;
    this.#dispose = dispose;
  }

  // Методы будут рассмотрены ниже
}
</code></pre>
<p><strong>Поля класса:</strong></p>
<ul>
<li><code>#resource</code> — хранит созданный экземпляр ресурса</li>
<li><code>#context</code> — контекст с дополнительными данными (например, файловый дескриптор)</li>
<li><code>#counter</code> — текущее количество активных ссылок</li>
<li><code>#create</code> — функция-фабрика для создания ресурса</li>
<li><code>#dispose</code> — функция для освобождения ресурса</li>
</ul>
<hr />
<h2 id="Пример-7-Простой-reference-counter-для-логера"><a class="header" href="#Пример-7-Простой-reference-counter-для-логера">Пример 7: Простой Reference Counter для логера</a></h2>
<h3 id="Постановка-задачи"><a class="header" href="#Постановка-задачи">Постановка задачи</a></h3>
<p>Создать логер, который:</p>
<ol>
<li>Записывает данные в файл</li>
<li>Автоматически открывает файл при первом использовании</li>
<li>Автоматически закрывает файл, когда все блоки завершены</li>
<li>Использует Reference Counter для отслеживания активных использований</li>
</ol>
<h3 id="Реализация-создания-логера"><a class="header" href="#Реализация-создания-логера">Реализация создания логера</a></h3>
<pre><code class="language-javascript">import { open } from 'node:fs';
import { Console } from 'node:console';

// Функция создания экземпляра логера
const createLogger = () =&gt; {
  // Открываем файл для записи
  const fd = open('output.log', 'w');

  // Создаем поток для записи
  const stream = fs.createWriteStream(null, { fd });

  // Создаем консоль, которая пишет в поток
  const console = new Console(stream);

  // Возвращаем ресурс и контекст
  return {
    resource: console,    // Сама консоль для использования
    context: { fd }       // Файловый дескриптор для закрытия
  };
};

// Функция финализации (освобождения) логера
const disposeLogger = (context) =&gt; {
  // Закрываем файловый дескриптор из контекста
  context.fd.close();
};

// Создаем Reference Counter для логера
const logger = new ReferenceCounter(createLogger, disposeLogger);
</code></pre>
<p><strong>Важные моменты:</strong></p>
<ul>
<li>Функция <code>createLogger</code> возвращает объект с двумя полями: <code>resource</code> и <code>context</code></li>
<li><code>resource</code> — это то, что будет использоваться в коде (консоль)</li>
<li><code>context</code> — это данные для финализации (файловый дескриптор)</li>
<li>Reference Counter универсален — он не привязан к конкретному типу ресурса</li>
</ul>
<h3 id="Метод-use--создание-disposable"><a class="header" href="#Метод-use--создание-disposable">Метод use() — создание Disposable</a></h3>
<pre><code class="language-javascript">class ReferenceCounter {
  // ... предыдущий код ...

  use() {
    // Увеличиваем счетчик ссылок
    this.#counter++;

    // Берем ресурс (консоль)
    const resource = this.#resource;

    // Создаем новый объект, наследующий от ресурса
    const disposable = Object.create(resource);

    // Добавляем метод dispose
    disposable[Symbol.dispose] = () =&gt; {
      // Уменьшаем счетчик при выходе из блока
      this.#counter--;

      // Если счетчик достиг нуля
      if (this.#counter === 0) {
        // Вызываем функцию освобождения ресурса
        this.#dispose(this.#context);

        // Очищаем ссылки
        this.#resource = null;
        this.#context = null;
      }
    };

    // Возвращаем disposable объект
    return disposable;
  }
}
</code></pre>
<p><strong>Механизм работы <code>use()</code>:</strong></p>
<ol>
<li><strong>Инкремент счетчика:</strong> при каждом вызове <code>use()</code> увеличивается <code>#counter</code></li>
<li><strong>Создание disposable:</strong> создается новый объект с прототипной ссылкой на ресурс</li>
<li><strong>Добавление <code>Symbol.dispose</code>:</strong> в объект добавляется метод для автоматической очистки</li>
<li><strong>Декремент при dispose:</strong> когда блок <code>using</code> завершается, счетчик уменьшается</li>
<li><strong>Финализация при нуле:</strong> когда счетчик достигает 0, вызывается функция освобождения</li>
</ol>
<h3 id="Использование-в-коде"><a class="header" href="#Использование-в-коде">Использование в коде</a></h3>
<pre><code class="language-javascript">async function main() {
  // Блок 0: первое использование логера
  {
    using console0 = logger.use();
    console0.log('log 0');

    // Блок 1: вложенное использование
    {
      using console1 = logger.use();
      console1.log('log 1');

      // Блок 2: еще более вложенное использование
      {
        using console2 = logger.use();
        console2.log('log 2');

        // Сохраняем ссылку для использования вне блока
        rf3 = console2;
      } // dispose для console2 - счетчик: 3 -&gt; 2
    } // dispose для console1 - счетчик: 2 -&gt; 1
  } // dispose для console0 - счетчик: 1 -&gt; 0, вызов disposeLogger

  // Блок 3: попытка использовать утекшую ссылку
  {
    using rf4 = rf3; // Это та же ссылка, но ресурс уже освобожден
    rf4.log('log 3'); // Запись НЕ произойдет - файл закрыт!
  }
}

const rf4 = await main();
console.log('After main');
rf4.log('log 4'); // Тоже НЕ запишется - ресурс освобожден
</code></pre>
<p><strong>Пошаговая трассировка:</strong></p>
<pre><code>1. Открытие файла:
   - createLogger вызван
   - fd открыт, stream создан, console создан
   - counter = 0

2. Вход в блок 0:
   - use() вызван
   - counter = 1
   - console0.log('log 0') → запись в файл ✓

3. Вход в блок 1:
   - use() вызван
   - counter = 2
   - console1.log('log 1') → запись в файл ✓

4. Вход в блок 2:
   - use() вызван
   - counter = 3
   - console2.log('log 2') → запись в файл ✓
   - rf3 = console2 (сохранение ссылки)

5. Выход из блока 2:
   - Symbol.dispose вызван для console2
   - counter = 2

6. Выход из блока 1:
   - Symbol.dispose вызван для console1
   - counter = 1

7. Выход из блока 0:
   - Symbol.dispose вызван для console0
   - counter = 0
   - disposeLogger вызван
   - fd.close() - ФАЙЛ ЗАКРЫТ
   - resource = null, context = null

8. Использование rf3/rf4:
   - Ссылка существует, но ресурс уже освобожден
   - Попытки записи не дадут результата
</code></pre>
<h3 id="Результат-выполнения"><a class="header" href="#Результат-выполнения">Результат выполнения</a></h3>
<p><strong>Вывод в консоль:</strong></p>
<pre><code>open
use (counter: 1)
dispose (counter: 0)
use (counter: 1)
use (counter: 2)
dispose (counter: 1)
dispose (counter: 0)
close
After main
</code></pre>
<p><strong>Содержимое output.log:</strong></p>
<pre><code>log 0
log 1
log 2
</code></pre>
<p><strong>Что НЕ записалось:</strong></p>
<ul>
<li><code>log 3</code> — ресурс уже освобожден</li>
<li><code>log 4</code> — ресурс уже освобожден</li>
</ul>
<hr />
<h2 id="Пример-8-reference-counter-с-коллекцией-файлов"><a class="header" href="#Пример-8-reference-counter-с-коллекцией-файлов">Пример 8: Reference Counter с коллекцией файлов</a></h2>
<h3 id="Постановка-задачи-1"><a class="header" href="#Постановка-задачи-1">Постановка задачи</a></h3>
<p>Создать логер, который может работать с <strong>несколькими файлами одновременно</strong>, где:</p>
<ul>
<li>Для каждого файла ведется свой счетчик ссылок</li>
<li>Файл открывается только один раз при первом обращении</li>
<li>Файл закрывается, когда его счетчик достигает нуля</li>
<li>Разные блоки могут писать в разные файлы</li>
</ul>
<h3 id="Структура-данных-для-коллекции-файлов"><a class="header" href="#Структура-данных-для-коллекции-файлов">Структура данных для коллекции файлов</a></h3>
<pre><code class="language-javascript">class MultiFileLogger {
  // Коллекция открытых файлов
  // Ключ: имя файла (строка)
  // Значение: объект с полями { counter, fd, console }
  #files = new Map();

  constructor() {
    // Инициализация пустой коллекции
  }
}
</code></pre>
<p><strong>Структура записи в коллекции:</strong></p>
<pre><code class="language-javascript">{
  'output.log': {
    counter: 2,           // Количество активных использований
    fd: &lt;FileDescriptor&gt;, // Файловый дескриптор
    console: &lt;Console&gt;    // Экземпляр консоли для записи
  },
  'output3.log': {
    counter: 1,
    fd: &lt;FileDescriptor&gt;,
    console: &lt;Console&gt;
  }
}
</code></pre>
<h3 id="Метод-open--открытие-файла"><a class="header" href="#Метод-open--открытие-файла">Метод open() — открытие файла</a></h3>
<pre><code class="language-javascript">class MultiFileLogger {
  #files = new Map();

  open(fileName) {
    // Открываем файл для записи
    const fd = fs.openSync(fileName, 'w');

    // Создаем поток записи
    const stream = fs.createWriteStream(null, { fd });

    // Создаем консоль для этого потока
    const console = new Console(stream);

    // Возвращаем структуру для сохранения в коллекцию
    return {
      counter: 0,  // Начальное значение счетчика
      fd,          // Файловый дескриптор
      console      // Консоль для записи
    };
  }
}
</code></pre>
<h3 id="Метод-use--получение-disposable-для-файла"><a class="header" href="#Метод-use--получение-disposable-для-файла">Метод use() — получение disposable для файла</a></h3>
<pre><code class="language-javascript">class MultiFileLogger {
  #files = new Map();

  use(fileName) {
    // Пытаемся найти файл в коллекции
    let instance = this.#files.get(fileName);

    // Если файл еще не открыт
    if (!instance) {
      // Открываем файл и получаем структуру
      instance = this.open(fileName);

      // Сохраняем в коллекцию
      this.#files.set(fileName, instance);
    }

    // Увеличиваем счетчик для этого файла
    instance.counter++;

    // Создаем disposable объект на базе консоли
    const disposable = Object.create(instance.console);

    // Добавляем метод dispose
    disposable[Symbol.dispose] = () =&gt; {
      // Уменьшаем счетчик
      instance.counter--;

      // Если счетчик достиг нуля
      if (instance.counter === 0) {
        // Закрываем файл
        instance.fd.close();

        // Удаляем из коллекции
        this.#files.delete(fileName);
      }
    };

    // Возвращаем disposable
    return disposable;
  }
}

// Создаем экземпляр логера
const logger = new MultiFileLogger();
</code></pre>
<p><strong>Логика работы <code>use(fileName)</code>:</strong></p>
<ol>
<li><strong>Поиск в коллекции:</strong> проверяем, открыт ли уже этот файл</li>
<li><strong>Ленивое открытие:</strong> если файла нет, открываем его и добавляем в коллекцию</li>
<li><strong>Инкремент счетчика:</strong> увеличиваем счетчик для данного файла</li>
<li><strong>Создание disposable:</strong> создаем объект с методом <code>Symbol.dispose</code></li>
<li><strong>Закрытие при нуле:</strong> когда счетчик файла становится 0, файл закрывается и удаляется из коллекции</li>
</ol>
<h3 id="Использование-с-несколькими-файлами"><a class="header" href="#Использование-с-несколькими-файлами">Использование с несколькими файлами</a></h3>
<pre><code class="language-javascript">async function main() {
  // Блок 0: работа с output.log
  {
    using c0 = logger.use('output.log');
    c0.log('log 0');  // Файл открывается, counter = 1

    // Блок 1: вложенное использование того же файла
    {
      using c1 = logger.use('output.log');
      c1.log('log 1');  // Файл уже открыт, counter = 2

      // Блок 2: еще более вложенное использование
      {
        using c2 = logger.use('output.log');
        c2.log('log 2');  // counter = 3

        // Блок 3: работа с ДРУГИМ файлом
        {
          using c3 = logger.use('output3.log');
          c3.log('log 3');  // Новый файл открывается, его counter = 1
        } // dispose c3: output3.log counter = 0, файл закрывается

        // Сохраняем ссылку для демонстрации утечки
        rf = c2;
      } // dispose c2: output.log counter = 2
    } // dispose c1: output.log counter = 1
  } // dispose c0: output.log counter = 0, файл закрывается

  // Возвращаем утекшую ссылку
  return rf;
}

// Блок 4: использование утекшей ссылки
{
  const f1 = await main();
  using c4 = f1;
  c4.log('log 4');  // НЕ запишется - файл уже закрыт!
}

// Блок 5: попытка использовать после завершения блока 4
{
  using c5 = f1;
  c5.log('log 5');  // НЕ запишется - файл закрыт!
}
</code></pre>
<h3 id="Пошаговая-трассировка-выполнения"><a class="header" href="#Пошаговая-трассировка-выполнения">Пошаговая трассировка выполнения</a></h3>
<pre><code>=== Начало выполнения ===

1. Вход в блок 0:
   logger.use('output.log')
   - Файл не найден в коллекции
   - open('output.log') вызван
   - files.set('output.log', { counter: 0, fd, console })
   - counter для output.log = 1
   - c0.log('log 0') → запись в output.log ✓

2. Вход в блок 1:
   logger.use('output.log')
   - Файл найден в коллекции
   - counter для output.log = 2
   - c1.log('log 1') → запись в output.log ✓

3. Вход в блок 2:
   logger.use('output.log')
   - Файл найден в коллекции
   - counter для output.log = 3
   - c2.log('log 2') → запись в output.log ✓
   - rf = c2 (сохранение ссылки)

4. Вход в блок 3:
   logger.use('output3.log')
   - Файл не найден в коллекции
   - open('output3.log') вызван
   - files.set('output3.log', { counter: 0, fd, console })
   - counter для output3.log = 1
   - c3.log('log 3') → запись в output3.log ✓

5. Выход из блока 3:
   - Symbol.dispose для c3
   - counter для output3.log = 0
   - fd.close() для output3.log
   - files.delete('output3.log')
   - output3.log ЗАКРЫТ ✓

6. Выход из блока 2:
   - Symbol.dispose для c2
   - counter для output.log = 2

7. Выход из блока 1:
   - Symbol.dispose для c1
   - counter для output.log = 1

8. Выход из блока 0:
   - Symbol.dispose для c0
   - counter для output.log = 0
   - fd.close() для output.log
   - files.delete('output.log')
   - output.log ЗАКРЫТ ✓

9. Использование в блоке 4:
   - f1 = rf (утекшая ссылка)
   - c4.log('log 4') → НЕ запишется (файл закрыт) ✗

10. Использование в блоке 5:
    - c5.log('log 5') → НЕ запишется (файл закрыт) ✗
</code></pre>
<h3 id="Результаты-выполнения"><a class="header" href="#Результаты-выполнения">Результаты выполнения</a></h3>
<p><strong>Вывод в консоль:</strong></p>
<pre><code>open output.log
use output.log (counter: 1)
use output.log (counter: 2)
use output.log (counter: 3)
open output3.log
use output3.log (counter: 1)
dispose output3.log (counter: 0)
close output3.log
dispose output.log (counter: 2)
dispose output.log (counter: 1)
dispose output.log (counter: 0)
close output.log
After main
</code></pre>
<p><strong>Содержимое output.log:</strong></p>
<pre><code>log 0
log 1
log 2
</code></pre>
<p><strong>Содержимое output3.log:</strong></p>
<pre><code>log 3
</code></pre>
<p><strong>Что НЕ записалось:</strong></p>
<ul>
<li><code>log 4</code> — output.log уже закрыт</li>
<li><code>log 5</code> — output.log уже закрыт</li>
</ul>
<hr />
<h2 id="Сравнение-подходов-finalization-registry-vs-usingdisposable"><a class="header" href="#Сравнение-подходов-finalization-registry-vs-usingdisposable">Сравнение подходов: Finalization Registry vs Using/Disposable</a></h2>
<h3 id="finalization-registry"><a class="header" href="#finalization-registry">Finalization Registry</a></h3>
<p><strong>Принцип работы:</strong></p>
<ul>
<li>Регистрирует callback для вызова при сборке мусора</li>
<li>Зависит от работы Garbage Collector</li>
<li>Недетерминированное время выполнения</li>
</ul>
<h4 id="Пример-с-finalization-registry"><a class="header" href="#Пример-с-finalization-registry">Пример с Finalization Registry</a></h4>
<pre><code class="language-javascript">// Создаем registry для отслеживания освобождения ресурсов
const registry = new FinalizationRegistry((context) =&gt; {
  // Этот callback вызовется когда-то в будущем
  console.log('Finalization:', context.name);
  context.fd.close();
});

class LoggerWithRegistry {
  constructor(fileName) {
    const fd = fs.openSync(fileName, 'w');
    const stream = fs.createWriteStream(null, { fd });
    this.console = new Console(stream);

    // Регистрируем для финализации
    registry.register(this, { name: fileName, fd });
  }
}

// Использование
{
  const logger = new LoggerWithRegistry('output.log');
  logger.console.log('Hello');
  // logger выходит из области видимости
}

// Файл может закрыться через несколько секунд (или минут, или никогда)
// В зависимости от того, когда запустится GC
</code></pre>
<p><strong>Проблемы Finalization Registry:</strong></p>
<ol>
<li>
<p><strong>Недетерминированность:</strong></p>
<pre><code class="language-javascript">{
  const logger = new LoggerWithRegistry('output.log');
  logger.console.log('Message');
}

// Файл может остаться открытым неопределенно долго
fs.readFileSync('output.log'); // Может быть не готов!
</code></pre>
</li>
<li>
<p><strong>Может не вызваться вообще:</strong></p>
<pre><code class="language-javascript">{
  const logger = new LoggerWithRegistry('output.log');
  logger.console.log('Message');
}

// Если программа завершится до GC
process.exit(0); // Файл может остаться незакрытым!
</code></pre>
</li>
<li>
<p><strong>Невозможно контролировать момент очистки:</strong></p>
<pre><code class="language-javascript">for (let i = 0; i &lt; 1000; i++) {
  const logger = new LoggerWithRegistry(`file${i}.log`);
  logger.console.log(`Message ${i}`);
}

// Все 1000 файлов могут оставаться открытыми!
// Достижение лимита файловых дескрипторов
</code></pre>
</li>
</ol>
<h3 id="usingdisposable"><a class="header" href="#usingdisposable">Using/Disposable</a></h3>
<p><strong>Принцип работы:</strong></p>
<ul>
<li>Детерминированное освобождение ресурсов</li>
<li>Вызывается сразу при выходе из блока</li>
<li>Работает даже при исключениях</li>
</ul>
<h4 id="Пример-с-usingdisposable"><a class="header" href="#Пример-с-usingdisposable">Пример с Using/Disposable</a></h4>
<pre><code class="language-javascript">class LoggerWithDisposable {
  #fd = null;

  constructor(fileName) {
    this.#fd = fs.openSync(fileName, 'w');
    const stream = fs.createWriteStream(null, { fd: this.#fd });
    this.console = new Console(stream);
  }

  [Symbol.dispose]() {
    // Вызовется ГАРАНТИРОВАННО при выходе из блока
    console.log('Disposing logger');
    this.#fd.close();
  }
}

// Использование
{
  using logger = new LoggerWithDisposable('output.log');
  logger.console.log('Hello');
} // Файл закрывается СРАЗУ И ГАРАНТИРОВАННО
</code></pre>
<p><strong>Преимущества Using/Disposable:</strong></p>
<ol>
<li>
<p><strong>Детерминированность:</strong></p>
<pre><code class="language-javascript">{
  using logger = new LoggerWithDisposable('output.log');
  logger.console.log('Message');
} // Файл закрыт ПРЯМО ЗДЕСЬ

// Файл точно закрыт
fs.readFileSync('output.log'); // Всегда готов для чтения
</code></pre>
</li>
<li>
<p><strong>Работает с исключениями:</strong></p>
<pre><code class="language-javascript">try {
  using logger = new LoggerWithDisposable('output.log');
  logger.console.log('Message');
  throw new Error('Something went wrong');
} catch (err) {
  // Symbol.dispose ВСЁ РАВНО вызовется
  // Файл точно закрыт
}
</code></pre>
</li>
<li>
<p><strong>Контролируемое управление ресурсами:</strong></p>
<pre><code class="language-javascript">for (let i = 0; i &lt; 1000; i++) {
  using logger = new LoggerWithDisposable(`file${i}.log`);
  logger.console.log(`Message ${i}`);
  // Файл закрывается на каждой итерации
} // Максимум 1 открытый файл одновременно
</code></pre>
</li>
</ol>
<h3 id="Сравнительная-таблица"><a class="header" href="#Сравнительная-таблица">Сравнительная таблица</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Характеристика</th><th>Finalization Registry</th><th>Using/Disposable</th></tr></thead><tbody>
<tr><td><strong>Время вызова</strong></td><td>Недетерминированное (зависит от GC)</td><td>Детерминированное (сразу при выходе из блока)</td></tr>
<tr><td><strong>Гарантия вызова</strong></td><td>Может не вызваться</td><td>Гарантированно вызывается</td></tr>
<tr><td><strong>Работа с исключениями</strong></td><td>Может не сработать при ранних выходах</td><td>Работает всегда (как <code>finally</code>)</td></tr>
<tr><td><strong>Предсказуемость</strong></td><td>Низкая</td><td>Высокая</td></tr>
<tr><td><strong>Синтаксис</strong></td><td>Многословный</td><td>Краткий (<code>using</code>)</td></tr>
<tr><td><strong>Использование в продакшене</strong></td><td>Только для некритичных случаев</td><td>Рекомендуется для управления ресурсами</td></tr>
<tr><td><strong>Задержка освобождения</strong></td><td>От секунд до бесконечности</td><td>Мгновенно</td></tr>
<tr><td><strong>Контроль памяти</strong></td><td>Слабый</td><td>Полный</td></tr>
</tbody></table>
</div>
<h3 id="Когда-использовать-каждый-подход"><a class="header" href="#Когда-использовать-каждый-подход">Когда использовать каждый подход</a></h3>
<p><strong>Finalization Registry:</strong></p>
<ul>
<li>Кеширование, где важна производительность</li>
<li>Очистка некритичных данных</li>
<li>Дополнительная подстраховка (но не основной механизм)</li>
</ul>
<pre><code class="language-javascript">// Пример: кеш с автоочисткой
const cache = new Map();
const registry = new FinalizationRegistry((key) =&gt; {
  cache.delete(key);
});

function cacheValue(key, value) {
  cache.set(key, value);
  registry.register(value, key);
}
</code></pre>
<p><strong>Using/Disposable:</strong></p>
<ul>
<li>Файловые дескрипторы</li>
<li>Сетевые соединения</li>
<li>Блокировки и мьютексы</li>
<li>Транзакции базы данных</li>
<li>Любые критичные ресурсы, требующие своевременного освобождения</li>
</ul>
<pre><code class="language-javascript">// Пример: транзакция базы данных
async function updateUser(userId, data) {
  using transaction = await db.beginTransaction();
  try {
    await transaction.update('users', { id: userId }, data);
    await transaction.commit();
  } catch (err) {
    // transaction.dispose() вызовется автоматически
    // и сделает rollback
  }
}
</code></pre>
<hr />
<h2 id="Преимущества-и-ограничения-reference-counter"><a class="header" href="#Преимущества-и-ограничения-reference-counter">Преимущества и ограничения Reference Counter</a></h2>
<h3 id="Преимущества"><a class="header" href="#Преимущества">Преимущества</a></h3>
<h4 id="1-Автоматическое-управление-жизненным-циклом"><a class="header" href="#1-Автоматическое-управление-жизненным-циклом">1. Автоматическое управление жизненным циклом</a></h4>
<pre><code class="language-javascript">// БЕЗ Reference Counter - ручное управление
function withoutRefCounter() {
  const fd = fs.openSync('file.log', 'w');
  const stream = fs.createWriteStream(null, { fd });
  const logger = new Console(stream);

  try {
    logger.log('Message 1');

    try {
      logger.log('Message 2');
      // ... вложенная логика
    } finally {
      // Нужно отслеживать вручную
    }

    logger.log('Message 3');
  } finally {
    // Закрываем только здесь
    fd.close();
  }
}

// С Reference Counter - автоматически
function withRefCounter() {
  {
    using logger1 = logger.use('file.log');
    logger1.log('Message 1');

    {
      using logger2 = logger.use('file.log');
      logger2.log('Message 2');
    } // Счетчик уменьшается автоматически

    logger1.log('Message 3');
  } // Файл закрывается автоматически
}
</code></pre>
<h4 id="2-Безопасность-при-исключениях"><a class="header" href="#2-Безопасность-при-исключениях">2. Безопасность при исключениях</a></h4>
<pre><code class="language-javascript">// Даже при ошибках ресурсы освобождаются
async function processLogs() {
  {
    using logger = logger.use('output.log');
    logger.log('Start processing');

    // Может выбросить ошибку
    await riskyOperation();

    logger.log('End processing');
  } // dispose вызовется ДАЖЕ если riskyOperation бросит ошибку
}
</code></pre>
<h4 id="3-Защита-от-утечек-ресурсов"><a class="header" href="#3-Защита-от-утечек-ресурсов">3. Защита от утечек ресурсов</a></h4>
<pre><code class="language-javascript">// Невозможно забыть закрыть ресурс
function safeResourceUsage() {
  {
    using logger = logger.use('file.log');
    logger.log('Message');

    // Даже если забыли вручную закрыть - не проблема
    // return; // Ранний выход - dispose всё равно вызовется
  }
}
</code></pre>
<h3 id="Ограничения-и-проблемы"><a class="header" href="#Ограничения-и-проблемы">Ограничения и проблемы</a></h3>
<h4 id="1-Утечшие-ссылки-не-работают"><a class="header" href="#1-Утечшие-ссылки-не-работают">1. Утечшие ссылки не работают</a></h4>
<pre><code class="language-javascript">let leakedReference;

{
  using logger = logger.use('file.log');
  logger.log('Message');
  leakedReference = logger; // Сохраняем ссылку
} // Файл закрывается, счетчик = 0

// Ссылка существует, но бесполезна
leakedReference.log('This will not work'); // Файл уже закрыт!
</code></pre>
<p><strong>Решение:</strong> не сохранять ссылки на disposable объекты вне блока <code>using</code>.</p>
<h4 id="2-Не-рекомендуется-для-продакшена-пока"><a class="header" href="#2-Не-рекомендуется-для-продакшена-пока">2. Не рекомендуется для продакшена (пока)</a></h4>
<pre><code class="language-javascript">// Это прототип, не используйте в продакшене
// Нужно больше тестирования и доработки
const logger = new ReferenceCounter(/* ... */);

// TODO:
// - Обработка race conditions
// - Поддержка async dispose
// - Более надежная обработка ошибок
// - Тестирование edge cases
</code></pre>
<h4 id="3-Необходима-поддержка-браузеромnodejs"><a class="header" href="#3-Необходима-поддержка-браузеромnodejs">3. Необходима поддержка браузером/Node.js</a></h4>
<pre><code class="language-javascript">// Проверка поддержки
if (typeof Symbol.dispose === 'undefined') {
  console.error('Using/Disposable not supported!');
  // Нужен fallback или polyfill
}
</code></pre>
<hr />
<h2 id="Практические-рекомендации"><a class="header" href="#Практические-рекомендации">Практические рекомендации</a></h2>
<h3 id="1-Структура-проекта-с-reference-counter"><a class="header" href="#1-Структура-проекта-с-reference-counter">1. Структура проекта с Reference Counter</a></h3>
<pre><code class="language-javascript">// logger.js - модуль логирования
import { ReferenceCounter } from './reference-counter.js';

export const logger = new ReferenceCounter(
  // Создание ресурса
  () =&gt; {
    const fd = fs.openSync('app.log', 'a');
    const stream = fs.createWriteStream(null, { fd });
    const console = new Console(stream);
    return { resource: console, context: { fd } };
  },
  // Освобождение ресурса
  (context) =&gt; {
    context.fd.close();
  }
);

// app.js - использование
import { logger } from './logger.js';

export async function processRequest(request) {
  using log = logger.use();
  log.log('Request started:', request.id);

  try {
    await handleRequest(request);
    log.log('Request completed:', request.id);
  } catch (err) {
    log.error('Request failed:', err);
    throw err;
  }
  // dispose вызовется автоматически
}
</code></pre>
<h3 id="2-Множественные-ресурсы"><a class="header" href="#2-Множественные-ресурсы">2. Множественные ресурсы</a></h3>
<pre><code class="language-javascript">// Управление несколькими ресурсами одновременно
async function complexOperation() {
  using dbConnection = connectionPool.use();
  using fileLogger = logger.use('operation.log');
  using lockHandle = lockManager.use('operation-lock');

  // Все три ресурса будут автоматически освобождены
  await performOperation(dbConnection, fileLogger);

} // dispose вызовется для всех трех ресурсов
</code></pre>
<h3 id="3-Правильная-обработка-ошибок"><a class="header" href="#3-Правильная-обработка-ошибок">3. Правильная обработка ошибок</a></h3>
<pre><code class="language-javascript">class ReferenceCounter {
  use() {
    this.#counter++;
    const resource = this.#resource;
    const disposable = Object.create(resource);

    disposable[Symbol.dispose] = () =&gt; {
      this.#counter--;

      if (this.#counter === 0) {
        try {
          // Обрабатываем ошибки при dispose
          this.#dispose(this.#context);
        } catch (err) {
          // Логируем, но не пробрасываем
          console.error('Error during dispose:', err);
        } finally {
          // Всегда очищаем ссылки
          this.#resource = null;
          this.#context = null;
        }
      }
    };

    return disposable;
  }
}
</code></pre>
<h3 id="4-Паттерн-для-ленивой-инициализации"><a class="header" href="#4-Паттерн-для-ленивой-инициализации">4. Паттерн для ленивой инициализации</a></h3>
<pre><code class="language-javascript">class ReferenceCounter {
  #initialized = false;

  use() {
    // Инициализация при первом использовании
    if (!this.#initialized) {
      const { resource, context } = this.#create();
      this.#resource = resource;
      this.#context = context;
      this.#initialized = true;
    }

    this.#counter++;
    // ... остальной код
  }
}
</code></pre>
<hr />
<h2 id="Диаграмма-жизненного-цикла-reference-counter"><a class="header" href="#Диаграмма-жизненного-цикла-reference-counter">Диаграмма жизненного цикла Reference Counter</a></h2>
<pre><code>Состояние счетчика для output.log:

Блок 0 начало:  counter = 1  [FILE OPENED]
│
├── Блок 1 начало:  counter = 2
│   │
│   ├── Блок 2 начало:  counter = 3
│   │   │
│   │   └── Блок 2 конец:  counter = 2  [dispose вызван]
│   │
│   └── Блок 1 конец:  counter = 1  [dispose вызван]
│
└── Блок 0 конец:  counter = 0  [FILE CLOSED, dispose вызван]


Состояние счетчика для output3.log:

Блок 3 начало:  counter = 1  [FILE OPENED]
│
└── Блок 3 конец:  counter = 0  [FILE CLOSED, dispose вызван]
</code></pre>
<hr />
<h2 id="Полный-код-реализации-reference-counter"><a class="header" href="#Полный-код-реализации-reference-counter">Полный код реализации Reference Counter</a></h2>
<h3 id="reference-counterjs"><a class="header" href="#reference-counterjs">reference-counter.js</a></h3>
<pre><code class="language-javascript">/**
 * Reference Counter для управления жизненным циклом ресурсов
 * на основе механизма using/disposable
 */
export class ReferenceCounter {
  // Приватные поля
  #resource = null;   // Сам ресурс (объект для использования)
  #context = null;    // Контекст с данными для финализации
  #counter = 0;       // Счетчик активных ссылок
  #create = null;     // Функция создания ресурса
  #dispose = null;    // Функция освобождения ресурса

  /**
   * @param {Function} create - Функция создания ресурса
   *   Должна возвращать { resource, context }
   * @param {Function} dispose - Функция освобождения ресурса
   *   Принимает context в качестве параметра
   */
  constructor(create, dispose) {
    this.#create = create;
    this.#dispose = dispose;
  }

  /**
   * Создает disposable объект для использования с using
   * @returns {Object} Disposable объект с методом Symbol.dispose
   */
  use() {
    // Ленивая инициализация при первом использовании
    if (this.#resource === null) {
      const { resource, context } = this.#create();
      this.#resource = resource;
      this.#context = context;
    }

    // Увеличиваем счетчик ссылок
    this.#counter++;
    console.log(`use (counter: ${this.#counter})`);

    // Создаем новый объект, наследующий от ресурса
    const disposable = Object.create(this.#resource);

    // Добавляем метод dispose
    disposable[Symbol.dispose] = () =&gt; {
      // Уменьшаем счетчик
      this.#counter--;
      console.log(`dispose (counter: ${this.#counter})`);

      // Если счетчик достиг нуля - освобождаем ресурс
      if (this.#counter === 0) {
        try {
          this.#dispose(this.#context);
          console.log('close');
        } catch (err) {
          console.error('Error during dispose:', err);
        } finally {
          this.#resource = null;
          this.#context = null;
        }
      }
    };

    return disposable;
  }
}
</code></pre>
<h3 id="multi-file-loggerjs"><a class="header" href="#multi-file-loggerjs">multi-file-logger.js</a></h3>
<pre><code class="language-javascript">import fs from 'node:fs';
import { Console } from 'node:console';

/**
 * Логер с поддержкой нескольких файлов
 * и reference counting для каждого файла
 */
export class MultiFileLogger {
  // Коллекция открытых файлов
  // Map&lt;fileName, { counter, fd, console }&gt;
  #files = new Map();

  /**
   * Открывает файл и создает консоль для записи
   * @param {string} fileName - Имя файла
   * @returns {Object} Структура { counter, fd, console }
   */
  open(fileName) {
    console.log(`open ${fileName}`);

    // Открываем файл для записи
    const fd = fs.openSync(fileName, 'w');

    // Создаем поток записи
    const stream = fs.createWriteStream(null, { fd });

    // Создаем консоль для этого потока
    const console = new Console(stream);

    // Возвращаем структуру
    return {
      counter: 0,
      fd,
      console
    };
  }

  /**
   * Получает disposable для записи в файл
   * @param {string} fileName - Имя файла
   * @returns {Object} Disposable объект консоли
   */
  use(fileName) {
    // Ищем файл в коллекции
    let instance = this.#files.get(fileName);

    // Если файл не открыт - открываем
    if (!instance) {
      instance = this.open(fileName);
      this.#files.set(fileName, instance);
    }

    // Увеличиваем счетчик
    instance.counter++;
    console.log(`use ${fileName} (counter: ${instance.counter})`);

    // Создаем disposable
    const disposable = Object.create(instance.console);

    // Добавляем метод dispose
    disposable[Symbol.dispose] = () =&gt; {
      instance.counter--;
      console.log(`dispose ${fileName} (counter: ${instance.counter})`);

      // Если счетчик достиг нуля - закрываем файл
      if (instance.counter === 0) {
        instance.fd.close();
        this.#files.delete(fileName);
        console.log(`close ${fileName}`);
      }
    };

    return disposable;
  }
}
</code></pre>
<h3 id="example-7js"><a class="header" href="#example-7js">example-7.js</a></h3>
<pre><code class="language-javascript">import fs from 'node:fs';
import { Console } from 'node:console';
import { ReferenceCounter } from './reference-counter.js';

// Создание логера
const logger = new ReferenceCounter(
  // Функция создания
  () =&gt; {
    console.log('open');
    const fd = fs.openSync('output.log', 'w');
    const stream = fs.createWriteStream(null, { fd });
    const console = new Console(stream);
    return { resource: console, context: { fd } };
  },
  // Функция освобождения
  (context) =&gt; {
    context.fd.close();
  }
);

// Использование
async function main() {
  let rf3;

  // Блок 0
  {
    using console0 = logger.use();
    console0.log('log 0');

    // Блок 1
    {
      using console1 = logger.use();
      console1.log('log 1');

      // Блок 2
      {
        using console2 = logger.use();
        console2.log('log 2');
        rf3 = console2; // Сохраняем ссылку
      }
    }
  }

  // Блок 3 - утекшая ссылка
  {
    using rf4 = rf3;
    rf4.log('log 3'); // Не запишется
  }

  return rf3;
}

const rf4 = await main();
console.log('After main');
rf4.log('log 4'); // Не запишется
</code></pre>
<h3 id="example-8js"><a class="header" href="#example-8js">example-8.js</a></h3>
<pre><code class="language-javascript">import { MultiFileLogger } from './multi-file-logger.js';

const logger = new MultiFileLogger();

async function main() {
  let rf;

  // Блок 0
  {
    using c0 = logger.use('output.log');
    c0.log('log 0');

    // Блок 1
    {
      using c1 = logger.use('output.log');
      c1.log('log 1');

      // Блок 2
      {
        using c2 = logger.use('output.log');
        c2.log('log 2');

        // Блок 3 - другой файл
        {
          using c3 = logger.use('output3.log');
          c3.log('log 3');
        }

        rf = c2;
      }
    }
  }

  return rf;
}

// Блок 4
{
  const f1 = await main();
  using c4 = f1;
  c4.log('log 4'); // Не запишется
}

console.log('After main');

// Блок 5
{
  using c5 = f1;
  c5.log('log 5'); // Не запишется
}
</code></pre>
<hr />
<h2 id="Ключевые-выводы"><a class="header" href="#Ключевые-выводы">Ключевые выводы</a></h2>
<h3 id="1-reference-counter-решает-важные-проблемы"><a class="header" href="#1-reference-counter-решает-важные-проблемы">1. Reference Counter решает важные проблемы</a></h3>
<p>✓ <strong>Автоматическое управление ресурсами:</strong> не нужно вручную отслеживать открытие/закрытие
✓ <strong>Безопасность при исключениях:</strong> ресурсы освобождаются даже при ошибках
✓ <strong>Защита от утечек:</strong> невозможно забыть закрыть ресурс
✓ <strong>Детерминированность:</strong> ресурсы освобождаются сразу, а не когда-нибудь</p>
<h3 id="2-usingdisposable-vs-finalization-registry"><a class="header" href="#2-usingdisposable-vs-finalization-registry">2. Using/Disposable vs Finalization Registry</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Using/Disposable</th><th>Finalization Registry</th></tr></thead><tbody>
<tr><td>Детерминированное освобождение</td><td>Недетерминированное</td></tr>
<tr><td>Гарантия вызова</td><td>Может не вызваться</td></tr>
<tr><td>Мгновенное освобождение</td><td>Задержка до GC</td></tr>
<tr><td>Рекомендуется для критичных ресурсов</td><td>Только для некритичных случаев</td></tr>
</tbody></table>
</div>
<h3 id="3-Практические-советы"><a class="header" href="#3-Практические-советы">3. Практические советы</a></h3>
<p><strong>Делайте:</strong></p>
<ul>
<li>Используйте <code>using</code> для файлов, соединений, транзакций</li>
<li>Обрабатывайте ошибки в методе <code>dispose</code></li>
<li>Проверяйте поддержку <code>Symbol.dispose</code> в целевой среде</li>
</ul>
<p><strong>Не делайте:</strong></p>
<ul>
<li>Не сохраняйте ссылки на disposable объекты вне блока <code>using</code></li>
<li>Не используйте текущую реализацию Reference Counter в продакшене (пока это прототип)</li>
<li>Не полагайтесь на Finalization Registry для критичных ресурсов</li>
</ul>
<h3 id="4-Статус-технологии"><a class="header" href="#4-Статус-технологии">4. Статус технологии</a></h3>
<p>⚠️ <strong>Текущий статус:</strong> Прототип, экспериментальная реализация</p>
<p><strong>Доступность:</strong></p>
<ul>
<li>Node.js v24+</li>
<li>Современные версии Chrome</li>
<li>Требует проверки поддержки</li>
</ul>
<p><strong>Будущее:</strong></p>
<ul>
<li>Доработка и тестирование</li>
<li>Возможное включение в Metarhia technology stack</li>
<li>Создание библиотеки с готовыми классами</li>
</ul>
<hr />
<h2 id="Дополнительные-материалы"><a class="header" href="#Дополнительные-материалы">Дополнительные материалы</a></h2>
<h3 id="Полезные-ссылки"><a class="header" href="#Полезные-ссылки">Полезные ссылки</a></h3>
<ul>
<li><a href="https://github.com/tc39/proposal-explicit-resource-management">TC39 Proposal: Explicit Resource Management</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/dispose">MDN: Symbol.dispose</a></li>
<li>Исходники примеров под видео лекции</li>
</ul>
<h3 id="Связанные-темы-для-изучения"><a class="header" href="#Связанные-темы-для-изучения">Связанные темы для изучения</a></h3>
<ol>
<li><strong>Finalization Registry</strong> - альтернативный подход к управлению ресурсами</li>
<li><strong>WeakRef и WeakMap</strong> - слабые ссылки в JavaScript</li>
<li><strong>Try...finally</strong> - классический подход к освобождению ресурсов</li>
<li><strong>RAII (Resource Acquisition Is Initialization)</strong> - паттерн из C++, вдохновивший using/disposable</li>
<li><strong>Async Disposable</strong> - асинхронная версия disposable (Symbol.asyncDispose)</li>
</ol>
<h3 id="Практические-задания"><a class="header" href="#Практические-задания">Практические задания</a></h3>
<ol>
<li>Реализуйте Reference Counter для пула соединений к базе данных</li>
<li>Создайте систему блокировок (locks) с автоматическим освобождением</li>
<li>Реализуйте файловый кеш с автоматической очисткой</li>
<li>Добавьте поддержку async dispose для асинхронных ресурсов</li>
</ol>
<hr />
<h2 id="Заключение"><a class="header" href="#Заключение">Заключение</a></h2>
<p>Механизм <strong>using/disposable</strong> представляет собой мощный инструмент для управления жизненным циклом ресурсов в JavaScript. В сочетании с паттерном <strong>Reference Counter</strong>, он позволяет создавать надежные и безопасные абстракции для работы с файлами, соединениями и другими критичными ресурсами.</p>
<p><strong>Основные преимущества подхода:</strong></p>
<ul>
<li>Детерминированное освобождение ресурсов</li>
<li>Автоматическая защита от утечек</li>
<li>Краткий и понятный синтаксис</li>
<li>Безопасность при исключениях</li>
</ul>
<p><strong>Текущие ограничения:</strong></p>
<ul>
<li>Относительно новая технология</li>
<li>Требует поддержки современных версий платформ</li>
<li>Прототипная реализация Reference Counter не готова для продакшена</li>
</ul>
<p>Следите за развитием технологии и экспериментируйте с примерами, чтобы быть готовыми к ее широкому применению в будущем!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../week2/конспект-using-dispose.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../week3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../week2/конспект-using-dispose.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../week3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
