<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GRASP: Чистая выдумка — Pure fabrication - Patterns</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Patterns</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Лекция-3-grasp--pure-fabrication-Чистая-выдумка"><a class="header" href="#Лекция-3-grasp--pure-fabrication-Чистая-выдумка">Лекция 3. GRASP — Pure Fabrication (Чистая выдумка)</a></h1>
<h2 id="Введение"><a class="header" href="#Введение">Введение</a></h2>
<p><strong>Pure Fabrication</strong> (Чистая выдумка) — один из девяти принципов GRASP. Он отвечает
на вопрос: что делать, если нам нужна программная абстракция, которая <strong>не соответствует
ни одной сущности предметной области</strong>, но при этом значительно снижает зацепление
(Low Coupling) и улучшает связность (High Cohesion) кода?</p>
<p>Ответ: <strong>придумываем её</strong>. Отсюда и название — "чистая выдумка".</p>
<p>Примеры чистых выдумок, которые мы уже изучали:</p>
<ul>
<li><code>Promise</code> — нет такой вещи в реальном мире</li>
<li><code>EventEmitter</code> — тоже придуман для удобства программирования</li>
<li><code>Socket</code> — абстракция над сетевым соединением</li>
<li>Слой доступа к данным (Repository, Loader, Storage) — не объект предметной области</li>
</ul>
<hr />
<h2 id="31-Проблема-знание-о-слое-данных-внутри-доменного-класса"><a class="header" href="#31-Проблема-знание-о-слое-данных-внутри-доменного-класса">3.1 Проблема: знание о слое данных внутри доменного класса</a></h2>
<p>Рассмотрим типичную ошибку — когда класс предметной области "знает" о структуре
базы данных.</p>
<pre><code class="language-javascript">// Пример 1. ПЛОХОЙ КОД — Person знает о базе данных (высокое зацепление)

// Симуляция объекта соединения с базой данных
const db = {
  async query(sql, params) {
    // В реальности здесь был бы вызов pg, mysql2 и т.д.
    console.log(`Выполняем SQL: ${sql}`, params);
    // Возвращаем симулированные данные
    return { name: 'Рене Декарт', age: 54, address: 'Нидерланды' };
  },
};

// ПРОБЛЕМА: класс Person сам умеет загружать себя из БД
class Person {
  constructor(data) {
    // Person знает о структуре записи из базы данных
    this.name = data.name;
    this.age = data.age;
    this.address = data.address;
  }

  // ПЛОХО: статический метод загрузки прямо в доменном классе
  // Person не должен знать о SQL и структуре таблиц
  static async load(db, id) {
    const data = await db.query('SELECT name, age, address FROM persons WHERE id = $1', [id]);
    // Person знает, что поля называются именно name, age, address
    return new Person(data);
  }
}

// Использование
async function main() {
  const person = await Person.load(db, 101);
  console.log(person);
}

main();
// Проблемы:
// 1. Person привязан к структуре БД (изменение схемы = изменение Person)
// 2. Person нарушает Single Responsibility Principle
// 3. Сложно тестировать — нужна реальная БД или мок
</code></pre>
<hr />
<h2 id="32-Шаг-1-Разделение-person-и-логики-загрузки"><a class="header" href="#32-Шаг-1-Разделение-person-и-логики-загрузки">3.2 Шаг 1: Разделение Person и логики загрузки</a></h2>
<p>Первое улучшение — вынести метод загрузки из класса <code>Person</code> в отдельный класс.</p>
<pre><code class="language-javascript">// Пример 2. Разделение: Person — только предметная область, Loader — чистая выдумка

// Симуляция базы данных
const db = {
  async query(sql, params) {
    console.log(`SQL: ${sql}`, params);
    return { name: 'Рене Декарт', age: 54, address: 'Нидерланды' };
  },
};

// Чистый доменный класс — знает только о своих полях предметной области
class Person {
  constructor({ name, age, address }) {
    this.name = name;
    this.age = age;
    this.address = address;
  }

  // Методы предметной области (если нужны)
  greet() {
    return `Меня зовут ${this.name}`;
  }
}

// ЧИСТАЯ ВЫДУМКА: Loader — класс, которого нет в предметной области,
// но он нужен нам для организации кода
// Loader знает о базе данных, Person — нет
class PersonLoader {
  constructor(db) {
    this.db = db;    // ссылка на соединение с БД (Dependency Injection)
  }

  // Загружает Person из БД по идентификатору
  async load(id) {
    const data = await this.db.query(
      'SELECT name, age, address FROM persons WHERE id = $1',
      [id],
    );
    // Loader создаёт Person из данных БД
    return new Person(data);
  }
}

// Использование
async function main() {
  const loader = new PersonLoader(db);
  const person = await loader.load(101);
  console.log(person.greet());
  // Вывод: SQL: SELECT name, age, address FROM persons WHERE id = $1 [ 101 ]
  //        Меня зовут Рене Декарт
}

main();
</code></pre>
<hr />
<h2 id="33-Шаг-2-Универсальный-loader-через-замыкания"><a class="header" href="#33-Шаг-2-Универсальный-loader-через-замыкания">3.3 Шаг 2: Универсальный Loader через замыкания</a></h2>
<p>Ещё лучше — сделать Loader универсальным, не привязанным к конкретному классу Person.
Здесь мы используем метапрограммирование JavaScript: создаём класс "на лету".</p>
<pre><code class="language-javascript">// Пример 3. Универсальный Loader — ещё одна чистая выдумка
// Loader не знает о Person, он работает с любой сущностью

const db = {
  async query(sql, params) {
    console.log(`SQL: ${sql}`, params);
    // Симулируем данные из разных таблиц
    const mockData = {
      persons: { name: 'Рене Декарт', age: 54, address: 'Нидерланды' },
      products: { title: 'Книга по философии', price: 999 },
    };
    return mockData[params[1]] ?? {};
  },
};

// Фабричная функция: принимает соединение с БД и имя сущности,
// возвращает асинхронную функцию загрузки
// Это замыкание — вместо класса для краткости
const createLoader = (db, entityName) =&gt; {
  // Создаём анонимный класс и даём ему имя через Object.defineProperty
  // Это метапрограммирование: имя класса формируется динамически
  const EntityClass = class {};
  Object.defineProperty(EntityClass, 'name', {
    value: entityName,
    writable: false,
  });

  // SQL-запрос тоже формируется по имени сущности
  const sql = `SELECT * FROM ${entityName} WHERE id = $1`;

  // Возвращаем функцию загрузки — замыкание над db, EntityClass и sql
  return async (id) =&gt; {
    const data = await db.query(sql, [id, entityName]);
    // Создаём экземпляр нужного класса и копируем в него поля из БД
    return Object.assign(new EntityClass(), data);
  };
};

// Использование: создаём загрузчики для разных сущностей
async function main() {
  const loadPerson = createLoader(db, 'persons');
  const loadProduct = createLoader(db, 'products');

  const person = await loadPerson(101);
  console.log('Загружен:', person.constructor.name, person);
  // Вывод: Загружен: persons { name: 'Рене Декарт', age: 54, address: 'Нидерланды' }

  const product = await loadProduct(42);
  console.log('Загружен:', product.constructor.name, product);
  // Вывод: Загружен: products { title: 'Книга по философии', price: 999 }
}

main();
</code></pre>
<hr />
<h2 id="34-Чистая-выдумка-для-работы-с-файлами-класс-storage"><a class="header" href="#34-Чистая-выдумка-для-работы-с-файлами-класс-storage">3.4 Чистая выдумка для работы с файлами: класс Storage</a></h2>
<p>Ещё один классический пример Pure Fabrication — слой хранения данных в файловой системе.
Сначала покажем плохой вариант, затем правильный.</p>
<pre><code class="language-javascript">// Пример 4. ПЛОХОЙ КОД — Person сам умеет сохраняться на диск

import { writeFileSync, readFileSync, existsSync } from 'node:fs';

// ПРОБЛЕМА: Person знает о файловой системе, сериализации, путях к файлам
class Person {
  constructor(name, age, fileName) {
    this.name = name;
    this.age = age;
    // fileName — это деталь реализации, которая не должна быть в Person
    // В предметной области у Person нет "имени файла"
    Object.defineProperty(this, 'fileName', {
      value: fileName,
      enumerable: false,   // не попадёт в JSON.stringify
      writable: false,
    });
  }

  // ПЛОХО: Person знает о сериализации и записи в файл
  save() {
    const json = JSON.stringify(this);
    writeFileSync(this.fileName, json, 'utf-8');
    console.log(`Сохранено в ${this.fileName}`);
  }

  // ПЛОХО: Person умеет читать себя из файла
  static load(fileName) {
    const json = readFileSync(fileName, 'utf-8');
    const data = JSON.parse(json);
    return Object.assign(new Person('', 0, fileName), data);
  }
}

// Использование
const person = new Person('Рене Декарт', 54, './descartes.json');
person.save();

const loaded = Person.load('./descartes.json');
console.log(loaded);
// Проблемы те же: Person нарушает SRP, тяжело тестировать, тяжело переиспользовать
</code></pre>
<pre><code class="language-javascript">// Пример 5. ХОРОШИЙ КОД — Storage как чистая выдумка (Pure Fabrication)

import { writeFileSync, readFileSync, mkdirSync, existsSync } from 'node:fs';
import { join } from 'node:path';

// Чистый доменный класс — только поля предметной области
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  introduce() {
    return `Я ${this.name}, мне ${this.age} лет`;
  }
}

// ЧИСТАЯ ВЫДУМКА: Storage
// Этот класс не существует в предметной области, но он нам нужен
// для организации работы с файловой системой
// Преимущества:
// - Person ничего не знает о файлах
// - Storage можно заменить (например, на DatabaseStorage) без изменения Person
// - Storage легко тестировать изолированно
class Storage {
  constructor(directory) {
    this.directory = directory;
    // Создаём директорию, если её нет
    if (!existsSync(directory)) {
      mkdirSync(directory, { recursive: true });
    }
  }

  // Формируем путь к файлу по идентификатору
  _getFilePath(id) {
    return join(this.directory, `${id}.json`);
  }

  // Сохраняем произвольный объект под указанным идентификатором
  save(id, entity) {
    const filePath = this._getFilePath(id);
    const json = JSON.stringify(entity, null, 2);
    writeFileSync(filePath, json, 'utf-8');
    console.log(`Сохранено: ${filePath}`);
  }

  // Загружаем объект по идентификатору и "превращаем" его в экземпляр нужного класса
  load(id, EntityClass) {
    const filePath = this._getFilePath(id);
    if (!existsSync(filePath)) {
      throw new Error(`Запись с id=${id} не найдена`);
    }
    const json = readFileSync(filePath, 'utf-8');
    const data = JSON.parse(json);
    // Object.assign копирует все поля из data в новый экземпляр EntityClass
    return Object.assign(new EntityClass('', 0), data);
  }
}

// Использование — Storage и Person слабо связаны (Low Coupling)
async function main() {
  const storage = new Storage('./data');

  // Создаём Person без каких-либо знаний о хранении
  const person = new Person('Рене Декарт', 54);

  // Storage сохраняет его — Person об этом не знает
  storage.save(100, person);

  // Storage загружает и восстанавливает объект
  const loaded = storage.load(100, Person);
  console.log(loaded.introduce());
  // Вывод: Я Рене Декарт, мне 54 лет
}

main();
</code></pre>
<hr />
<h2 id="35-Несколько-уровней-чистой-выдумки"><a class="header" href="#35-Несколько-уровней-чистой-выдумки">3.5 Несколько уровней чистой выдумки</a></h2>
<p>В реальных приложениях чистые выдумки образуют <strong>слои</strong>. Каждый слой скрывает
детали от следующего.</p>
<pre><code class="language-javascript">// Пример 6. Три слоя чистой выдумки: Domain -&gt; Repository -&gt; Driver

// ==========================================
// Слой 1: Предметная область (Domain)
// Только бизнес-логика, никаких деталей хранения
// ==========================================

class Product {
  constructor(title, price, category) {
    this.title = title;
    this.price = price;
    this.category = category;
  }

  isExpensive() {
    return this.price &gt; 1000;
  }

  applyDiscount(percent) {
    return new Product(
      this.title,
      this.price * (1 - percent / 100),
      this.category,
    );
  }
}

// ==========================================
// Слой 2: Репозиторий (ЧИСТАЯ ВЫДУМКА #1)
// Абстракция над хранилищем — не знает, это файл, БД или память
// Знает только о Product
// ==========================================

class ProductRepository {
  constructor(driver) {
    // driver — ещё одна чистая выдумка ниже уровнем
    this.driver = driver;
  }

  async findById(id) {
    const data = await this.driver.read('products', id);
    if (!data) return null;
    return Object.assign(new Product('', 0, ''), data);
  }

  async save(id, product) {
    await this.driver.write('products', id, { ...product });
  }

  async findExpensive() {
    const all = await this.driver.readAll('products');
    return all
      .map((data) =&gt; Object.assign(new Product('', 0, ''), data))
      .filter((p) =&gt; p.isExpensive());
  }
}

// ==========================================
// Слой 3: Драйвер хранения (ЧИСТАЯ ВЫДУМКА #2)
// Знает о конкретном способе хранения (в памяти, файл, БД)
// Не знает о Product — работает с сырыми данными
// ==========================================

class InMemoryDriver {
  constructor() {
    // Простое хранилище в памяти: { 'products': { 1: {...}, 2: {...} } }
    this.store = new Map();
  }

  async read(collection, id) {
    const coll = this.store.get(collection);
    return coll ? coll.get(id) ?? null : null;
  }

  async write(collection, id, data) {
    if (!this.store.has(collection)) {
      this.store.set(collection, new Map());
    }
    this.store.get(collection).set(id, data);
  }

  async readAll(collection) {
    const coll = this.store.get(collection);
    return coll ? [...coll.values()] : [];
  }
}

// ==========================================
// Пример использования
// ==========================================

async function main() {
  // Собираем слои через Dependency Injection
  const driver = new InMemoryDriver();           // чистая выдумка #2
  const repo = new ProductRepository(driver);    // чистая выдумка #1

  // Работаем с предметной областью — про слои хранения не думаем
  const book = new Product('Паттерны проектирования', 1500, 'books');
  const pen = new Product('Ручка', 50, 'stationery');

  await repo.save(1, book);
  await repo.save(2, pen);

  // Загружаем по id
  const loaded = await repo.findById(1);
  console.log(`Загружен: ${loaded.title}, цена: ${loaded.price}`);
  // Вывод: Загружен: Паттерны проектирования, цена: 1500

  // Используем метод предметной области
  console.log(`Дорогой товар? ${loaded.isExpensive()}`);
  // Вывод: Дорогой товар? true

  // Поиск дорогих товаров
  const expensive = await repo.findExpensive();
  console.log('Дорогие товары:', expensive.map((p) =&gt; p.title));
  // Вывод: Дорогие товары: [ 'Паттерны проектирования' ]
}

main();
</code></pre>
<hr />
<h2 id="36-Стратегия-как-расширение-чистой-выдумки"><a class="header" href="#36-Стратегия-как-расширение-чистой-выдумки">3.6 Стратегия как расширение чистой выдумки</a></h2>
<p>Чистая выдумка (Loader, Storage, Repository) может быть расширена до <strong>паттерна Стратегия</strong>:
базовый класс определяет интерфейс, конкретные подклассы — реализации.</p>
<pre><code class="language-javascript">// Пример 7. Repository как стратегия: файловое и in-memory хранилище

import { writeFileSync, readFileSync, readdirSync, existsSync, mkdirSync } from 'node:fs';
import { join } from 'node:path';

// ==========================================
// Базовый класс — определяет интерфейс (контракт)
// ==========================================

class BaseRepository {
  // Абстрактный метод — подклассы обязаны переопределить
  async save(id, entity) {
    throw new Error('save() не реализован');
  }

  async findById(id) {
    throw new Error('findById() не реализован');
  }

  async findAll() {
    throw new Error('findAll() не реализован');
  }
}

// ==========================================
// Стратегия 1: хранение в памяти (для тестов)
// ==========================================

class MemoryRepository extends BaseRepository {
  constructor() {
    super();
    this.data = new Map();
  }

  async save(id, entity) {
    // Сохраняем копию, чтобы избежать мутации оригинала
    this.data.set(id, { ...entity });
  }

  async findById(id) {
    return this.data.get(id) ?? null;
  }

  async findAll() {
    return [...this.data.values()];
  }
}

// ==========================================
// Стратегия 2: хранение в файлах (для продакшена)
// ==========================================

class FileRepository extends BaseRepository {
  constructor(directory) {
    super();
    this.directory = directory;
    if (!existsSync(directory)) {
      mkdirSync(directory, { recursive: true });
    }
  }

  _filePath(id) {
    return join(this.directory, `${id}.json`);
  }

  async save(id, entity) {
    writeFileSync(this._filePath(id), JSON.stringify(entity, null, 2), 'utf-8');
  }

  async findById(id) {
    const path = this._filePath(id);
    if (!existsSync(path)) return null;
    return JSON.parse(readFileSync(path, 'utf-8'));
  }

  async findAll() {
    if (!existsSync(this.directory)) return [];
    return readdirSync(this.directory)
      .filter((f) =&gt; f.endsWith('.json'))
      .map((f) =&gt; JSON.parse(readFileSync(join(this.directory, f), 'utf-8')));
  }
}

// ==========================================
// Предметная область — не зависит от реализации хранилища
// ==========================================

class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}

// ==========================================
// Функция сервисного слоя — работает с любой стратегией хранилища
// ==========================================

async function runDemo(repository) {
  await repository.save(1, new Person('Рене Декарт', 54));
  await repository.save(2, new Person('Иммануил Кант', 79));

  const descartes = await repository.findById(1);
  console.log('Найден:', descartes);

  const all = await repository.findAll();
  console.log('Все записи:', all.length, 'штук');
}

// Запускаем с разными стратегиями хранения
async function main() {
  console.log('--- In-Memory хранилище ---');
  await runDemo(new MemoryRepository());

  console.log('\n--- Файловое хранилище ---');
  await runDemo(new FileRepository('./tmp-persons'));
}

main();
// Код сервисного слоя (runDemo) одинаков для обеих стратегий!
// Pure Fabrication + Strategy = мощная комбинация
</code></pre>
<hr />
<h2 id="37-Итог-почему-pure-fabrication-важна"><a class="header" href="#37-Итог-почему-pure-fabrication-важна">3.7 Итог: почему Pure Fabrication важна</a></h2>
<pre><code class="language-javascript">// Пример 8. Краткая демонстрация эффекта от применения Pure Fabrication

// БЕЗ Pure Fabrication:
// User --знает о--&gt; Database
// User --знает о--&gt; FileSystem
// User --знает о--&gt; NetworkAPI
// Высокое зацепление (High Coupling) — изменение БД ломает User

// С Pure Fabrication:
// User --использует--&gt; UserRepository (чистая выдумка)
// UserRepository --использует--&gt; Driver (чистая выдумка)
// Driver --работает с--&gt; Database / FileSystem / NetworkAPI
// Каждый слой знает только о следующем уровне абстракции

// Ключевые выгоды Pure Fabrication:
// 1. Low Coupling — User не зависит от конкретной БД
// 2. High Cohesion — каждый класс делает одно дело
// 3. Testability — можно подменить Driver на MemoryDriver в тестах
// 4. Reusability — Repository можно использовать с разными Entity

// Примеры Pure Fabrication в экосистеме Node.js:
const examples = [
  'EventEmitter    — нет такого в предметной области, но упрощает события',
  'Promise         — абстракция над асинхронностью, не объект реального мира',
  'Readable/Writable Stream — абстракция над потоком данных',
  'Repository      — нет в предметной области, но нужен для Low Coupling',
  'Logger          — не бизнес-логика, но нужен везде',
  'ConnectionPool  — техническая абстракция над пулом соединений',
  'Middleware      — концепция из Express, нет в HTTP-спецификации',
];

examples.forEach((ex) =&gt; console.log('-', ex));
</code></pre>
<hr />
<h2 id="Заключение"><a class="header" href="#Заключение">Заключение</a></h2>
<p>Три темы, разобранные в лекциях этой недели, тесно связаны между собой:</p>
<ol>
<li>
<p><strong>EventTarget / EventEmitter</strong> — конкретные реализации контракта событий в JavaScript.
Понимание разницы между ними критично для написания кода, совместимого с браузером
и Node.js одновременно.</p>
</li>
<li>
<p><strong>Observer / Observable</strong> — паттерн, который лежит в основе EventEmitter, RxJS
и других реактивных библиотек. Реализация "с нуля" позволяет понять, что происходит
внутри готовых инструментов.</p>
</li>
<li>
<p><strong>Pure Fabrication</strong> — принцип GRASP, объясняющий, почему мы создаём абстракции
вроде Repository, Loader, Storage. Это не усложнение ради усложнения, а сознательное
снижение зацепления между слоями приложения.</p>
</li>
</ol>
<p><strong>Практический совет:</strong> Реализуйте каждый из примеров самостоятельно, добавьте
<code>console.log</code> в ключевые места, напишите тесты. Только через практику приходит
настоящее понимание этих концепций.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../week6/lecture-2-observer.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../week7.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../week6/lecture-2-observer.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../week7.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
