<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Builder - Patterns</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Patterns</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="builder-pattern---lecture-notes"><a class="header" href="#builder-pattern---lecture-notes">Builder Pattern - Lecture Notes</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The <strong>Builder Pattern</strong> is a creational design pattern from the Gang of Four (GoF) that separates the construction of complex objects from their representation. It allows you to construct complex objects step by step, providing flexibility in creating different representations of an object using the same construction process.</p>
<h3 id="main-purpose"><a class="header" href="#main-purpose">Main Purpose</a></h3>
<p>The Builder pattern addresses the problem of complex object instantiation by:</p>
<ul>
<li>Separating object construction logic from the domain model/class itself</li>
<li>Moving instantiation logic to a dedicated builder class</li>
<li>Providing a clean interface for object initialization and modification</li>
<li>Allowing different configurations and variations of object creation</li>
</ul>
<hr />
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<h3 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h3>
<p>When a constructor becomes too complex and we want to separate the instantiation logic from the domain model or class itself, we can extract this responsibility into a separate class that specializes in creating instances.</p>
<p><strong>Key insight</strong>: The Builder is a class dedicated to instantiating another class (or multiple classes).</p>
<h3 id="core-components"><a class="header" href="#core-components">Core Components</a></h3>
<p>The Builder pattern typically involves three main components:</p>
<ol>
<li><strong>Product</strong> - The complex object being built</li>
<li><strong>Builder</strong> - The class responsible for constructing the product</li>
<li><strong>Director</strong> (optional) - Controls the sequence of building steps</li>
</ol>
<p><strong>Important</strong>: The Director is not always required - it's an optional component that manages the order of construction steps.</p>
<hr />
<h2 id="advantages-of-the-builder-pattern"><a class="header" href="#advantages-of-the-builder-pattern">Advantages of the Builder Pattern</a></h2>
<h3 id="1-separation-of-responsibilities"><a class="header" href="#1-separation-of-responsibilities">1. Separation of Responsibilities</a></h3>
<p>The pattern achieves clear separation of concerns by isolating the construction logic from the business logic of the object being created.</p>
<h3 id="2-flexible-initialization"><a class="header" href="#2-flexible-initialization">2. Flexible Initialization</a></h3>
<p>Through different options and methods, you can create various initialization variants. The initialization process doesn't have to be linear - it can support multiple alternative configurations.</p>
<h3 id="3-complexity-hiding"><a class="header" href="#3-complexity-hiding">3. Complexity Hiding</a></h3>
<p>If complexity can be hidden and isolated behind the Builder pattern, this is actually beneficial:</p>
<ul>
<li>The complex code can be properly tested in isolation</li>
<li>The main codebase remains clean and simple</li>
<li>Code size increases, but complexity is encapsulated</li>
</ul>
<hr />
<h2 id="disadvantages-of-the-builder-pattern"><a class="header" href="#disadvantages-of-the-builder-pattern">Disadvantages of the Builder Pattern</a></h2>
<h3 id="1-increased-complexity"><a class="header" href="#1-increased-complexity">1. Increased Complexity</a></h3>
<p>Without the Builder pattern there's already complexity, but adding the pattern introduces additional structural complexity.</p>
<h3 id="2-code-size"><a class="header" href="#2-code-size">2. Code Size</a></h3>
<p>Additional classes need to be created (Director, Builder), which means more code to maintain.</p>
<p><strong>However</strong>: If complexity is properly hidden and isolated, and the code is well-tested, the increased code size becomes less of a concern. The benefits of encapsulation often outweigh the cost.</p>
<hr />
<h2 id="classic-implementation-example"><a class="header" href="#classic-implementation-example">Classic Implementation Example</a></h2>
<h3 id="product-class"><a class="header" href="#product-class">Product Class</a></h3>
<p>The product is the object we want to build. In this example, it has three fields:</p>
<pre><code class="language-javascript">class Product {
  constructor() {
    this.field1 = null;
    this.field2 = null;
    this.field3 = null;
  }
}
</code></pre>
<h3 id="abstract-builder"><a class="header" href="#abstract-builder">Abstract Builder</a></h3>
<p>The abstract builder defines the interface for all concrete builders. In classical implementation, it includes:</p>
<ul>
<li>A constructor that throws an exception (cannot be instantiated directly)</li>
<li>Step methods for building (step1, step2, step3)</li>
<li>CreateInstance method for creating the product instance</li>
<li>GetInstance method for retrieving the finished product</li>
</ul>
<pre><code class="language-javascript">class AbstractBuilder {
  constructor() {
    // Cannot be called directly - throws exception
    throw new Error('Abstract class cannot be instantiated');
  }

  step1() {
    throw new Error('Method must be implemented');
  }

  step2() {
    throw new Error('Method must be implemented');
  }

  step3() {
    throw new Error('Method must be implemented');
  }

  createInstance() {
    throw new Error('Method must be implemented');
  }

  getInstance() {
    throw new Error('Method must be implemented');
  }
}
</code></pre>
<h3 id="concrete-builder"><a class="header" href="#concrete-builder">Concrete Builder</a></h3>
<p>The concrete builder inherits from the abstract builder and implements all methods:</p>
<pre><code class="language-javascript">class ConcreteBuilder extends AbstractBuilder {
  constructor() {
    super(); // This won't throw because we're in subclass
    this.instance = null;
  }

  createInstance() {
    // Creates a new product instance
    this.instance = new Product();
    return this;
  }

  step1() {
    // Initialize field1
    this.instance.field1 = 'value1';
    return this;
  }

  step2() {
    // Initialize field2
    this.instance.field2 = 'value2';
    // Could also:
    // - Establish connections
    // - Set up timeouts
    // - Attach callbacks
    // - Any complex initialization
    return this;
  }

  step3() {
    // Initialize field3
    this.instance.field3 = 'value3';
    return this;
  }

  getInstance() {
    // Returns the finished product
    const result = this.instance;
    this.instance = null; // Reset for next build
    return result;
  }
}
</code></pre>
<h3 id="director"><a class="header" href="#director">Director</a></h3>
<p>The Director manages the sequence of building steps:</p>
<pre><code class="language-javascript">class Director {
  constructor(builder) {
    this.builder = builder;
  }

  create() {
    // Orchestrates the building process
    this.builder.createInstance();
    this.builder.step1();
    this.builder.step2();
    this.builder.step3();
    return this.builder.getInstance();
  }
}
</code></pre>
<h3 id="usage---classic-pattern"><a class="header" href="#usage---classic-pattern">Usage - Classic Pattern</a></h3>
<pre><code class="language-javascript">// Create a concrete builder
const builder = new ConcreteBuilder();

// Pass it to the director
const director = new Director(builder);

// Director executes all steps and returns the product
const product = director.create();

// All complexity is hidden during construction
</code></pre>
<p><strong>Note</strong>: While this follows the classical pattern from books (adapted from Java-style examples), JavaScript offers more flexible alternatives due to first-class functions.</p>
<hr />
<h2 id="modern-javascript-approach"><a class="header" href="#modern-javascript-approach">Modern JavaScript Approach</a></h2>
<h3 id="alternative-without-director"><a class="header" href="#alternative-without-director">Alternative Without Director</a></h3>
<p>In JavaScript, with first-class functions, we can simplify the pattern. Steps can be separate functions or procedures that are called sequentially, then combined in a factory function.</p>
<pre><code class="language-javascript">// Simple factory approach
function createProduct(config) {
  const product = new Product();

  // Apply configuration steps
  if (config.field1) product.field1 = config.field1;
  if (config.field2) product.field2 = config.field2;
  if (config.field3) product.field3 = config.field3;

  return product;
}
</code></pre>
<p>This is often simpler and more idiomatic in JavaScript than the full classical pattern.</p>
<hr />
<h2 id="practical-example-query-builder"><a class="header" href="#practical-example-query-builder">Practical Example: Query Builder</a></h2>
<p>A real-world example that demonstrates the Builder pattern is a SQL Query Builder. This example shows how to construct complex SQL queries step by step.</p>
<h3 id="querybuilder-class"><a class="header" href="#querybuilder-class">QueryBuilder Class</a></h3>
<pre><code class="language-javascript">class QueryBuilder {
  constructor(table) {
    // Initialize options object with table and empty clauses
    this.options = {
      table: table,
      fields: '*',
      where: '',
      order: '',
      limit: ''
    };
  }

  // Method to set WHERE clause
  where(conditions) {
    this.options.where = conditions;
    return this; // Return this for method chaining
  }

  // Method to set ORDER BY clause
  order(field) {
    this.options.order = field;
    return this; // Return this for method chaining
  }

  // Method to set LIMIT clause
  limit(count) {
    this.options.limit = count;
    return this; // Return this for method chaining
  }

  // Build and return the final SQL query
  then(resolve, reject) {
    // Extract all accumulated options
    const { table, fields, where, order, limit } = this.options;

    // Build query parts
    let query = `SELECT ${fields} FROM ${table}`;

    if (where) {
      query += ` WHERE ${where}`;
    }

    if (order) {
      query += ` ORDER BY ${order}`;
    }

    if (limit) {
      query += ` LIMIT ${limit}`;
    }

    // Return the complete query
    // In real implementation, this would execute the query
    resolve(query);
  }
}
</code></pre>
<h3 id="key-features"><a class="header" href="#key-features">Key Features</a></h3>
<p><strong>Method Chaining</strong>: Each method returns <code>this</code>, enabling fluent interface:</p>
<pre><code class="language-javascript">builder.where('country = "UA"').order('population').limit(10);
</code></pre>
<p><strong>Thenable Contract</strong>: The class implements a <code>then</code> method, making it compatible with async/await and Promise chains. This means you can use <code>await</code> before the constructor:</p>
<pre><code class="language-javascript">const result = await new QueryBuilder('cities')
  .where('country = "UA"')
  .order('population')
  .limit(10);
</code></pre>
<h3 id="usage-example---method-chaining"><a class="header" href="#usage-example---method-chaining">Usage Example - Method Chaining</a></h3>
<pre><code class="language-javascript">// Using method chaining syntax
const query = await new QueryBuilder('cities')
  .where('country = "UA" AND type = 1')
  .order('population')
  .limit(10);

// Query built:
// "SELECT * FROM cities WHERE country = "UA" AND type = 1 ORDER BY population LIMIT 10"
</code></pre>
<p><strong>Advantages of chaining</strong>:</p>
<ul>
<li>Clean, readable syntax</li>
<li>Each step is explicit</li>
<li>Flexible - can add or remove steps easily</li>
</ul>
<hr />
<h2 id="adding-a-director-to-query-builder"><a class="header" href="#adding-a-director-to-query-builder">Adding a Director to Query Builder</a></h2>
<p>While method chaining is convenient, sometimes we want to pass all options at once (e.g., when receiving JSON from frontend or reading from a file).</p>
<h3 id="director-for-batch-configuration"><a class="header" href="#director-for-batch-configuration">Director for Batch Configuration</a></h3>
<pre><code class="language-javascript">class QueryDirector {
  constructor(builder, options) {
    this.builder = builder;
    this.options = options;
  }

  build() {
    // Apply all options at once
    const { where, order, limit } = this.options;

    if (where) this.builder.where(where);
    if (order) this.builder.order(order);
    if (limit) this.builder.limit(limit);

    return this.builder;
  }
}
</code></pre>
<h3 id="usage-with-director"><a class="header" href="#usage-with-director">Usage with Director</a></h3>
<pre><code class="language-javascript">// Options object (could come from JSON, file, frontend, etc.)
const options = {
  where: 'country = "UA" AND type = 1',
  order: 'population',
  limit: 10
};

// Create builder
const builder = new QueryBuilder('cities');

// Use director to apply all options
const director = new QueryDirector(builder, options);
const query = await director.build();
</code></pre>
<p><strong>Benefits</strong>:</p>
<ul>
<li>Can work with configuration objects</li>
<li>Useful when options come from external sources (JSON, API, files)</li>
<li>Combines well with the chaining approach</li>
</ul>
<hr />
<h2 id="method-chaining-vs-object-configuration"><a class="header" href="#method-chaining-vs-object-configuration">Method Chaining vs Object Configuration</a></h2>
<h3 id="method-chaining-approach"><a class="header" href="#method-chaining-approach">Method Chaining Approach</a></h3>
<pre><code class="language-javascript">const result = await new QueryBuilder('cities')
  .where('country = "UA"')
  .order('population')
  .limit(10);
</code></pre>
<p><strong>Pros</strong>:</p>
<ul>
<li>Very readable and explicit</li>
<li>Fluent, natural syntax</li>
<li>Easy to see the construction steps</li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
<li>Not convenient when you already have an options object</li>
<li>Requires writing each method call separately</li>
</ul>
<h3 id="object-configuration-approach"><a class="header" href="#object-configuration-approach">Object Configuration Approach</a></h3>
<pre><code class="language-javascript">const options = {
  table: 'cities',
  where: 'country = "UA"',
  order: 'population',
  limit: 10
};

// Direct initialization or via Director
const result = await buildQuery(options);
</code></pre>
<p><strong>Pros</strong>:</p>
<ul>
<li>Options can come from external sources (JSON, files, frontend)</li>
<li>Easy to store and transmit configurations</li>
<li>More compact for complex configurations</li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
<li>Less explicit about the building process</li>
<li>Harder to see the construction steps</li>
</ul>
<h3 id="best-practice-support-both"><a class="header" href="#best-practice-support-both">Best Practice: Support Both</a></h3>
<p>A well-designed builder should support both approaches:</p>
<pre><code class="language-javascript">// Chaining when building step by step
const query1 = await new QueryBuilder('cities')
  .where('country = "UA"')
  .limit(10);

// Object when configuration is already available
const query2 = await new QueryBuilder('cities', options);
</code></pre>
<hr />
<h2 id="typescript-example-classic-builder-pattern"><a class="header" href="#typescript-example-classic-builder-pattern">TypeScript Example: Classic Builder Pattern</a></h2>
<p>Here's a comprehensive TypeScript implementation showing the full pattern:</p>
<pre><code class="language-typescript">// Product being built
class Product1 {
  public parts: string[] = [];

  public listParts(): void {
    console.log(`Product parts: ${this.parts.join(', ')}\n`);
  }
}

// Builder interface
interface Builder {
  producePartA(): void;
  producePartB(): void;
  producePartC(): void;
}

// Concrete builder implementation
class ConcreteBuilder1 implements Builder {
  private product: Product1;

  constructor() {
    this.reset();
  }

  public reset(): void {
    this.product = new Product1();
  }

  public producePartA(): void {
    this.product.parts.push('PartA1');
  }

  public producePartB(): void {
    this.product.parts.push('PartB1');
  }

  public producePartC(): void {
    this.product.parts.push('PartC1');
  }

  // Return the product and reset for next build
  public getProduct(): Product1 {
    const result = this.product;
    this.reset();
    return result;
  }
}

// Director class
class Director {
  private builder: Builder;

  public setBuilder(builder: Builder): void {
    this.builder = builder;
  }

  // Build minimal product
  public buildMinimalViableProduct(): void {
    this.builder.producePartA();
  }

  // Build full-featured product
  public buildFullFeaturedProduct(): void {
    this.builder.producePartA();
    this.builder.producePartB();
    this.builder.producePartC();
  }
}
</code></pre>
<h3 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h3>
<pre><code class="language-typescript">// Setup
const director = new Director();
const builder = new ConcreteBuilder1();
director.setBuilder(builder);

// Build minimal product
console.log('Standard basic product:');
director.buildMinimalViableProduct();
builder.getProduct().listParts();
// Output: Product parts: PartA1

// Build full product
console.log('Standard full featured product:');
director.buildFullFeaturedProduct();
builder.getProduct().listParts();
// Output: Product parts: PartA1, PartB1, PartC1

// Custom product (without director)
console.log('Custom product:');
builder.producePartA();
builder.producePartC();
builder.getProduct().listParts();
// Output: Product parts: PartA1, PartC1
</code></pre>
<hr />
<h2 id="real-world-use-cases"><a class="header" href="#real-world-use-cases">Real-World Use Cases</a></h2>
<h3 id="1-http-request-builders"><a class="header" href="#1-http-request-builders">1. HTTP Request Builders</a></h3>
<pre><code class="language-javascript">const request = await new RequestBuilder('https://api.example.com')
  .method('POST')
  .header('Content-Type', 'application/json')
  .body({ user: 'John' })
  .timeout(5000);
</code></pre>
<h3 id="2-documentreport-builders"><a class="header" href="#2-documentreport-builders">2. Document/Report Builders</a></h3>
<pre><code class="language-javascript">const report = new ReportBuilder()
  .title('Monthly Sales Report')
  .section('Summary', summaryData)
  .section('Details', detailsData)
  .footer('Generated: ' + new Date())
  .build();
</code></pre>
<h3 id="3-configuration-builders"><a class="header" href="#3-configuration-builders">3. Configuration Builders</a></h3>
<pre><code class="language-javascript">const config = new ConfigBuilder()
  .database('localhost', 5432)
  .logging('debug')
  .timeout(30000)
  .retries(3)
  .build();
</code></pre>
<h3 id="4-ui-component-builders"><a class="header" href="#4-ui-component-builders">4. UI Component Builders</a></h3>
<pre><code class="language-javascript">const dialog = new DialogBuilder()
  .title('Confirm Action')
  .message('Are you sure?')
  .button('OK', handleOk)
  .button('Cancel', handleCancel)
  .show();
</code></pre>
<hr />
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<ol>
<li>
<p><strong>Purpose</strong>: The Builder pattern separates complex object construction from its representation</p>
</li>
<li>
<p><strong>When to Use</strong>:</p>
<ul>
<li>When constructors become too complex</li>
<li>When you need multiple ways to create an object</li>
<li>When object creation requires many steps</li>
<li>When you want to hide construction complexity</li>
</ul>
</li>
<li>
<p><strong>Components</strong>:</p>
<ul>
<li><strong>Product</strong>: The object being built</li>
<li><strong>Builder</strong>: Constructs the product step by step</li>
<li><strong>Director</strong> (optional): Controls the building sequence</li>
</ul>
</li>
<li>
<p><strong>Benefits</strong>:</p>
<ul>
<li>Encapsulates construction logic</li>
<li>Supports different representations</li>
<li>Provides control over construction process</li>
<li>Enables method chaining for fluent interfaces</li>
</ul>
</li>
<li>
<p><strong>JavaScript Considerations</strong>:</p>
<ul>
<li>First-class functions allow simpler alternatives</li>
<li>Method chaining (<code>return this</code>) creates fluent APIs</li>
<li>Thenable contract enables async/await compatibility</li>
<li>Can support both chaining and object configuration</li>
</ul>
</li>
<li>
<p><strong>Trade-offs</strong>:</p>
<ul>
<li>Increases code size with additional classes</li>
<li>May add complexity to simple cases</li>
<li>Worth it when construction logic is genuinely complex</li>
</ul>
</li>
</ol>
<hr />
<h2 id="common-patterns-with-builder"><a class="header" href="#common-patterns-with-builder">Common Patterns with Builder</a></h2>
<h3 id="fluent-interface-method-chaining"><a class="header" href="#fluent-interface-method-chaining">Fluent Interface (Method Chaining)</a></h3>
<p>Return <code>this</code> from each builder method to enable chaining:</p>
<pre><code class="language-javascript">class FluentBuilder {
  method1() {
    // ... do work
    return this; // Enable chaining
  }

  method2() {
    // ... do work
    return this; // Enable chaining
  }
}

// Usage
const result = new FluentBuilder()
  .method1()
  .method2();
</code></pre>
<h3 id="thenable-pattern"><a class="header" href="#thenable-pattern">Thenable Pattern</a></h3>
<p>Implement <code>then()</code> to make builder work with promises:</p>
<pre><code class="language-javascript">class ThenableBuilder {
  then(resolve, reject) {
    // Build and return final result
    const result = this.build();
    resolve(result);
  }
}

// Usage with await
const result = await new ThenableBuilder().option1().option2();
</code></pre>
<h3 id="reset-pattern"><a class="header" href="#reset-pattern">Reset Pattern</a></h3>
<p>Reset builder state after getting the product for reuse:</p>
<pre><code class="language-javascript">class ReusableBuilder {
  getProduct() {
    const result = this.product;
    this.reset(); // Clear state for next build
    return result;
  }

  reset() {
    this.product = new Product();
  }
}
</code></pre>
<hr />
<h2 id="comparison-with-other-patterns"><a class="header" href="#comparison-with-other-patterns">Comparison with Other Patterns</a></h2>
<h3 id="builder-vs-factory-method"><a class="header" href="#builder-vs-factory-method">Builder vs Factory Method</a></h3>
<ul>
<li><strong>Factory Method</strong>: Creates objects in one step</li>
<li><strong>Builder</strong>: Constructs objects step by step with configuration</li>
</ul>
<h3 id="builder-vs-abstract-factory"><a class="header" href="#builder-vs-abstract-factory">Builder vs Abstract Factory</a></h3>
<ul>
<li><strong>Abstract Factory</strong>: Creates families of related objects</li>
<li><strong>Builder</strong>: Constructs a single complex object with many options</li>
</ul>
<h3 id="builder-vs-prototype"><a class="header" href="#builder-vs-prototype">Builder vs Prototype</a></h3>
<ul>
<li><strong>Prototype</strong>: Clones existing objects</li>
<li><strong>Builder</strong>: Constructs new objects from scratch with specific configuration</li>
</ul>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>The Builder pattern is essential when dealing with complex object construction. While the classical implementation involves abstract builders and directors, modern JavaScript allows for more flexible and simpler approaches using:</p>
<ul>
<li>Method chaining for fluent APIs</li>
<li>First-class functions for step composition</li>
<li>Thenable contract for async compatibility</li>
<li>Hybrid approaches supporting both chaining and object configuration</li>
</ul>
<p>The key is to balance between following the pattern formally and adapting it to JavaScript's strengths, always keeping the code maintainable, testable, and easy to use.</p>
<p><strong>Remember</strong>: Use the Builder pattern when construction logic is genuinely complex. For simple cases, a regular constructor or factory function is often sufficient and more appropriate.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../week3/decomposition-aggregation-composition-lecture-notes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../week3/prototype-pattern-lecture-notes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../week3/decomposition-aggregation-composition-lecture-notes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../week3/prototype-pattern-lecture-notes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
