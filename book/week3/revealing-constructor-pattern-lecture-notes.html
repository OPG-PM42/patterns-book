<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Паттерн Revealing Constructor - открытый конструктор - Patterns</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Patterns</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Паттерн-revealing-constructor-Открытый-конструктор"><a class="header" href="#Паттерн-revealing-constructor-Открытый-конструктор">Паттерн Revealing Constructor (Открытый конструктор)</a></h1>
<h2 id="Обзор"><a class="header" href="#Обзор">Обзор</a></h2>
<p>Паттерн <strong>Revealing Constructor</strong> (Открытый конструктор) — это паттерн проектирования, который позволяет инициализировать объект через функцию, передаваемую в конструктор. Этот паттерн необходим для понимания работы Promise и построения более сложных абстракций для работы с асинхронностью, таких как паттерн Future (без состояния и многоразовый, в отличие от Promise).</p>
<p><strong>Основная идея:</strong> Функция попадает в конструктор и инициализирует экземпляр объекта, изменяя его поведение или внедряя зависимости.</p>
<hr />
<h2 id="Три-способа-передачи-значений-в-функцию"><a class="header" href="#Три-способа-передачи-значений-в-функцию">Три способа передачи значений в функцию</a></h2>
<p>Прежде чем перейти к паттерну, рассмотрим три различных способа передачи значений внутрь функции:</p>
<h3 id="Пример-Различные-способы-передачи-данных"><a class="header" href="#Пример-Различные-способы-передачи-данных">Пример: Различные способы передачи данных</a></h3>
<pre><code class="language-javascript">// Три способа передачи значений
const example = (x, y, z) =&gt; {
  // 1. Константа - прямое значение
  console.log(x); // Обращаемся напрямую к переменной

  // 2. Функция, возвращающая константу
  console.log(y()); // Вызываем функцию для получения значения

  // 3. Callback-функция
  z((value) =&gt; {
    console.log(value); // Значение приходит через callback
  });
};

// Вызов с различными типами аргументов
example(
  5,                    // 1. Просто константа
  () =&gt; 10,            // 2. Функция, возвращающая значение
  (callback) =&gt; {      // 3. Функция, принимающая callback
    callback(15);
  }
);
</code></pre>
<p><strong>Вывод:</strong></p>
<ul>
<li><strong>Первый способ (константа):</strong> Самый простой, значение передаётся напрямую</li>
<li><strong>Второй способ (функция):</strong> Позволяет отложить вычисление значения</li>
<li><strong>Третий способ (callback):</strong> Позволяет асинхронно вернуть значение в будущем</li>
</ul>
<hr />
<h2 id="Применение-паттерна-в-promise"><a class="header" href="#Применение-паттерна-в-promise">Применение паттерна в Promise</a></h2>
<p>Именно <strong>третий способ</strong> (callback) используется в конструкторе Promise и является примером паттерна Revealing Constructor.</p>
<h3 id="Пример-promise-с-revealing-constructor"><a class="header" href="#Пример-promise-с-revealing-constructor">Пример: Promise с Revealing Constructor</a></h3>
<pre><code class="language-javascript">// Promise использует паттерн Revealing Constructor
const promise1 = new Promise((resolve, reject) =&gt; {
  // Сразу разрешаем промис
  resolve(5);
});

const promise2 = new Promise((resolve, reject) =&gt; {
  // Ждём секунду, затем разрешаем
  setTimeout(() =&gt; {
    resolve(5);
  }, 1000);
});

// Первый слушатель - навешивается ДО разрешения промиса
promise2.then((x) =&gt; {
  console.log('First listener:', x);
});

// Ждём 1.5 секунды
setTimeout(() =&gt; {
  // Второй слушатель - навешивается ПОСЛЕ разрешения промиса
  promise2.then((y) =&gt; {
    console.log('Second listener:', y);
  });
}, 1500);

console.log(promise2); // Promise { &lt;pending&gt; }
</code></pre>
<p><strong>Результат выполнения:</strong></p>
<pre><code>Promise { &lt;pending&gt; }
First listener: 5
Second listener: 5
</code></pre>
<h3 id="Почему-promise-нужен-именно-callback"><a class="header" href="#Почему-promise-нужен-именно-callback">Почему Promise нужен именно callback?</a></h3>
<p><strong>Ключевой момент:</strong> Если бы в Promise передавали просто константу или функцию, возвращающую константу, мы не смогли бы:</p>
<ol>
<li><strong>Отложить разрешение промиса</strong> (подождать секунду в примере выше)</li>
<li><strong>Переводить промис из состояния pending</strong> в resolved или rejected</li>
<li><strong>Подписываться на значение до и после его разрешения</strong></li>
</ol>
<pre><code class="language-javascript">// ❌ Это НЕ сработало бы:
const badPromise = new Promise(() =&gt; {
  return 5; // return сразу вернул бы значение,
            // не дав возможности асинхронно разрешить промис
});

// ✅ Правильный способ - через callback (resolve/reject):
const goodPromise = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(5); // Асинхронное разрешение через callback
  }, 1000);
});
</code></pre>
<hr />
<h2 id="Применение-паттерна-в-nodejs-streams"><a class="header" href="#Применение-паттерна-в-nodejs-streams">Применение паттерна в Node.js Streams</a></h2>
<p>Паттерн Revealing Constructor широко используется в стримах Node.js, позволяя избежать наследования классов.</p>
<h3 id="Традиционный-подход-Наследование-через-extends"><a class="header" href="#Традиционный-подход-Наследование-через-extends">Традиционный подход: Наследование через extends</a></h3>
<pre><code class="language-javascript">const { Readable } = require('node:stream');

// Создаём класс RandomStream, наследуясь от Readable
class RandomStream extends Readable {
  _read(size) {
    // Генерируем массив случайных байтов нужной длины
    const chunk = Buffer.allocUnsafe(size)
      .map(() =&gt; Math.floor(Math.random() * 256));

    // Преобразуем в шестнадцатеричную строку
    const hexString = chunk.toString('hex');

    // Отправляем данные в буфер стрима
    this.push(hexString);
  }
}

// Использование
const randomStream = new RandomStream();
randomStream.on('data', (chunk) =&gt; {
  console.log(chunk);
});
</code></pre>
<h3 id="Современный-подход-revealing-constructor"><a class="header" href="#Современный-подход-revealing-constructor">Современный подход: Revealing Constructor</a></h3>
<pre><code class="language-javascript">const { Readable } = require('node:stream');

// Создаём Readable stream БЕЗ наследования
const randomStream = new Readable({
  read(size) {
    // Генерируем массив случайных байтов
    const chunk = Buffer.allocUnsafe(size)
      .map(() =&gt; Math.floor(Math.random() * 256));

    // Преобразуем в шестнадцатеричную строку
    const hexString = chunk.toString('hex');

    // Отправляем данные в буфер
    this.push(hexString);
  }
});

// Использование точно такое же
randomStream.on('data', (chunk) =&gt; {
  console.log(chunk);
});
</code></pre>
<p><strong>Преимущества Revealing Constructor в стримах:</strong></p>
<ol>
<li><strong>Нет необходимости создавать отдельный класс</strong></li>
<li><strong>Более компактный код</strong></li>
<li><strong>Внедрение зависимостей</strong> - метод <code>read</code> инжектится внутрь экземпляра Readable</li>
<li><strong>Именно так реализованы стримы в стандартной библиотеке Node.js</strong></li>
</ol>
<h3 id="Практический-пример-pipe-в-stdout"><a class="header" href="#Практический-пример-pipe-в-stdout">Практический пример: Pipe в stdout</a></h3>
<pre><code class="language-javascript">const { Readable } = require('node:stream');

const randomStream = new Readable({
  read(size) {
    const chunk = Buffer.allocUnsafe(size)
      .map(() =&gt; Math.floor(Math.random() * 256));
    this.push(chunk.toString('hex') + '\n');
  }
});

// Pipe в stdout для бесконечного вывода случайных чисел
randomStream.pipe(process.stdout);
// Генерирует и выводит бесконечный поток случайных hex-строк
</code></pre>
<p><strong>Почему это работает:</strong></p>
<ul>
<li>Как только происходит <code>pipe</code>, Readable начинает вызывать метод <code>read</code></li>
<li>Метод <code>read</code> генерирует данные и пушит их в буфер через <code>this.push()</code></li>
<li>Данные автоматически передаются в Writable stream (stdout)</li>
</ul>
<hr />
<h2 id="Другие-типы-стримов-с-revealing-constructor"><a class="header" href="#Другие-типы-стримов-с-revealing-constructor">Другие типы стримов с Revealing Constructor</a></h2>
<h3 id="transform-stream"><a class="header" href="#transform-stream">Transform Stream</a></h3>
<h4 id="Традиционный-подход-с-наследованием"><a class="header" href="#Традиционный-подход-с-наследованием">Традиционный подход с наследованием:</a></h4>
<pre><code class="language-javascript">const { Transform } = require('node:stream');

// Стрим, который делает все буквы заглавными
class UpperCaseTransform extends Transform {
  _transform(chunk, encoding, callback) {
    // Преобразуем chunk в заглавные буквы
    const upperChunk = chunk.toString().toUpperCase();
    // Передаём результат дальше
    callback(null, upperChunk);
  }
}

// Использование
const upperTransform = new UpperCaseTransform();
process.stdin
  .pipe(upperTransform)
  .pipe(process.stdout);
</code></pre>
<h4 id="revealing-constructor-подход"><a class="header" href="#revealing-constructor-подход">Revealing Constructor подход:</a></h4>
<pre><code class="language-javascript">const { Transform } = require('node:stream');

// Создаём Transform stream без наследования
const upperTransform = new Transform({
  transform(chunk, encoding, callback) {
    // Преобразуем chunk в заглавные буквы
    const upperChunk = chunk.toString().toUpperCase();
    // Передаём результат дальше
    callback(null, upperChunk);
  }
});

// Использование - абсолютно идентично
process.stdin
  .pipe(upperTransform)
  .pipe(process.stdout);
</code></pre>
<h3 id="writable-stream"><a class="header" href="#writable-stream">Writable Stream</a></h3>
<pre><code class="language-javascript">const { Writable } = require('node:stream');

// Создаём Writable stream через Revealing Constructor
const myWritable = new Writable({
  write(chunk, encoding, callback) {
    console.log('Received:', chunk.toString());
    callback(); // Сигнализируем о завершении записи
  }
});
</code></pre>
<h3 id="duplex-stream"><a class="header" href="#duplex-stream">Duplex Stream</a></h3>
<pre><code class="language-javascript">const { Duplex } = require('node:stream');

// Для Duplex нужно определить и read, и write
const myDuplex = new Duplex({
  read(size) {
    // Логика чтения
    this.push('data');
  },
  write(chunk, encoding, callback) {
    // Логика записи
    console.log(chunk.toString());
    callback();
  }
});
</code></pre>
<hr />
<h2 id="Создание-собственных-абстракций-с-revealing-constructor"><a class="header" href="#Создание-собственных-абстракций-с-revealing-constructor">Создание собственных абстракций с Revealing Constructor</a></h2>
<p>Паттерн можно использовать не только для Promise и стримов, но и для создания собственных абстракций.</p>
<h3 id="Пример-Класс-timer"><a class="header" href="#Пример-Класс-timer">Пример: Класс Timer</a></h3>
<pre><code class="language-javascript">class Timer {
  constructor(interval, listener) {
    this.interval = interval;  // Интервал в миллисекундах
    this.listener = listener;  // Функция-обработчик
    this.timerId = null;       // ID таймера
  }

  start() {
    // Запускаем setInterval с переданной функцией
    this.timerId = setInterval(this.listener, this.interval);
  }

  stop() {
    // Останавливаем таймер
    if (this.timerId) {
      clearInterval(this.timerId);
      this.timerId = null;
    }
  }
}

// Использование
const timer = new Timer(1000, () =&gt; {
  console.log('Timer event');
});

timer.start(); // Начинаем вызов каждую секунду

setTimeout(() =&gt; {
  timer.stop(); // Останавливаем через 5 секунд
}, 5000);
</code></pre>
<p><strong>Результат выполнения:</strong></p>
<pre><code>Timer event
Timer event
Timer event
Timer event
</code></pre>
<p>(4 события за ~5 секунд)</p>
<p><strong>Особенности паттерна в Timer:</strong></p>
<ul>
<li>Функция <code>listener</code> передаётся в конструктор</li>
<li>Хранится внутри экземпляра объекта</li>
<li>Используется вместо метода, который можно было бы переопределить</li>
<li>Изменяет поведение базового функционала (setInterval)</li>
</ul>
<hr />
<h2 id="Различные-формы-передачи-функций-в-revealing-constructor"><a class="header" href="#Различные-формы-передачи-функций-в-revealing-constructor">Различные формы передачи функций в Revealing Constructor</a></h2>
<h3 id="Форма-1-Прямая-передача-функции-promise-timer"><a class="header" href="#Форма-1-Прямая-передача-функции-promise-timer">Форма 1: Прямая передача функции (Promise, Timer)</a></h3>
<pre><code class="language-javascript">// Promise
new Promise((resolve, reject) =&gt; {
  // resolve и reject - это callbacks
});

// Timer
new Timer(1000, () =&gt; {
  // Функция передаётся напрямую
});
</code></pre>
<h3 id="Форма-2-Передача-через-объект-streams"><a class="header" href="#Форма-2-Передача-через-объект-streams">Форма 2: Передача через объект (Streams)</a></h3>
<pre><code class="language-javascript">// Readable Stream
new Readable({
  read(size) {
    // Функция передаётся как метод объекта
  }
});

// Transform Stream
new Transform({
  transform(chunk, encoding, callback) {
    // Именованная функция в объекте
  }
});

// Duplex Stream
new Duplex({
  read(size) { /* ... */ },
  write(chunk, encoding, callback) { /* ... */ }
});
</code></pre>
<hr />
<h2 id="Ключевые-концепции-паттерна"><a class="header" href="#Ключевые-концепции-паттерна">Ключевые концепции паттерна</a></h2>
<h3 id="1-Внедрение-зависимостей-dependency-injection"><a class="header" href="#1-Внедрение-зависимостей-dependency-injection">1. Внедрение зависимостей (Dependency Injection)</a></h3>
<p>Revealing Constructor очень похож на внедрение зависимостей, только:</p>
<ul>
<li><strong>Внедряется одна или несколько функций</strong> внутрь экземпляра</li>
<li><strong>Функции изменяют поведение</strong> базового класса</li>
<li><strong>Альтернатива наследованию</strong> классов</li>
</ul>
<pre><code class="language-javascript">// Вместо наследования:
class MyStream extends Readable {
  _read(size) { /* ... */ }
}

// Используем внедрение через конструктор:
const myStream = new Readable({
  read(size) { /* ... */ }
});
</code></pre>
<h3 id="2-Инициализация-состояния-объекта"><a class="header" href="#2-Инициализация-состояния-объекта">2. Инициализация состояния объекта</a></h3>
<p>Переданная функция может:</p>
<ul>
<li>Изменять внутреннее состояние объекта</li>
<li>Переводить объект из одного состояния в другое (pending → fulfilled/rejected в Promise)</li>
<li>Управлять жизненным циклом объекта</li>
</ul>
<h3 id="3-Асинхронное-управление"><a class="header" href="#3-Асинхронное-управление">3. Асинхронное управление</a></h3>
<p>Паттерн позволяет:</p>
<ul>
<li>Откладывать выполнение операций</li>
<li>Работать с асинхронными операциями</li>
<li>Подписываться на события до и после их наступления</li>
</ul>
<hr />
<h2 id="Преимущества-паттерна"><a class="header" href="#Преимущества-паттерна">Преимущества паттерна</a></h2>
<h3 id="1-Инкапсуляция"><a class="header" href="#1-Инкапсуляция">1. Инкапсуляция</a></h3>
<pre><code class="language-javascript">// Внутренние методы (resolve/reject) доступны
// только внутри функции-конструктора
new Promise((resolve, reject) =&gt; {
  // resolve и reject доступны ТОЛЬКО здесь
  setTimeout(() =&gt; resolve(42), 1000);
});

// Снаружи нельзя напрямую вызвать resolve или reject
</code></pre>
<h3 id="2-Гибкость"><a class="header" href="#2-Гибкость">2. Гибкость</a></h3>
<pre><code class="language-javascript">// Можно передать любую логику инициализации
const stream1 = new Readable({
  read() { this.push('simple data'); }
});

const stream2 = new Readable({
  read(size) {
    // Сложная логика с асинхронными операциями
    fetchData().then(data =&gt; this.push(data));
  }
});
</code></pre>
<h3 id="3-Избежание-наследования"><a class="header" href="#3-Избежание-наследования">3. Избежание наследования</a></h3>
<pre><code class="language-javascript">// Не нужно создавать класс для каждого случая
// Плохо:
class SimpleReadable extends Readable { _read() { /* ... */ } }
class ComplexReadable extends Readable { _read() { /* ... */ } }
class AnotherReadable extends Readable { _read() { /* ... */ } }

// Хорошо:
const simple = new Readable({ read() { /* ... */ } });
const complex = new Readable({ read() { /* ... */ } });
const another = new Readable({ read() { /* ... */ } });
</code></pre>
<h3 id="4-Контроль-доступа"><a class="header" href="#4-Контроль-доступа">4. Контроль доступа</a></h3>
<pre><code class="language-javascript">// Promise открывает только resolve/reject внутри конструктора
// но не даёт доступ к ним извне
const promise = new Promise((resolve, reject) =&gt; {
  // Только здесь можно управлять состоянием
  setTimeout(() =&gt; resolve('done'), 1000);
});

// promise.resolve() - ❌ Такого метода нет!
// promise.reject()  - ❌ Такого метода нет!
</code></pre>
<hr />
<h2 id="Сравнение-подходов"><a class="header" href="#Сравнение-подходов">Сравнение подходов</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Аспект</th><th>Наследование (extends)</th><th>Revealing Constructor</th></tr></thead><tbody>
<tr><td><strong>Создание класса</strong></td><td>Требуется</td><td>Не требуется</td></tr>
<tr><td><strong>Многословность</strong></td><td>Больше кода</td><td>Компактнее</td></tr>
<tr><td><strong>Переиспользование</strong></td><td>Через иерархию классов</td><td>Через композицию функций</td></tr>
<tr><td><strong>Гибкость</strong></td><td>Ограничена иерархией</td><td>Высокая</td></tr>
<tr><td><strong>Инкапсуляция</strong></td><td>Через приватные поля</td><td>Через замыкания</td></tr>
</tbody></table>
</div>
<h3 id="Пример-сравнения-для-стримов"><a class="header" href="#Пример-сравнения-для-стримов">Пример сравнения для стримов:</a></h3>
<pre><code class="language-javascript">// Подход 1: Наследование (многословно)
class RandomStream extends Readable {
  constructor(options) {
    super(options);
  }
  _read(size) {
    const chunk = Buffer.allocUnsafe(size)
      .map(() =&gt; Math.floor(Math.random() * 256));
    this.push(chunk.toString('hex'));
  }
}
const stream1 = new RandomStream();

// Подход 2: Revealing Constructor (компактно)
const stream2 = new Readable({
  read(size) {
    const chunk = Buffer.allocUnsafe(size)
      .map(() =&gt; Math.floor(Math.random() * 256));
    this.push(chunk.toString('hex'));
  }
});
</code></pre>
<hr />
<h2 id="Применение-в-реальных-проектах"><a class="header" href="#Применение-в-реальных-проектах">Применение в реальных проектах</a></h2>
<h3 id="1-promise-api"><a class="header" href="#1-promise-api">1. Promise API</a></h3>
<p>Все промисы используют этот паттерн:</p>
<pre><code class="language-javascript">// Работа с файлами
const filePromise = new Promise((resolve, reject) =&gt; {
  fs.readFile('file.txt', (err, data) =&gt; {
    if (err) reject(err);
    else resolve(data);
  });
});

// HTTP запросы
const httpPromise = new Promise((resolve, reject) =&gt; {
  http.get('http://api.example.com', (res) =&gt; {
    let data = '';
    res.on('data', chunk =&gt; data += chunk);
    res.on('end', () =&gt; resolve(data));
    res.on('error', reject);
  });
});
</code></pre>
<h3 id="2-nodejs-streams"><a class="header" href="#2-nodejs-streams">2. Node.js Streams</a></h3>
<p>Стандартная библиотека Node.js реализует все типы стримов с поддержкой Revealing Constructor:</p>
<pre><code class="language-javascript">const { Readable, Writable, Transform, Duplex } = require('node:stream');

// Все эти конструкторы принимают объекты с функциями
const r = new Readable({ read() { /* ... */ } });
const w = new Writable({ write() { /* ... */ } });
const t = new Transform({ transform() { /* ... */ } });
const d = new Duplex({ read() { /* ... */ }, write() { /* ... */ } });
</code></pre>
<h3 id="3-custom-event-emitters"><a class="header" href="#3-custom-event-emitters">3. Custom Event Emitters</a></h3>
<pre><code class="language-javascript">class Emitter {
  constructor(listener) {
    this.listener = listener;
    this.events = {};
  }

  emit(event, data) {
    if (this.listener) {
      this.listener(event, data);
    }
  }
}

const emitter = new Emitter((event, data) =&gt; {
  console.log(`Event ${event}:`, data);
});

emitter.emit('message', 'Hello!');
</code></pre>
<hr />
<h2 id="Связь-с-паттерном-future"><a class="header" href="#Связь-с-паттерном-future">Связь с паттерном Future</a></h2>
<p>Паттерн Revealing Constructor будет использован для создания паттерна <strong>Future</strong> в следующей лекции:</p>
<p><strong>Отличия Future от Promise:</strong></p>
<ul>
<li><strong>Без состояния</strong> (stateless)</li>
<li><strong>Многоразовый</strong> (можно использовать повторно)</li>
<li><strong>Из функционального программирования</strong></li>
<li><strong>Компонуемый</strong> (легко комбинируется)</li>
</ul>
<pre><code class="language-javascript">// Пример концепции (упрощённо)
class Future {
  constructor(computation) {
    this.computation = computation; // Сохраняем вычисление
  }

  fork(reject, resolve) {
    // Каждый раз запускаем вычисление заново
    this.computation(reject, resolve);
  }
}

// Future можно запустить многократно
const future = new Future((reject, resolve) =&gt; {
  setTimeout(() =&gt; resolve(42), 1000);
});

future.fork(console.error, console.log); // Первый запуск
future.fork(console.error, console.log); // Второй запуск
</code></pre>
<hr />
<h2 id="Практические-рекомендации"><a class="header" href="#Практические-рекомендации">Практические рекомендации</a></h2>
<h3 id="Когда-использовать-revealing-constructor"><a class="header" href="#Когда-использовать-revealing-constructor">Когда использовать Revealing Constructor</a></h3>
<p>✅ <strong>Используйте когда:</strong></p>
<ul>
<li>Нужно внедрить поведение в конструктор объекта</li>
<li>Требуется инкапсулировать внутренние методы</li>
<li>Хотите избежать создания множества классов через наследование</li>
<li>Работаете с асинхронными операциями</li>
<li>Нужно управлять состоянием объекта извне конструктора</li>
</ul>
<p>❌ <strong>Не используйте когда:</strong></p>
<ul>
<li>Логика слишком сложная для одной функции</li>
<li>Нужна полноценная иерархия классов</li>
<li>Требуется множественное наследование поведения</li>
<li>Важна типизация и IDE поддержка (без TypeScript)</li>
</ul>
<h3 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h3>
<pre><code class="language-javascript">// ✅ Хорошо: Явные имена параметров
new Promise((resolve, reject) =&gt; {
  // Понятно, что делают эти функции
});

// ✅ Хорошо: Документированные методы объекта
new Readable({
  read(size) {
    // size - понятный параметр
  }
});

// ❌ Плохо: Неясные имена
new SomeClass((a, b) =&gt; {
  // Что такое a и b?
});

// ✅ Хорошо: Обработка ошибок
new Promise((resolve, reject) =&gt; {
  try {
    // ... операция
    resolve(result);
  } catch (error) {
    reject(error);
  }
});
</code></pre>
<hr />
<h2 id="Резюме"><a class="header" href="#Резюме">Резюме</a></h2>
<h3 id="Основные-концепции"><a class="header" href="#Основные-концепции">Основные концепции</a></h3>
<ol>
<li><strong>Revealing Constructor</strong> - паттерн, при котором функция передаётся в конструктор для инициализации объекта</li>
<li><strong>Три способа передачи данных</strong>: константа, функция возвращающая значение, callback-функция</li>
<li><strong>Promise использует Revealing Constructor</strong> для управления состоянием (resolve/reject)</li>
<li><strong>Node.js Streams</strong> используют этот паттерн для внедрения методов read/write/transform</li>
<li><strong>Альтернатива наследованию</strong> - можно избежать создания классов</li>
</ol>
<h3 id="Ключевые-преимущества"><a class="header" href="#Ключевые-преимущества">Ключевые преимущества</a></h3>
<ul>
<li>✅ Инкапсуляция внутренних методов</li>
<li>✅ Гибкость в настройке поведения</li>
<li>✅ Компактный код без наследования</li>
<li>✅ Внедрение зависимостей через конструктор</li>
<li>✅ Поддержка асинхронных операций</li>
</ul>
<h3 id="Области-применения"><a class="header" href="#Области-применения">Области применения</a></h3>
<ul>
<li>Promise API</li>
<li>Node.js Streams (Readable, Writable, Transform, Duplex)</li>
<li>Custom таймеры и планировщики</li>
<li>Event Emitters</li>
<li>Паттерн Future (следующая тема)</li>
</ul>
<h3 id="Следующие-шаги"><a class="header" href="#Следующие-шаги">Следующие шаги</a></h3>
<p>В следующей лекции мы построим паттерн <strong>Future</strong> на основе Revealing Constructor:</p>
<ul>
<li>Без состояния (в отличие от Promise)</li>
<li>Многоразовый</li>
<li>Из функционального программирования</li>
<li>Для работы с асинхронностью</li>
</ul>
<hr />
<h2 id="Дополнительные-примеры-для-практики"><a class="header" href="#Дополнительные-примеры-для-практики">Дополнительные примеры для практики</a></h2>
<h3 id="Пример-1-observable-подобный-класс"><a class="header" href="#Пример-1-observable-подобный-класс">Пример 1: Observable-подобный класс</a></h3>
<pre><code class="language-javascript">class Observable {
  constructor(subscriber) {
    this.subscriber = subscriber;
  }

  subscribe(observer) {
    return this.subscriber(observer);
  }
}

// Использование
const observable = new Observable((observer) =&gt; {
  let count = 0;
  const interval = setInterval(() =&gt; {
    observer.next(count++);
    if (count &gt; 5) {
      observer.complete();
      clearInterval(interval);
    }
  }, 1000);

  // Функция отписки
  return () =&gt; clearInterval(interval);
});

const unsubscribe = observable.subscribe({
  next: (value) =&gt; console.log('Value:', value),
  complete: () =&gt; console.log('Complete!')
});
</code></pre>
<h3 id="Пример-2-retry-механизм"><a class="header" href="#Пример-2-retry-механизм">Пример 2: Retry механизм</a></h3>
<pre><code class="language-javascript">class Retryable {
  constructor(operation, maxRetries = 3) {
    this.operation = operation;
    this.maxRetries = maxRetries;
  }

  async execute() {
    let lastError;
    for (let attempt = 0; attempt &lt; this.maxRetries; attempt++) {
      try {
        return await new Promise(this.operation);
      } catch (error) {
        lastError = error;
        console.log(`Attempt ${attempt + 1} failed:`, error.message);
      }
    }
    throw lastError;
  }
}

// Использование
const unreliableOperation = new Retryable((resolve, reject) =&gt; {
  if (Math.random() &lt; 0.7) {
    reject(new Error('Random failure'));
  } else {
    resolve('Success!');
  }
}, 5);

unreliableOperation.execute()
  .then(result =&gt; console.log(result))
  .catch(error =&gt; console.error('Failed after retries:', error));
</code></pre>
<h3 id="Пример-3-debounced-stream"><a class="header" href="#Пример-3-debounced-stream">Пример 3: Debounced Stream</a></h3>
<pre><code class="language-javascript">const { Transform } = require('node:stream');

function createDebouncedStream(delay) {
  let timeoutId = null;
  let bufferedChunk = null;

  return new Transform({
    transform(chunk, encoding, callback) {
      // Сбрасываем предыдущий таймер
      if (timeoutId) {
        clearTimeout(timeoutId);
      }

      // Буферизуем chunk
      bufferedChunk = chunk;

      // Устанавливаем новый таймер
      timeoutId = setTimeout(() =&gt; {
        this.push(bufferedChunk);
        callback();
      }, delay);
    },

    flush(callback) {
      // Отправляем последний chunk при завершении
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      if (bufferedChunk) {
        this.push(bufferedChunk);
      }
      callback();
    }
  });
}

// Использование
const debouncedStream = createDebouncedStream(500);
process.stdin
  .pipe(debouncedStream)
  .pipe(process.stdout);
</code></pre>
<hr />
<h2 id="Контрольные-вопросы"><a class="header" href="#Контрольные-вопросы">Контрольные вопросы</a></h2>
<ol>
<li>В чём основное отличие между передачей константы и callback-функции в конструктор?</li>
<li>Почему Promise не может использовать простую функцию вместо callback для инициализации?</li>
<li>Какие преимущества даёт Revealing Constructor по сравнению с наследованием классов?</li>
<li>Приведите три примера использования этого паттерна в стандартной библиотеке Node.js</li>
<li>Как Revealing Constructor связан с паттерном Dependency Injection?</li>
</ol>
<hr />
<p><strong>Автор конспекта:</strong> Создано на основе лекции о паттерне Revealing Constructor
<strong>Тема курса:</strong> Паттерны проектирования в Node.js и JavaScript
<strong>Следующая тема:</strong> Паттерн Future для работы с асинхронностью</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../week3/flyweight-pattern-lecture-notes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../week4.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../week3/flyweight-pattern-lecture-notes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../week4.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
