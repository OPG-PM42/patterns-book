<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Паттерн Actor — асинхронное программирование - Patterns</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Patterns</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Паттерн-actor--безопасное-управление-состоянием-в-асинхронном-коде"><a class="header" href="#Паттерн-actor--безопасное-управление-состоянием-в-асинхронном-коде">Паттерн Actor — безопасное управление состоянием в асинхронном коде</a></h1>
<hr />
<h2 id="Введение"><a class="header" href="#Введение">Введение</a></h2>
<p>Паттерн Actor (Актор) решает одну из наиболее коварных проблем асинхронного
программирования: гонки данных (data races). В отличие от многопоточных языков (C++, Java),
в JavaScript нет разделяемой памяти между потоками выполнения (за исключением
<code>SharedArrayBuffer</code>). Тем не менее гонки данных в JavaScript реальны и проявляются
в асинхронном коде при параллельных вызовах функций, работающих с общим состоянием.</p>
<hr />
<h2 id="31-Проблема-гонки-данных-в-асинхронном-javascript"><a class="header" href="#31-Проблема-гонки-данных-в-асинхронном-javascript">3.1 Проблема: гонки данных в асинхронном JavaScript</a></h2>
<pre><code class="language-javascript">// Пример 18. Демонстрация гонки данных — ОПАСНЫЙ КОД (антипаттерн)
//
// Задача: склад с 5 единицами товара (артикул 1722).
// Три одновременных заказа по 2 единицы.
// Ожидаемый результат: первые два заказа выполнены, третий отклонён.
// Реальный результат: все три проходят, счётчик уходит в -1.
//
// Почему: каждый buy() читает стейт ДО того, как другие buy() успели его изменить.
// Event Loop — не защита от гонок. Он предотвращает параллельное ВЫПОЛНЕНИЕ,
// но не параллельное ЧЕРЕДОВАНИЕ асинхронных операций.

'use strict';

// Состояние склада
const warehouseState = { 1722: 5 };

// Имитация асинхронных бизнес-операций

async function checkAvailability(order, state) {
  // Имитируем запрос к БД
  await new Promise((r) =&gt; setTimeout(r, Math.random() * 10));
  if (state[order.lot] &lt; order.qty) {
    throw new Error(`Недостаточно товара: есть ${state[order.lot]}, запрошено ${order.qty}`);
  }
  console.log(`[${order.id}] Проверка наличия ОК: ${state[order.lot]} &gt;= ${order.qty}`);
}

async function processPayment(order) {
  await new Promise((r) =&gt; setTimeout(r, Math.random() * 15));
  console.log(`[${order.id}] Платёж проведён на сумму ${order.qty * 1000} руб.`);
}

async function shiftGoods(order, state) {
  await new Promise((r) =&gt; setTimeout(r, Math.random() * 5));
  state[order.lot] -= order.qty;
  console.log(`[${order.id}] Товар списан. Остаток: ${state[order.lot]}`);
}

async function sendNotification(order) {
  await new Promise((r) =&gt; setTimeout(r, 5));
  console.log(`[${order.id}] Уведомление отправлено`);
}

// Функция бизнес-логики покупки
async function buy(order, state) {
  await checkAvailability(order, state); // &lt;- ТОЧКА ГОНКИ: читаем стейт
  await processPayment(order);           // &lt;- другие buy() тоже дошли сюда
  await shiftGoods(order, state);        // &lt;- все три декрементируют!
  await sendNotification(order);
}

// Три одновременных заказа
const orders = [
  { id: 'ORDER-1', lot: 1722, qty: 2 },
  { id: 'ORDER-2', lot: 1722, qty: 2 },
  { id: 'ORDER-3', lot: 1722, qty: 2 },
];

async function runRace() {
  console.log('=== ДЕМОНСТРАЦИЯ ГОНКИ ДАННЫХ ===');
  console.log(`Начальный остаток: ${warehouseState[1722]}\n`);

  // Запускаем все три одновременно через setTimeout с одинаковой задержкой
  // Это имитирует три HTTP-запроса, поступивших в одно время
  const promises = orders.map(
    (order) =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(buy(order, warehouseState)), 0))
  );

  const results = await Promise.allSettled(promises);

  console.log('\n=== РЕЗУЛЬТАТ ===');
  results.forEach((result, i) =&gt; {
    if (result.status === 'fulfilled') {
      console.log(`ORDER-${i + 1}: ВЫПОЛНЕН`);
    } else {
      console.log(`ORDER-${i + 1}: ОШИБКА — ${result.reason.message}`);
    }
  });

  // ПРОБЛЕМА: финальный остаток может быть отрицательным!
  console.log(`\nФинальный остаток: ${warehouseState[1722]}`);
  console.log('(Ожидалось: 1, может быть -1 или другое отрицательное число)');
}

runRace();
</code></pre>
<p><strong>Разбор механизма гонки:</strong></p>
<p>Event Loop в JavaScript однопоточный — два колбэка не выполняются буквально одновременно.
Однако <code>async/await</code> — это синтаксический сахар над промисами, которые ставятся в очередь
микрозадач. Последовательность выполнения:</p>
<ol>
<li><code>ORDER-1.buy()</code> → <code>checkAvailability()</code> — видит остаток 5, ОК</li>
<li><code>ORDER-2.buy()</code> → <code>checkAvailability()</code> — видит остаток 5, ОК (декремент ещё не произошёл!)</li>
<li><code>ORDER-3.buy()</code> → <code>checkAvailability()</code> — видит остаток 5, ОК</li>
<li>Все три прошли проверку и перешли к <code>processPayment</code></li>
<li>Все три прошли к <code>shiftGoods</code> и каждый уменьшил остаток на 2</li>
<li>Итог: 5 - 2 - 2 - 2 = -1</li>
</ol>
<hr />
<h2 id="32-Решение-Паттерн-actor"><a class="header" href="#32-Решение-Паттерн-actor">3.2 Решение: Паттерн Actor</a></h2>
<pre><code class="language-javascript">// Пример 19. Реализация паттерна Actor
//
// Actor — объект с единственной публичной точкой входа (send),
// который внутри организует очередь сообщений (mailbox).
// Каждое сообщение обрабатывается строго последовательно с await.
//
// Ключевые элементы:
//   #queue      — массив-очередь сообщений (FIFO)
//   #processing — флаг активного исполнения (предотвращает повторный запуск #process)
//   #behavior   — функция бизнес-логики (передаётся через конструктор)
//   #state      — состояние, принадлежащее только этому актору
//
// Паттерн "Открытый конструктор" (Revealing Constructor):
//   behavior передаётся в конструктор — актор не знает о конкретной логике,
//   он только гарантирует последовательность обработки.
//
// Историческая справка:
//   Когда Алан Кей изобретал ООП, он представлял методы именно как "отправку сообщений".
//   Вызов метода = отправка сообщения на экземпляр. Actor реализует эту идею буквально:
//   есть объект (Actor), есть почтовый ящик (#queue), есть поведение (#behavior).

'use strict';

class Actor {
  #behavior;  // функция: (message, state) =&gt; Promise&lt;void&gt;
  #state;     // изолированное состояние актора
  #queue = [];           // очередь входящих сообщений (mailbox)
  #processing = false;   // флаг: идёт ли сейчас обработка

  constructor(behavior, initialState) {
    this.#behavior = behavior;
    this.#state = initialState;
  }

  // Единственный публичный метод: отправить сообщение актору
  // "fire and forget" — мы не ждём результата (нет return Promise)
  send(message) {
    this.#queue.push(message);
    // Запускаем обработку (если ещё не запущена)
    this.#process();
  }

  // Приватный цикл обработки сообщений
  async #process() {
    // Если уже обрабатываем — выходим (другой вызов #process уже крутит цикл)
    if (this.#processing) return;

    this.#processing = true;

    // Обрабатываем сообщения по одному, пока очередь не опустеет
    while (this.#queue.length &gt; 0) {
      const message = this.#queue.shift(); // берём первое сообщение из очереди (FIFO)
      try {
        // await гарантирует: следующее сообщение не начнётся, пока это не завершится
        await this.#behavior(message, this.#state);
      } catch (err) {
        // Ошибка в behavior не останавливает обработку других сообщений
        console.error(`Actor: ошибка при обработке сообщения:`, err.message);
      }
    }

    this.#processing = false;
    // После обнуления флага актор готов принять новые сообщения
  }
}

module.exports = { Actor };
</code></pre>
<hr />
<h2 id="33-Применение-actor-к-задаче-со-складом"><a class="header" href="#33-Применение-actor-к-задаче-со-складом">3.3 Применение Actor к задаче со складом</a></h2>
<pre><code class="language-javascript">// Пример 20. Склад с гонкой данных — ИСПРАВЛЕННАЯ версия с Actor
//
// Единственное изменение по сравнению с опасным кодом:
// вместо прямого вызова buy(order, state) отправляем сообщение актору.
// Бизнес-логика (buy) не изменилась.

'use strict';

// --- Та же бизнес-логика что в примере 18 ---

async function checkAvailability(order, state) {
  await new Promise((r) =&gt; setTimeout(r, Math.random() * 10));
  if (state[order.lot] &lt; order.qty) {
    throw new Error(`Недостаточно товара: есть ${state[order.lot]}, запрошено ${order.qty}`);
  }
  console.log(`[${order.id}] Проверка наличия ОК: ${state[order.lot]} &gt;= ${order.qty}`);
}

async function processPayment(order) {
  await new Promise((r) =&gt; setTimeout(r, Math.random() * 15));
  console.log(`[${order.id}] Платёж проведён`);
}

async function shiftGoods(order, state) {
  await new Promise((r) =&gt; setTimeout(r, Math.random() * 5));
  state[order.lot] -= order.qty;
  console.log(`[${order.id}] Товар списан. Остаток: ${state[order.lot]}`);
}

async function sendNotification(order) {
  await new Promise((r) =&gt; setTimeout(r, 5));
  console.log(`[${order.id}] Уведомление отправлено`);
}

// Функция бизнес-логики — НЕ ИЗМЕНИЛАСЬ
async function buy(order, state) {
  await checkAvailability(order, state);
  await processPayment(order);
  await shiftGoods(order, state);
  await sendNotification(order);
}

// --- Реализация Actor ---

class Actor {
  #behavior;
  #state;
  #queue = [];
  #processing = false;

  constructor(behavior, initialState) {
    this.#behavior = behavior;
    this.#state = initialState;
  }

  send(message) {
    this.#queue.push(message);
    this.#process();
  }

  async #process() {
    if (this.#processing) return;
    this.#processing = true;
    while (this.#queue.length &gt; 0) {
      const message = this.#queue.shift();
      try {
        await this.#behavior(message, this.#state);
      } catch (err) {
        console.error(`[${message.id}] ОШИБКА: ${err.message}`);
      }
    }
    this.#processing = false;
  }
}

// --- Применение ---

async function runWithActor() {
  console.log('=== ACTOR: БЕЗОПАСНАЯ ОБРАБОТКА ЗАКАЗОВ ===');

  // Оборачиваем состояние и поведение в актор
  // Состояние изолировано внутри актора — снаружи к нему нет доступа
  const warehouseActor = new Actor(buy, { 1722: 5 });

  console.log('Начальный остаток: 5\n');

  const orders = [
    { id: 'ORDER-1', lot: 1722, qty: 2 },
    { id: 'ORDER-2', lot: 1722, qty: 2 },
    { id: 'ORDER-3', lot: 1722, qty: 2 },
  ];

  // Отправляем все три сообщения "одновременно"
  // Actor поставит их в очередь и обработает последовательно
  for (const order of orders) {
    warehouseActor.send(order);
  }

  // Ждём завершения всех обработок (даём время event loop)
  await new Promise((r) =&gt; setTimeout(r, 500));

  console.log('\n=== ИТОГ ===');
  console.log('Все три сообщения обработаны последовательно.');
  console.log('Остаток не ушёл в минус. Гонка данных устранена.');
}

runWithActor();
</code></pre>
<hr />
<h2 id="34-Гарантии-паттерна-actor"><a class="header" href="#34-Гарантии-паттерна-actor">3.4 Гарантии паттерна Actor</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Гарантия</th><th>Описание</th><th>Механизм</th></tr></thead><tbody>
<tr><td>Последовательность</td><td>Сообщения обрабатываются по одному</td><td><code>while</code> + <code>await</code> + флаг <code>#processing</code></td></tr>
<tr><td>Изоляция стейта</td><td>Состояние недоступно снаружи</td><td>Приватное поле <code>#state</code></td></tr>
<tr><td>Отказоустойчивость</td><td>Ошибка одного сообщения не ломает очередь</td><td><code>try/catch</code> в <code>#process</code></td></tr>
<tr><td>Прозрачность</td><td>Бизнес-логика не меняется</td><td>Поведение передаётся через конструктор</td></tr>
<tr><td>Без блокировок</td><td>Нет mutex/lock/semaphore</td><td>Только очередь и async/await</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="35-Типичная-ошибка-утечка-ссылки-на-состояние"><a class="header" href="#35-Типичная-ошибка-утечка-ссылки-на-состояние">3.5 Типичная ошибка: утечка ссылки на состояние</a></h2>
<pre><code class="language-javascript">// Пример 21. Антипаттерн: внешняя ссылка на состояние нарушает гарантии Actor
//
// Если передать ссылку на state наружу, кто угодно сможет изменить его напрямую,
// минуя очередь актора. Изоляция нарушена — гонка возвращается.

'use strict';

class UnsafeActor {
  #state;
  #queue = [];
  #processing = false;

  constructor(initialState) {
    this.#state = initialState;
    // АНТИПАТТЕРН: публичный геттер возвращает ссылку на изменяемый объект
    // Внешний код может изменить this.state[key] напрямую, минуя очередь
    this.state = this.#state; // &lt;-- ОПАСНО
  }

  send(behavior, message) {
    this.#queue.push({ behavior, message });
    this.#process();
  }

  async #process() {
    if (this.#processing) return;
    this.#processing = true;
    while (this.#queue.length &gt; 0) {
      const { behavior, message } = this.#queue.shift();
      await behavior(message, this.#state);
    }
    this.#processing = false;
  }
}

const actor = new UnsafeActor({ counter: 0 });

// Внешний код напрямую модифицирует состояние, минуя очередь:
actor.state.counter = 999; // &lt;-- ГОНКА ДАННЫХ ВОЗМОЖНА

console.log('АНТИПАТТЕРН: внешняя запись в actor.state обходит очередь');
console.log('Всегда используйте приватные поля (#state) и не возвращайте ссылку на state наружу');
</code></pre>
<hr />
<h2 id="36-Связи-с-другими-концепциями"><a class="header" href="#36-Связи-с-другими-концепциями">3.6 Связи с другими концепциями</a></h2>
<h3 id="Паттерн-actor-и-event-loop"><a class="header" href="#Паттерн-actor-и-event-loop">Паттерн Actor и Event Loop</a></h3>
<p>Event Loop в Node.js не защищает от гонок данных сам по себе. Он гарантирует, что
в любой момент времени выполняется только один участок синхронного кода. Но <code>await</code>
создаёт точку отказа от управления: между двумя <code>await</code> другой асинхронный код может
начать выполнение и изменить общий стейт.</p>
<p>Actor решает это иначе: он не запрещает другим запуститься, но гарантирует, что к
данному стейту будет обращаться только одно сообщение за раз, потому что следующее
сообщение не начнётся до <code>await</code> в конце предыдущего.</p>
<h3 id="Паттерн-Открытый-конструктор-во-всех-трёх-темах"><a class="header" href="#Паттерн-Открытый-конструктор-во-всех-трёх-темах">Паттерн "Открытый конструктор" во всех трёх темах</a></h3>
<p>Все три темы недели 7 используют один и тот же паттерн — передача поведения через
конструктор (Revealing Constructor Pattern):</p>
<pre><code class="language-javascript">// Node.js Writable: поведение записи — через конструктор
const writable = new Writable({
  write(chunk, encoding, next) { /* логика */ }
});

// Web Streams WritableStream: то же самое в Web API
const ws = new WritableStream({
  write(chunk) { /* логика */ }
});

// Actor: поведение обработки сообщений — через конструктор
const actor = new Actor(behaviorFunction, initialState);
</code></pre>
<p>Это не случайное совпадение. Паттерн Revealing Constructor — это способ создать объект
с инкапсулированным состоянием, поведение которого задаётся в момент создания. Он
противоположен субклассированию: вместо <code>extends Transform</code> мы передаём функцию.</p>
<h3 id="for-await-как-унифицированный-интерфейс"><a class="header" href="#for-await-как-унифицированный-интерфейс">for await как унифицированный интерфейс</a></h3>
<pre><code class="language-javascript">// Node.js Readable Stream
for await (const chunk of nodeStream) { ... }

// Web API ReadableStream (response.body из fetch)
for await (const chunk of response.body) { ... }

// HTTP IncomingMessage (является Readable Stream)
for await (const chunk of req) { ... }

// Любой объект с Symbol.asyncIterator
for await (const item of asyncGenerator()) { ... }
</code></pre>
<p>Это принципиальное решение стандартного комитета TC39 и Node.js: унифицировать
доступ ко всем источникам асинхронных данных через один синтаксис.</p>
<hr />
<h2 id="37-Сравнение-подходов-к-защите-состояния"><a class="header" href="#37-Сравнение-подходов-к-защите-состояния">3.7 Сравнение подходов к защите состояния</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Подход</th><th>Механизм</th><th>Сложность</th><th>Применимость</th></tr></thead><tbody>
<tr><td>Последовательные <code>await</code></td><td><code>await buy1; await buy2</code></td><td>Низкая</td><td>Один исполнитель</td></tr>
<tr><td>Mutex / Semaphore</td><td>Блокировки (библиотеки)</td><td>Высокая</td><td>Мультипоточность (Worker)</td></tr>
<tr><td>Actor Pattern</td><td>Очередь + async/await</td><td>Низкая</td><td>Любой async JS</td></tr>
<tr><td>Immutable state</td><td>Неизменяемые структуры</td><td>Средняя</td><td>Функциональный стиль</td></tr>
<tr><td>SharedArrayBuffer + Atomics</td><td>Атомарные операции</td><td>Очень высокая</td><td>SharedArrayBuffer</td></tr>
</tbody></table>
</div>
<p>Для большинства задач в Node.js паттерн Actor — наиболее практичное решение:
он не требует сторонних библиотек, работает со стандартным async/await и не
усложняет бизнес-логику.</p>
<hr />
<h2 id="Предупреждения-и-типичные-ошибки"><a class="header" href="#Предупреждения-и-типичные-ошибки">Предупреждения и типичные ошибки</a></h2>
<h3 id="Стримы"><a class="header" href="#Стримы">Стримы</a></h3>
<p><strong>Забытый обработчик ошибок</strong></p>
<pre><code class="language-javascript">// НЕПРАВИЛЬНО: без обработки ошибок Node.js упадёт
const stream = fs.createReadStream('./nonexistent.txt');
stream.on('data', (chunk) =&gt; { /* ... */ });
// Если файл не существует — необработанное исключение!

// ПРАВИЛЬНО: всегда добавляем on('error')
stream.on('error', (err) =&gt; console.error('Ошибка стрима:', err.message));
</code></pre>
<p><strong>Использование pipe вместо pipeline</strong></p>
<pre><code class="language-javascript">// НЕПРАВИЛЬНО: pipe не обрабатывает ошибки автоматически
readable.pipe(transform).pipe(writable);
// Если transform выдаст ошибку — readable не будет закрыт

// ПРАВИЛЬНО: pipeline корректно обрабатывает ошибки и закрывает все стримы
const { pipeline } = require('node:stream/promises');
await pipeline(readable, transform, writable);
</code></pre>
<p><strong>Смешивание on('data') и on('readable')</strong></p>
<pre><code class="language-javascript">// НЕПРАВИЛЬНО: подписка на оба события создаёт непредсказуемое поведение
stream.on('data', handler1);    // переводит в flowing mode
stream.on('readable', handler2); // конфликт режимов

// ПРАВИЛЬНО: используйте один стиль чтения
</code></pre>
<p><strong>null в стриме объектов</strong></p>
<pre><code class="language-javascript">// НЕПРАВИЛЬНО: null — зарезервированный сигнал конца стрима
const stream = new Readable({ read() {} });
stream.push(null);         // &lt;- КОНЕЦ СТРИМА, не данные!
stream.push({ id: null }); // НИКОГДА не выполнится

// ПРАВИЛЬНО: используйте sentinel-объект или objectMode с явным закрытием
</code></pre>
<h3 id="actor-pattern"><a class="header" href="#actor-pattern">Actor Pattern</a></h3>
<p><strong>Разделённый стейт между акторами</strong></p>
<pre><code class="language-javascript">// НЕПРАВИЛЬНО: оба актора работают с одним объектом
const shared = { count: 0 };
const actor1 = new Actor(behavior1, shared);
const actor2 = new Actor(behavior2, shared); // ГОНКА ДАННЫХ!

// ПРАВИЛЬНО: каждый актор владеет своим стейтом
const actor1 = new Actor(behavior1, { count: 0 });
const actor2 = new Actor(behavior2, { count: 0 });
</code></pre>
<p><strong>Ожидание результата через send()</strong></p>
<pre><code class="language-javascript">// НЕПРАВИЛЬНО: Actor.send() — fire and forget, нет возврата результата
const result = actor.send(message); // result === undefined

// ПРАВИЛЬНО: если нужен результат — используйте callback внутри сообщения
// или расширяйте Actor паттерн возвратом Promise из send()
actor.send({ ...message, onComplete: (result) =&gt; { /* ... */ } });
</code></pre>
<hr />
<h2 id="Управление-памятью-через-стримы"><a class="header" href="#Управление-памятью-через-стримы">Управление памятью через стримы</a></h2>
<p>Ключевое преимущество стримов — данные не загружаются в память целиком.
При чтении файла через стрим в памяти находится не более одного чанка (по умолчанию 64 KB),
независимо от размера файла:</p>
<div class="table-wrapper"><table><thead><tr><th>Подход</th><th>Файл 1 GB</th><th>Потребление памяти</th></tr></thead><tbody>
<tr><td><code>fs.readFileSync</code></td><td>Целиком в Buffer</td><td>~1 GB</td></tr>
<tr><td><code>fs.readFile</code> (колбэк)</td><td>Целиком в Buffer</td><td>~1 GB</td></tr>
<tr><td><code>fs.createReadStream</code></td><td>Текущий чанк</td><td>~64 KB</td></tr>
<tr><td><code>pipeline(readStream, ...)</code></td><td>Текущий чанк</td><td>~64 KB</td></tr>
</tbody></table>
</div>
<p>Стримы незаменимы для:</p>
<ul>
<li>Обработки файлов, не помещающихся в RAM</li>
<li>Потокового видеокодирования и шифрования</li>
<li>Курсоров базы данных (записи читаются чанками)</li>
<li>Передачи больших HTTP-ответов без буферизации всего тела</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../week7/lecture-2-web-streams.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../week9.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../week7/lecture-2-web-streams.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../week9.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
