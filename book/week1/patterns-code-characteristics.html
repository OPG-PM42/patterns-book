<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Характеристики и оптимизация для V8, SOLID - SRP, SoC - Patterns</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Patterns</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Паттерны-характеристики-кода-и-стратегии-оптимизации"><a class="header" href="#Паттерны-характеристики-кода-и-стратегии-оптимизации">Паттерны: характеристики кода и стратегии оптимизации</a></h1>
<h2 id="Обзор-лекции"><a class="header" href="#Обзор-лекции">Обзор лекции</a></h2>
<p><strong>Тема:</strong> JavaScript, TypeScript — SOLID/SRP, SoC
<strong>Цель:</strong> Научиться писать код, который одновременно:</p>
<ul>
<li>Соответствует принципам SOLID и GRASP</li>
<li>Оптимизирован для виртуальной машины V8</li>
<li>Читабельный, надёжный и поддерживаемый</li>
</ul>
<hr />
<h2 id="1-Введение-Зачем-нужен-обзор-техник-перед-паттернами"><a class="header" href="#1-Введение-Зачем-нужен-обзор-техник-перед-паттернами">1. Введение: Зачем нужен обзор техник перед паттернами</a></h2>
<h3 id="Основная-идея"><a class="header" href="#Основная-идея">Основная идея</a></h3>
<p>Прежде чем изучать паттерны проектирования, необходимо понять:</p>
<ul>
<li>Какие возможности JavaScript и TypeScript мы будем использовать</li>
<li>Как разные парадигмы (процедурная, ООП, функциональная) применяются на практике</li>
<li>Как совместить принципы качественного кода с оптимизацией для V8</li>
</ul>
<h3 id="Подход-к-балансу-характеристик-кода"><a class="header" href="#Подход-к-балансу-характеристик-кода">Подход к балансу характеристик кода</a></h3>
<p>Мы стремимся сбалансировать:</p>
<ul>
<li><strong>Читаемость</strong> - код легко понять</li>
<li><strong>Надёжность</strong> - меньше ошибок</li>
<li><strong>Стабильность</strong> - предсказуемое поведение</li>
<li><strong>Модифицируемость</strong> - легко вносить изменения</li>
<li><strong>Тестируемость</strong> - простота покрытия тестами</li>
<li><strong>Производительность</strong> - эффективное выполнение</li>
</ul>
<hr />
<h2 id="2-Анализ-плохого-кода-18-категорий-проблем"><a class="header" href="#2-Анализ-плохого-кода-18-категорий-проблем">2. Анализ плохого кода: 18 категорий проблем</a></h2>
<h3 id="Исходная-задача"><a class="header" href="#Исходная-задача">Исходная задача</a></h3>
<p><strong>Задача:</strong> Обработать сырой датасет товаров с неконсистентными данными и извлечь цены.</p>
<p><strong>Проблемы входных данных:</strong></p>
<ul>
<li>Объекты с полями в разном порядке</li>
<li>Массивы вместо объектов</li>
<li>Смешанные типы данных (string и number)</li>
<li>Отсутствующие или переименованные поля (<code>price</code> vs <code>cost</code>)</li>
</ul>
<hr />
<h3 id="21-Проблемы-оптимизации-v8"><a class="header" href="#21-Проблемы-оптимизации-v8">2.1. Проблемы оптимизации V8</a></h3>
<h4 id="Проблема-1-Деоптимизация-виртуальной-машины"><a class="header" href="#Проблема-1-Деоптимизация-виртуальной-машины">Проблема 1: Деоптимизация виртуальной машины</a></h4>
<p><strong>Что:</strong> Полиморфный код постоянно меняет форму объектов и скрытые классы.</p>
<p><strong>Почему плохо:</strong></p>
<ul>
<li>V8 оптимизирует код на основе предположений о структуре объектов</li>
<li>Изменение формы объектов заставляет V8 отказываться от оптимизаций</li>
<li>Производительность падает</li>
</ul>
<p><strong>Ключевые концепции:</strong></p>
<ul>
<li><strong>Hidden Classes (скрытые классы)</strong> - внутреннее представление структуры объектов в V8</li>
<li><strong>Мегаморфный код</strong> - код, работающий с более чем 4 формами объектов</li>
</ul>
<h4 id="Проблема-13-Изменение-формы-объектов"><a class="header" href="#Проблема-13-Изменение-формы-объектов">Проблема 13: Изменение формы объектов</a></h4>
<p><strong>Антипаттерны:</strong></p>
<pre><code class="language-javascript">// Плохо: delete меняет форму объекта
const obj = { name: 'Item', price: 100 };
delete obj.price; // Форма изменилась!

// Плохо: добавление полей в разном порядке
const obj1 = { name: 'A', price: 10 };
const obj2 = { price: 20, name: 'B' }; // Другая форма!
</code></pre>
<p><strong>Решение:</strong></p>
<pre><code class="language-javascript">// Хорошо: всегда одна и та же форма
const obj1 = { name: 'A', price: 10 };
const obj2 = { name: 'B', price: 20 };
</code></pre>
<h4 id="Проблема-14-Дырявые-массивы"><a class="header" href="#Проблема-14-Дырявые-массивы">Проблема 14: Дырявые массивы</a></h4>
<p><strong>Что:</strong> Массивы с пропусками (holes) создаются при удалении элементов.</p>
<pre><code class="language-javascript">// Плохо
const arr = [1, 2, 3];
delete arr[1]; // [1, empty, 3] - дырявый массив
</code></pre>
<hr />
<h3 id="22-Проблемы-читаемости-и-сложности"><a class="header" href="#22-Проблемы-читаемости-и-сложности">2.2. Проблемы читаемости и сложности</a></h3>
<h4 id="Проблема-2-Избыток-if-ов-6-штук"><a class="header" href="#Проблема-2-Избыток-if-ов-6-штук">Проблема 2: Избыток if-ов (6 штук)</a></h4>
<p><strong>Почему плохо:</strong></p>
<ul>
<li>Высокая когнитивная нагрузка</li>
<li>Сложность тестирования (много ветвлений)</li>
<li>Трудно отследить логику</li>
</ul>
<p><strong>Решение:</strong> Использовать меньше условий через декомпозицию и изоляцию проверок.</p>
<h4 id="Проблема-3-Разнесённая-проверка-на-массив"><a class="header" href="#Проблема-3-Разнесённая-проверка-на-массив">Проблема 3: Разнесённая проверка на массив</a></h4>
<p><strong>Проблема:</strong></p>
<pre><code class="language-javascript">// Плохо: проверка в одном месте
if (!Array.isArray(data)) {
  // обработка объекта
}
// ... много кода ...
// обработка массива в другом месте
</code></pre>
<p><strong>Почему плохо:</strong> Глаза должны прыгать по коду, нарушается последовательность чтения.</p>
<h4 id="Проблема-8-Дупликация-кода"><a class="header" href="#Проблема-8-Дупликация-кода">Проблема 8: Дупликация кода</a></h4>
<p><strong>Примеры дупликации:</strong></p>
<ul>
<li>Повторяющиеся проверки (<code>options.converter</code>)</li>
<li>Похожие преобразования типов в разных местах</li>
</ul>
<hr />
<h3 id="23-Проблемы-производительности"><a class="header" href="#23-Проблемы-производительности">2.3. Проблемы производительности</a></h3>
<h4 id="Проблема-4-Неэффективная-деструктуризация-массива"><a class="header" href="#Проблема-4-Неэффективная-деструктуризация-массива">Проблема 4: Неэффективная деструктуризация массива</a></h4>
<pre><code class="language-javascript">// Плохо: создаёт итератор
const [, value] = data; // Пропускаем первый, берём второй

// Хорошо: прямой доступ
const value = data[1];
</code></pre>
<p><strong>Почему плохо:</strong> Деструктуризация массива создаёт итератор, что медленнее прямого доступа.</p>
<h4 id="Проблема-12-array-как-tuple"><a class="header" href="#Проблема-12-array-как-tuple">Проблема 12: Array как tuple</a></h4>
<p><strong>Проблема:</strong></p>
<pre><code class="language-javascript">// Плохо в JavaScript
const item = ['Book', 100]; // [name, price]
const [name, price] = item;
</code></pre>
<p><strong>Почему плохо:</strong></p>
<ul>
<li>Создание итератора при деструктуризации</li>
<li>Непонятно, что в каком индексе</li>
<li>В JavaScript объект предпочтительнее</li>
</ul>
<p><strong>Решение:</strong></p>
<pre><code class="language-javascript">// Хорошо
const item = { name: 'Book', price: 100 };
const { name, price } = item;
</code></pre>
<h4 id="Проблема-14-closures-модифицирующие-внешний-scope"><a class="header" href="#Проблема-14-closures-модифицирующие-внешний-scope">Проблема 14: Closures, модифицирующие внешний scope</a></h4>
<pre><code class="language-javascript">// Плохо
const out = [];
data.forEach(item =&gt; {
  out.push(process(item)); // Модификация внешней переменной
});

// Хорошо
const out = data.map(item =&gt; process(item));

// Ещё лучше (для V8)
const out = [];
for (let i = 0; i &lt; data.length; i++) {
  out.push(process(data[i]));
}
</code></pre>
<hr />
<h3 id="24-Проблемы-типизации"><a class="header" href="#24-Проблемы-типизации">2.4. Проблемы типизации</a></h3>
<h4 id="Проблема-5-Избыток-union-типов"><a class="header" href="#Проблема-5-Избыток-union-типов">Проблема 5: Избыток Union типов</a></h4>
<p><strong>Проблема:</strong></p>
<pre><code class="language-typescript">// Плохо: сложный Union
type Item = { name: string; price?: number } | { name?: string; price: number };
function getPrice(data: Item | ItemData): number | undefined | NaN {
  // ...
}
</code></pre>
<p><strong>Цель:</strong> Минимизировать Union типы через нормализацию данных.</p>
<h4 id="Проблема-6-Выходной-тип-number--undefined--nan"><a class="header" href="#Проблема-6-Выходной-тип-number--undefined--nan">Проблема 6: Выходной тип <code>number | undefined | NaN</code></a></h4>
<p><strong>Проблема:</strong> NaN в JavaScript ведёт себя странно (<code>NaN !== NaN</code>).</p>
<p><strong>Решение:</strong> Возвращать <code>number | undefined</code>, заменяя NaN на undefined.</p>
<pre><code class="language-typescript">// Плохо
return parseInt(value); // Может вернуть NaN

// Хорошо
const parsed = parseInt(value);
return isNaN(parsed) ? undefined : parsed;
</code></pre>
<hr />
<h3 id="25-Проблемы-архитектуры"><a class="header" href="#25-Проблемы-архитектуры">2.5. Проблемы архитектуры</a></h3>
<h4 id="Проблема-9-Слабые-контракты-weak-contracts"><a class="header" href="#Проблема-9-Слабые-контракты-weak-contracts">Проблема 9: Слабые контракты (Weak Contracts)</a></h4>
<p><strong>Суть:</strong> Сырые данные проникают глубоко в бизнес-логику.</p>
<p><strong>Решение:</strong> Изолировать сложность входных данных:</p>
<ol>
<li>На входе нормализовать данные</li>
<li>В бизнес-логике работать только с консистентными данными</li>
</ol>
<h4 id="Проблема-10-mixed-responsibility-Смешение-ответственностей"><a class="header" href="#Проблема-10-mixed-responsibility-Смешение-ответственностей">Проблема 10: Mixed Responsibility (Смешение ответственностей)</a></h4>
<p><strong>Функция делает слишком много:</strong></p>
<ul>
<li>Конвертирует сырые данные</li>
<li>Определяет типы</li>
<li>Нормализует данные</li>
<li>Преобразует массивы в объекты</li>
<li>Извлекает конкретное поле (price)</li>
</ul>
<p><strong>Принцип:</strong> Single Responsibility Principle (SRP) - одна функция = одна ответственность.</p>
<h4 id="Проблема-11-inconsistent-return"><a class="header" href="#Проблема-11-inconsistent-return">Проблема 11: Inconsistent Return</a></h4>
<p><strong>Проблема:</strong> Функция возвращает разные типы в разных ветках.</p>
<pre><code class="language-javascript">// Плохо: ESLint ругается
function getPrice(data) {
  if (!data) return undefined;
  if (typeof data === 'string') return NaN;
  return data.price;
}
</code></pre>
<hr />
<h3 id="26-Стилистические-проблемы"><a class="header" href="#26-Стилистические-проблемы">2.6. Стилистические проблемы</a></h3>
<h4 id="Проблема-15-Неявное-преобразование-типов"><a class="header" href="#Проблема-15-Неявное-преобразование-типов">Проблема 15: Неявное преобразование типов</a></h4>
<p><strong>Антипаттерны:</strong></p>
<pre><code class="language-javascript">// Приведение к строке
const str1 = '' + number;
const str2 = `${number}`;

// Приведение к числу
const num1 = +string;
const num2 = string * 1;
const num3 = string - 0;
const num4 = string / 1;
</code></pre>
<p><strong>Почему плохо:</strong> Повышает когнитивную нагрузку, неочевидно.</p>
<p><strong>Решение:</strong></p>
<pre><code class="language-javascript">// Явное преобразование
const str = String(number);
const num = Number(string);
const num2 = parseInt(string, 10);
const num3 = parseFloat(string);
</code></pre>
<h4 id="Проблема-16-Сравнение-с-автоприведением-типов"><a class="header" href="#Проблема-16-Сравнение-с-автоприведением-типов">Проблема 16: Сравнение с автоприведением типов</a></h4>
<p><strong>Правило:</strong> Всегда использовать строгое сравнение.</p>
<pre><code class="language-javascript">// Плохо
if (value == null) { }
if (a != b) { }

// Хорошо
if (value === null) { }
if (a !== b) { }
</code></pre>
<h4 id="Проблема-17-Последовательное-присвоение"><a class="header" href="#Проблема-17-Последовательное-присвоение">Проблема 17: Последовательное присвоение</a></h4>
<pre><code class="language-javascript">// Плохо
let a = b = c = 0;

// Хорошо
let a = 0;
let b = 0;
let c = 0;
</code></pre>
<h4 id="Проблема-18-Использование-var"><a class="header" href="#Проблема-18-Использование-var">Проблема 18: Использование var</a></h4>
<p><strong>Правило:</strong> Использовать <code>const</code> по умолчанию, <code>let</code> только при необходимости.</p>
<pre><code class="language-javascript">// Плохо
var x = 10;

// Хорошо
const x = 10;

// Если нужна мутация
let counter = 0;
counter++; // Но не менять тип!
</code></pre>
<p><strong>Важно:</strong> Если переменная объявлена через <code>let</code>:</p>
<ul>
<li>Не менять её тип (<code>number</code> → <code>string</code>)</li>
<li>Стараться не смешивать <code>float</code> и <code>integer</code></li>
</ul>
<hr />
<h2 id="3-Рефакторинг-1-Процедурный-стиль-с-разделением-ответственности"><a class="header" href="#3-Рефакторинг-1-Процедурный-стиль-с-разделением-ответственности">3. Рефакторинг №1: Процедурный стиль с разделением ответственности</a></h2>
<h3 id="Основная-идея-1"><a class="header" href="#Основная-идея-1">Основная идея</a></h3>
<p>Разделить функцию на две:</p>
<ul>
<li><code>normalizeItem()</code> - нормализует данные</li>
<li><code>getPrice()</code> - извлекает цену из нормализованных данных</li>
</ul>
<h3 id="Ключевые-улучшения"><a class="header" href="#Ключевые-улучшения">Ключевые улучшения</a></h3>
<h4 id="1-Разделение-ответственностей-srp"><a class="header" href="#1-Разделение-ответственностей-srp">1. Разделение ответственностей (SRP)</a></h4>
<pre><code class="language-javascript">// Плохо: одна функция делает всё
function getPrice(data, options) {
  // Проверки типов
  // Нормализация
  // Извлечение price
  // Конвертация типов
}

// Хорошо: две функции с чёткими ответственностями
function normalizeItem(data, options = {}) {
  // Только нормализация данных
  const isTuple = Array.isArray(data);
  const obj = isTuple ? { name: data[0], price: data[1] } : data;
  const { price, cost } = obj;
  const value = price ?? cost;

  const { converter } = options;
  const normalizedValue =
    typeof value === 'string' &amp;&amp; converter
      ? converter(value)
      : parseFloat(value);

  return { name: obj.name, price: normalizedValue };
}

function getPrice(item) {
  // Только извлечение price
  return item.price;
}
</code></pre>
<h4 id="2-Использование-const-вместо-let"><a class="header" href="#2-Использование-const-вместо-let">2. Использование const вместо let</a></h4>
<pre><code class="language-javascript">// Плохо
let price;
if (typeof value === 'string') {
  price = parseFloat(value);
} else {
  price = value;
}

// Хорошо
const price = typeof value === 'string' ? parseFloat(value) : value;
</code></pre>
<h4 id="3-Уменьшение-if-ов"><a class="header" href="#3-Уменьшение-if-ов">3. Уменьшение if-ов</a></h4>
<p><strong>Было:</strong> 6 if-ов
<strong>Стало:</strong> 3 тернарных оператора</p>
<p>Тернарные операторы проще читать, когда они однострочные.</p>
<h4 id="4-Линейный-код"><a class="header" href="#4-Линейный-код">4. Линейный код</a></h4>
<p>Код стал последовательным, без прыжков взгляда:</p>
<pre><code class="language-javascript">const isTuple = Array.isArray(data);
const obj = isTuple ? { name: data[0], price: data[1] } : data;
const { price, cost } = obj;
const value = price ?? cost;
// ... и так далее
</code></pre>
<h4 id="5-Улучшение-типизации"><a class="header" href="#5-Улучшение-типизации">5. Улучшение типизации</a></h4>
<p><strong>Было:</strong></p>
<pre><code class="language-typescript">type Item = { name?: string; price?: number } | ItemData;
</code></pre>
<p><strong>Стало:</strong></p>
<pre><code class="language-typescript">type RawItemTuple = [string, number | string];
type RawItemObject = { name: string; price?: number; cost?: number };
type RawItem = RawItemTuple | RawItemObject;

type NormalizedItem = { name: string; price: number };

function normalizeItem(data: RawItem, options?: Options): NormalizedItem {
  // ...
}
</code></pre>
<p><strong>Преимущества:</strong></p>
<ul>
<li>Чёткое разделение raw и normalized данных</li>
<li>Меньше Union типов во внутренней логике</li>
<li>Consistent return type</li>
</ul>
<h3 id="Результаты-оптимизации"><a class="header" href="#Результаты-оптимизации">Результаты оптимизации</a></h3>
<p><strong>Характеристики кода:</strong></p>
<ul>
<li>✅ Легче тестировать</li>
<li>✅ Легче читать</li>
<li>✅ Нет дупликации</li>
<li>✅ Меньше if-ов (3 тернарных вместо 6 if-ов)</li>
<li>✅ Изоляция проверок от бизнес-логики</li>
<li>✅ Применён SRP (Single Responsibility Principle)</li>
<li>✅ Применён SoC (Separation of Concerns)</li>
<li>✅ Consistent return</li>
<li>✅ Готов к inlining (V8 может встроить функции)</li>
</ul>
<hr />
<h2 id="4-Рефакторинг-2-Именованные-параметры"><a class="header" href="#4-Рефакторинг-2-Именованные-параметры">4. Рефакторинг №2: Именованные параметры</a></h2>
<h3 id="Техника-именованных-параметров"><a class="header" href="#Техника-именованных-параметров">Техника именованных параметров</a></h3>
<pre><code class="language-javascript">// Было: позиционные параметры
function normalizeItem(data, options) {
  // ...
}
normalizeItem(item, { converter: parseFloat });

// Стало: именованные параметры
function normalizeItem({ data, options = {} }) {
  // ...
}
normalizeItem({ data: item, options: { converter: parseFloat } });
</code></pre>
<h3 id="Когда-использовать"><a class="header" href="#Когда-использовать">Когда использовать</a></h3>
<p><strong>Плюсы именованных параметров:</strong></p>
<ul>
<li>Читаемость - видно, что передаётся</li>
<li>Гибкость - можно опускать/переставлять аргументы</li>
<li>Самодокументирование кода</li>
</ul>
<p><strong>Минусы:</strong></p>
<ul>
<li>Создаёт дополнительные обёртки (деструктуризация)</li>
<li>Немного медленнее для V8</li>
</ul>
<h3 id="Рекомендация"><a class="header" href="#Рекомендация">Рекомендация</a></h3>
<ul>
<li><strong>Высокоуровневый код:</strong> использовать именованные параметры (приоритет читаемости)</li>
<li><strong>Низкоуровневый код:</strong> использовать позиционные параметры (приоритет производительности)</li>
</ul>
<hr />
<h2 id="5-Рефакторинг-3-Классы-и-статические-фабрики"><a class="header" href="#5-Рефакторинг-3-Классы-и-статические-фабрики">5. Рефакторинг №3: Классы и статические фабрики</a></h2>
<h3 id="Зачем-использовать-классы"><a class="header" href="#Зачем-использовать-классы">Зачем использовать классы</a></h3>
<ul>
<li>Некоторые паттерны естественнее выражаются через ООП</li>
<li>Инкапсуляция данных</li>
<li>Использование <code>instanceof</code> для проверки типов</li>
<li>Мультипарадигменный подход</li>
</ul>
<h3 id="Паттерн-Статические-фабрики"><a class="header" href="#Паттерн-Статические-фабрики">Паттерн: Статические фабрики</a></h3>
<p><strong>Структура класса:</strong></p>
<pre><code class="language-javascript">class Item {
  constructor(name, price, options = {}) {
    const { converter } = options;
    this.name = name;
    this.price =
      typeof price === 'string' &amp;&amp; converter
        ? converter(price)
        : parseFloat(price);
  }

  // Фабрика для объектов
  static fromStruct({ name, price, cost, ...options }) {
    return new Item(name, price ?? cost, options);
  }

  // Фабрика для массивов (tuple)
  static fromTuple([name, price], options) {
    return new Item(name, price, options);
  }

  // Общая фабрика (Strategy выбора)
  static fromData(data, options = {}) {
    const factory = Array.isArray(data) ? Item.fromTuple : Item.fromStruct;
    return factory(data, options);
  }
}
</code></pre>
<h3 id="Использование"><a class="header" href="#Использование">Использование</a></h3>
<pre><code class="language-javascript">// Использование
const items = rawData.map(data =&gt; Item.fromData(data, { converter: parseFloat }));
const prices = items.map(item =&gt; item.price);
</code></pre>
<h3 id="Преимущества-подхода"><a class="header" href="#Преимущества-подхода">Преимущества подхода</a></h3>
<ol>
<li>
<p><strong>Декомпозиция:</strong> Каждая фабрика имеет одну ответственность</p>
<ul>
<li><code>fromStruct</code> - разобрать объект</li>
<li><code>fromTuple</code> - разобрать массив</li>
<li><code>fromData</code> - выбрать нужную фабрику</li>
</ul>
</li>
<li>
<p><strong>Strategy pattern:</strong> <code>fromData</code> выбирает стратегию на основе типа данных</p>
</li>
<li>
<p><strong>Приватность:</strong> Можно сделать поля приватными с геттерами</p>
</li>
</ol>
<pre><code class="language-javascript">class Item {
  #price; // Приватное поле

  constructor(name, price) {
    this.name = name;
    this.#price = price;
  }

  get price() {
    return this.#price;
  }
}
</code></pre>
<h3 id="Подход-к-strategy"><a class="header" href="#Подход-к-strategy">Подход к Strategy</a></h3>
<pre><code class="language-javascript">// Выбор фабрики из переменной
const factory = Array.isArray(data) ? Item.fromTuple : Item.fromStruct;
return factory(data, options);
</code></pre>
<p>Это начало паттерна Strategy - выбор алгоритма из коллекции на основе ключа/условия.</p>
<hr />
<h2 id="6-Рефакторинг-4-Функциональный-подход-с-замыканиями"><a class="header" href="#6-Рефакторинг-4-Функциональный-подход-с-замыканиями">6. Рефакторинг №4: Функциональный подход с замыканиями</a></h2>
<h3 id="Идея"><a class="header" href="#Идея">Идея</a></h3>
<p>Вместо хранения данных в полях объекта использовать замыкания (closures).</p>
<h3 id="Реализация"><a class="header" href="#Реализация">Реализация</a></h3>
<pre><code class="language-javascript">// Фабрика объектов с замыканиями
function item(name, price, options = {}) {
  const { converter } = options;
  const normalizedPrice =
    typeof price === 'string' &amp;&amp; converter
      ? converter(price)
      : parseFloat(price);

  // Данные в замыкании
  const finalName = name;
  const finalPrice = normalizedPrice;

  // Возвращаем объект с методами доступа
  return {
    getName: () =&gt; finalName,
    getPrice: () =&gt; finalPrice
  };
}

// Фабрики остаются похожими
function fromStruct({ name, price, cost, ...options }) {
  return item(name, price ?? cost, options);
}

function fromTuple([name, price], options) {
  return item(name, price, options);
}

function fromData(data, options = {}) {
  const factory = Array.isArray(data) ? fromTuple : fromStruct;
  return factory(data, options);
}
</code></pre>
<h3 id="Использование-1"><a class="header" href="#Использование-1">Использование</a></h3>
<pre><code class="language-javascript">const items = rawData.map(data =&gt; fromData(data));
const prices = items.map(item =&gt; item.getPrice());
</code></pre>
<h3 id="Преимущества"><a class="header" href="#Преимущества">Преимущества</a></h3>
<ol>
<li><strong>Иммутабельность:</strong> Данные нельзя модифицировать извне</li>
<li><strong>Инкапсуляция:</strong> Данные скрыты в замыкании</li>
<li><strong>Защита:</strong> Нет прямого доступа к переменным</li>
</ol>
<h3 id="Результат"><a class="header" href="#Результат">Результат</a></h3>
<pre><code class="language-javascript">console.log(item);
// { getName: [Function], getPrice: [Function] }
// Сами name и price не видны
</code></pre>
<hr />
<h2 id="7-Рефакторинг-5-Процедурный-код-финальная-версия"><a class="header" href="#7-Рефакторинг-5-Процедурный-код-финальная-версия">7. Рефакторинг №5: Процедурный код (финальная версия)</a></h2>
<h3 id="Философия-процедурного-стиля"><a class="header" href="#Философия-процедурного-стиля">Философия процедурного стиля</a></h3>
<p><strong>Почему процедурный?</strong></p>
<ul>
<li>Баланс между ФП и императивным стилем</li>
<li>Использование чистых функций</li>
<li>Не модифицируем state наружу, делаем return</li>
<li>Допускаются переменные (в отличие от чистого ФП)</li>
</ul>
<p><strong>Отличие от функционального:</strong></p>
<ul>
<li>В ФП не должно быть переменных - только expressions</li>
<li>В ФП функции очень маленькие (по 1 строке)</li>
<li>В процедурном допустимы if, for, переменные - более читаемо</li>
</ul>
<h3 id="Принципы"><a class="header" href="#Принципы">Принципы</a></h3>
<ol>
<li><strong>Чистые функции</strong> - не модифицируют внешний state</li>
<li><strong>Const по умолчанию</strong> - переменные только когда нужно</li>
<li><strong>Простые циклы</strong> - <code>for</code> вместо рекурсии</li>
<li><strong>Структуры данных</strong> - возвращаем объекты, а не храним в замыканиях</li>
</ol>
<h3 id="Реализация-1"><a class="header" href="#Реализация-1">Реализация</a></h3>
<pre><code class="language-javascript">// Всегда возвращаем объект одинаковой формы
function normalizeItem(data, options = {}) {
  const isTuple = Array.isArray(data);
  const obj = isTuple ? { name: data[0], price: data[1] } : data;
  const { name, price, cost } = obj;
  const value = price ?? cost;

  const { converter } = options;
  const normalizedPrice =
    typeof value === 'string' &amp;&amp; converter
      ? converter(value)
      : parseFloat(value);

  // Всегда одинаковая форма: { name: string, price: number }
  return { name, price: normalizedPrice };
}

function getPrice(item) {
  return item.price;
}
</code></pre>
<h3 id="Результат-1"><a class="header" href="#Результат-1">Результат</a></h3>
<pre><code class="language-javascript">const normalized = rawData.map(data =&gt; normalizeItem(data));
const prices = normalized.map(getPrice);

console.table(normalized);
// Все объекты имеют одинаковую форму { name, price }
</code></pre>
<h3 id="Итоговые-характеристики"><a class="header" href="#Итоговые-характеристики">Итоговые характеристики</a></h3>
<p>✅ <strong>Читаемость:</strong> последовательный код
✅ <strong>Производительность:</strong> одна форма объектов → V8 оптимизирует
✅ <strong>Тестируемость:</strong> чистые функции легко тестировать
✅ <strong>Модифицируемость:</strong> понятная структура
✅ <strong>Надёжность:</strong> consistent types</p>
<hr />
<h2 id="8-Ключевые-принципы-и-выводы"><a class="header" href="#8-Ключевые-принципы-и-выводы">8. Ключевые принципы и выводы</a></h2>
<h3 id="Принцип-single-responsibility-srp"><a class="header" href="#Принцип-single-responsibility-srp">Принцип Single Responsibility (SRP)</a></h3>
<p><strong>Определение:</strong> Каждая функция/класс должны иметь одну ответственность.</p>
<p><strong>Пример из лекции:</strong></p>
<ul>
<li><code>normalizeItem</code> - только нормализация</li>
<li><code>getPrice</code> - только извлечение цены</li>
<li><code>fromStruct</code> - только разбор объекта</li>
<li><code>fromTuple</code> - только разбор массива</li>
</ul>
<h3 id="Принцип-separation-of-concerns-soc"><a class="header" href="#Принцип-separation-of-concerns-soc">Принцип Separation of Concerns (SoC)</a></h3>
<p><strong>Определение:</strong> Разделение задач - каждый узел системы выполняет одну задачу.</p>
<p><strong>Применение:</strong></p>
<ul>
<li>Изолировать обработку сырых данных от бизнес-логики</li>
<li>Разделить raw и normalized данные</li>
<li>Логика проверок не проникает в бизнес-логику</li>
</ul>
<h3 id="weak-contracts-vs-strong-contracts"><a class="header" href="#weak-contracts-vs-strong-contracts">Weak Contracts vs Strong Contracts</a></h3>
<p><strong>Weak Contracts (плохо):</strong></p>
<pre><code class="language-javascript">// Бизнес-логика работает с сырыми данными
function businessLogic(rawData) {
  if (Array.isArray(rawData)) { /* ... */ }
  if (typeof rawData.price === 'string') { /* ... */ }
  // Проверки размазаны по всему коду
}
</code></pre>
<p><strong>Strong Contracts (хорошо):</strong></p>
<pre><code class="language-javascript">// Нормализация на входе
const normalized = rawData.map(normalizeItem);

// Бизнес-логика работает с чистыми данными
function businessLogic(normalizedData) {
  // Никаких проверок - данные уже консистентны
  return normalizedData.map(item =&gt; item.price * 1.2);
}
</code></pre>
<h3 id="Оптимизация-для-v8"><a class="header" href="#Оптимизация-для-v8">Оптимизация для V8</a></h3>
<p><strong>Правила:</strong></p>
<ol>
<li><strong>Одна форма объекта</strong> - всегда { name, price } в одном порядке</li>
<li><strong>Не менять форму</strong> - не использовать delete, не добавлять поля</li>
<li><strong>Не смешивать типы</strong> - в переменной всегда один тип</li>
<li><strong>Избегать дырявых массивов</strong> - не delete из массивов</li>
<li><strong>Const &gt; let &gt; var</strong> - предсказуемость для оптимизатора</li>
<li><strong>Меньше 4 форм</strong> - иначе мегаморфный код</li>
</ol>
<h3 id="Баланс-характеристик"><a class="header" href="#Баланс-характеристик">Баланс характеристик</a></h3>
<p>Код должен быть:</p>
<ul>
<li>✅ Читаемый</li>
<li>✅ Надёжный</li>
<li>✅ Стабильный</li>
<li>✅ Понятный</li>
<li>✅ Модифицируемый</li>
<li>✅ Тестируемый</li>
<li>✅ Достаточно оптимизированный</li>
</ul>
<p><strong>Не надо:</strong> Жертвовать всем ради максимальной производительности или максимальной красоты.</p>
<hr />
<h2 id="9-Практические-рекомендации"><a class="header" href="#9-Практические-рекомендации">9. Практические рекомендации</a></h2>
<h3 id="Что-использовать"><a class="header" href="#Что-использовать">Что использовать</a></h3>
<h4 id="-Использовать-всегда"><a class="header" href="#-Использовать-всегда">✅ Использовать всегда</a></h4>
<ul>
<li><code>const</code> по умолчанию</li>
<li>Строгое сравнение (<code>===</code>, <code>!==</code>)</li>
<li>Явное преобразование типов (<code>Number()</code>, <code>String()</code>)</li>
<li>Чистые функции</li>
<li>Consistent object shapes</li>
<li>Разделение raw и normalized данных</li>
</ul>
<h4 id="-Использовать-осторожно"><a class="header" href="#-Использовать-осторожно">⚠️ Использовать осторожно</a></h4>
<ul>
<li><code>let</code> - только если действительно нужна мутация</li>
<li>Тернарные операторы - только однострочные</li>
<li>Именованные параметры - в высокоуровневом коде</li>
<li>Классы - когда подходят паттерны ООП</li>
</ul>
<h4 id="-Избегать"><a class="header" href="#-Избегать">❌ Избегать</a></h4>
<ul>
<li><code>var</code></li>
<li><code>==</code> и <code>!=</code></li>
<li><code>delete</code> на объектах</li>
<li>Неявное приведение типов (<code>+str</code>, <code>str * 1</code>)</li>
<li>Последовательное присвоение (<code>a = b = c</code>)</li>
<li>Модификация аргументов функции</li>
<li>Closures, модифицирующие внешний scope</li>
<li>Деструктуризация массивов как tuples</li>
<li>Массивы с элементами разных типов</li>
<li>Изменение типа переменной</li>
</ul>
<h3 id="Когда-использовать-разные-стили"><a class="header" href="#Когда-использовать-разные-стили">Когда использовать разные стили</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Стиль</th><th>Когда использовать</th></tr></thead><tbody>
<tr><td><strong>Процедурный</strong></td><td>Основной стиль для прикладного кода. Баланс читаемости и производительности.</td></tr>
<tr><td><strong>ООП (классы)</strong></td><td>Паттерны, требующие инкапсуляции и полиморфизма. Статические фабрики.</td></tr>
<tr><td><strong>Функциональный</strong></td><td>Когда нужна иммутабельность и защита данных. Композиция функций.</td></tr>
</tbody></table>
</div>
<h3 id="subset-javascript"><a class="header" href="#subset-javascript">Subset JavaScript</a></h3>
<p><strong>Философия:</strong> Использовать подмножество возможностей JavaScript, а не всю мощь языка.</p>
<p><strong>Почему:</strong></p>
<ul>
<li>Повышает предсказуемость</li>
<li>Упрощает чтение кода</li>
<li>Помогает V8 оптимизировать</li>
<li>Снижает количество ошибок</li>
</ul>
<hr />
<h2 id="10-Типичные-ошибки-и-как-их-избежать"><a class="header" href="#10-Типичные-ошибки-и-как-их-избежать">10. Типичные ошибки и как их избежать</a></h2>
<h3 id="Ошибка-1-Переусложнение"><a class="header" href="#Ошибка-1-Переусложнение">Ошибка 1: Переусложнение</a></h3>
<pre><code class="language-javascript">// Плохо: использование всех возможностей JS
const price = options?.converter?.(value) ?? +value || parseFloat(value);

// Хорошо: простой и понятный код
const price = options.converter
  ? options.converter(value)
  : parseFloat(value);
</code></pre>
<h3 id="Ошибка-2-Игнорирование-формы-объектов"><a class="header" href="#Ошибка-2-Игнорирование-формы-объектов">Ошибка 2: Игнорирование формы объектов</a></h3>
<pre><code class="language-javascript">// Плохо: разные формы
const items = [
  { name: 'A', price: 10 },
  { price: 20, name: 'B' }, // Другой порядок полей!
  { name: 'C', cost: 30 }   // Другое поле!
];

// Хорошо: всегда одна форма
const normalizeItem = (raw) =&gt; ({
  name: raw.name,
  price: raw.price ?? raw.cost
});
const items = rawData.map(normalizeItem);
</code></pre>
<h3 id="Ошибка-3-Смешение-ответственностей"><a class="header" href="#Ошибка-3-Смешение-ответственностей">Ошибка 3: Смешение ответственностей</a></h3>
<pre><code class="language-javascript">// Плохо: функция делает всё
function processAndSave(rawData) {
  // Валидация
  // Нормализация
  // Бизнес-логика
  // Сохранение в БД
}

// Хорошо: разделение
function validate(data) { /* ... */ }
function normalize(data) { /* ... */ }
function process(data) { /* ... */ }
function save(data) { /* ... */ }

// Композиция
const result = save(process(normalize(validate(rawData))));
</code></pre>
<h3 id="Ошибка-4-Проверки-в-бизнес-логике"><a class="header" href="#Ошибка-4-Проверки-в-бизнес-логике">Ошибка 4: Проверки в бизнес-логике</a></h3>
<pre><code class="language-javascript">// Плохо
function calculateDiscount(item) {
  if (!item.price) return 0;
  if (typeof item.price === 'string') {
    item.price = parseFloat(item.price);
  }
  return item.price * 0.1;
}

// Хорошо: нормализация на входе
function calculateDiscount(item) {
  // item.price гарантированно number
  return item.price * 0.1;
}
</code></pre>
<hr />
<h2 id="11-Связь-с-паттернами-проектирования"><a class="header" href="#11-Связь-с-паттернами-проектирования">11. Связь с паттернами проектирования</a></h2>
<p>Эта лекция закладывает основу для изучения паттернов:</p>
<h3 id="strategy-начало-в-Рефакторинге-3"><a class="header" href="#strategy-начало-в-Рефакторинге-3">Strategy (начало в Рефакторинге №3)</a></h3>
<pre><code class="language-javascript">// Выбор стратегии на основе данных
const factory = Array.isArray(data) ? fromTuple : fromStruct;
return factory(data);
</code></pre>
<h3 id="factory-method"><a class="header" href="#factory-method">Factory Method</a></h3>
<pre><code class="language-javascript">// Статические фабрики - разновидность Factory
static fromStruct(data) { /* ... */ }
static fromTuple(data) { /* ... */ }
static fromData(data) { /* ... */ }
</code></pre>
<h3 id="solid-принципы"><a class="header" href="#solid-принципы">SOLID принципы</a></h3>
<ul>
<li><strong>S</strong> - Single Responsibility (разделение normalizeItem и getPrice)</li>
<li><strong>O</strong> - Open/Closed (фабрики можно расширять)</li>
<li><strong>L</strong> - Liskov Substitution (все фабрики возвращают совместимые объекты)</li>
<li><strong>I</strong> - Interface Segregation (минимальные интерфейсы)</li>
<li><strong>D</strong> - Dependency Inversion (options injection)</li>
</ul>
<hr />
<h2 id="12-Резюме"><a class="header" href="#12-Резюме">12. Резюме</a></h2>
<h3 id="Главные-выводы"><a class="header" href="#Главные-выводы">Главные выводы</a></h3>
<ol>
<li>
<p><strong>Баланс важнее крайностей</strong> - нужен компромисс между производительностью и читаемостью</p>
</li>
<li>
<p><strong>Разделяй и властвуй</strong> - декомпозиция улучшает все характеристики кода</p>
</li>
<li>
<p><strong>Изолируй сложность</strong> - проверки и нормализация на входе, чистая логика внутри</p>
</li>
<li>
<p><strong>Консистентность данных</strong> - одна форма объектов, predictable types</p>
</li>
<li>
<p><strong>Subset &gt; Full power</strong> - использовать простое подмножество JS, а не все возможности</p>
</li>
</ol>
<h3 id="Практический-чеклист"><a class="header" href="#Практический-чеклист">Практический чеклист</a></h3>
<p>При написании кода проверяйте:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Используется <code>const</code> везде, где возможно</li>
<li><input disabled="" type="checkbox"/>
Строгое сравнение (<code>===</code>, <code>!==</code>)</li>
<li><input disabled="" type="checkbox"/>
Одна ответственность на функцию</li>
<li><input disabled="" type="checkbox"/>
Нет дупликации кода</li>
<li><input disabled="" type="checkbox"/>
Сырые данные нормализованы на входе</li>
<li><input disabled="" type="checkbox"/>
Объекты имеют одинаковую форму</li>
<li><input disabled="" type="checkbox"/>
Нет изменения формы объектов</li>
<li><input disabled="" type="checkbox"/>
Явное преобразование типов</li>
<li><input disabled="" type="checkbox"/>
Чистые функции (не модифицируют внешний state)</li>
<li><input disabled="" type="checkbox"/>
Consistent return types</li>
</ul>
<h3 id="Дальнейшее-изучение"><a class="header" href="#Дальнейшее-изучение">Дальнейшее изучение</a></h3>
<p><strong>Для углубления:</strong></p>
<ul>
<li>Оптимизации V8 (скрытые классы, inline caching)</li>
<li>SOLID и GRASP принципы</li>
<li>Паттерны проектирования на JavaScript/TypeScript</li>
<li>Функциональное программирование</li>
<li>TypeScript advanced types</li>
</ul>
<hr />
<h2 id="Ссылки-и-материалы"><a class="header" href="#Ссылки-и-материалы">Ссылки и материалы</a></h2>
<p><strong>Из лекции упоминались:</strong></p>
<ul>
<li>Блог Вячеслава Егорова (разработчик V8) - про оптимизации виртуальной машины</li>
<li>Статьи про скрытые классы и inline caching</li>
<li>Дополнительные видео и стримы по паттернам</li>
</ul>
<p><strong>Код из лекции:</strong></p>
<ul>
<li>Исходники всех примеров рефакторинга</li>
<li>Задачи для самостоятельной работы</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../week1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../week1/grasp-principles-lecture-notes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../week1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../week1/grasp-principles-lecture-notes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
