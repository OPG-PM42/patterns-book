<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Layers and Low Coupling на примере конфига и транспорта - Patterns</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Patterns</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="nodejs-Слои-и-Слабое-Зацепление-на-примере-конфигурации-и-транспорта"><a class="header" href="#nodejs-Слои-и-Слабое-Зацепление-на-примере-конфигурации-и-транспорта">Node.js: Слои и Слабое Зацепление на примере конфигурации и транспорта</a></h1>
<h2 id="Обзор"><a class="header" href="#Обзор">Обзор</a></h2>
<p>Эта лекция посвящена архитектуре Node.js приложений с акцентом на разделение по слоям (Layers) и принцип слабого зацепления (Low Coupling). Мы рассмотрим практические примеры рефакторинга, включая вынос конфигурации из приложения, абстрагирование транспортных слоев (HTTP и WebSocket) и применение принципа инъекции зависимостей (Dependency Injection) через различные механизмы.</p>
<p><strong>Основные темы:</strong></p>
<ul>
<li>Вынос конфигурации в отдельный модуль</li>
<li>Абстрагирование транспортов</li>
<li>Слабое зацепление модулей</li>
<li>Инъекция зависимостей через замыкания</li>
<li>Отказ от кастомного лоадера в пользу CommonJS</li>
</ul>
<hr />
<h2 id="Часть-1-Вынос-конфигурации-из-приложения"><a class="header" href="#Часть-1-Вынос-конфигурации-из-приложения">Часть 1: Вынос конфигурации из приложения</a></h2>
<h3 id="Проблема-Конфигурация-распределена-по-коду"><a class="header" href="#Проблема-Конфигурация-распределена-по-коду">Проблема: Конфигурация распределена по коду</a></h3>
<p>Раньше конфигурация была встроена прямо в код приложения. Это создавало проблемы:</p>
<ul>
<li>Сильное зацепление (tight coupling) между модулями и конфигурацией</li>
<li>Сложность тестирования</li>
<li>Невозможность легко изменять параметры</li>
<li>Модули импортируют конфигурацию повсеместно</li>
</ul>
<h3 id="Решение-Централизованная-конфигурация"><a class="header" href="#Решение-Централизованная-конфигурация">Решение: Централизованная конфигурация</a></h3>
<p>Все настройки выносятся в один файл конфигурации (например, <code>config.js</code>).</p>
<h4 id="Пример-структуры-конфига"><a class="header" href="#Пример-структуры-конфига">Пример структуры конфига</a></h4>
<pre><code class="language-javascript">// config.js
'use strict';

module.exports = {
  // Порт для отдачи статики
  static: {
    port: 8000
  },

  // Порт для API
  api: {
    port: 8001,
    transport: 'http' // или 'ws' для WebSocket
  },

  // Настройки Sandbox для изоляции прикладного кода
  sandbox: {
    timeout: 5000,
    displayErrors: false
  },

  // Подключение к базе данных
  db: {
    host: 'localhost',
    port: 5432,
    database: 'application',
    user: 'user',
    password: 'password'
  }
};
</code></pre>
<h3 id="Принцип-единственной-точки-входа"><a class="header" href="#Принцип-единственной-точки-входа">Принцип единственной точки входа</a></h3>
<p><strong>Важно:</strong> Конфиг должен импортироваться <strong>только в одном месте</strong> — в точке входа приложения (<code>main.js</code>).</p>
<pre><code class="language-javascript">// main.js
'use strict';

const config = require('./config.js');

// Дальше конфиг передается через зависимости,
// а не импортируется повсеместно
</code></pre>
<p><strong>Почему это важно:</strong></p>
<ul>
<li>Централизованное управление конфигурацией</li>
<li>Легко отследить, где и как используются настройки</li>
<li>Упрощается тестирование (можно подменить конфиг)</li>
<li>Снижается зацепление между модулями</li>
</ul>
<hr />
<h2 id="Часть-2-Инъекция-зависимостей-через-замыкания"><a class="header" href="#Часть-2-Инъекция-зависимостей-через-замыкания">Часть 2: Инъекция зависимостей через замыкания</a></h2>
<h3 id="Концепция"><a class="header" href="#Концепция">Концепция</a></h3>
<p>Вместо импорта конфигурации в каждом модуле, мы <strong>инжектируем</strong> нужные части конфигурации через замыкания (closures).</p>
<h3 id="Пример-1-Инъекция-настроек-в-sandbox-loader"><a class="header" href="#Пример-1-Инъекция-настроек-в-sandbox-loader">Пример 1: Инъекция настроек в Sandbox loader</a></h3>
<p><strong>До рефакторинга:</strong></p>
<pre><code class="language-javascript">// loader.js
'use strict';

const config = require('./config.js'); // Плохо: импорт конфига

module.exports = (filename) =&gt; {
  const timeout = config.sandbox.timeout;
  // ... код
};
</code></pre>
<p><strong>После рефакторинга:</strong></p>
<pre><code class="language-javascript">// loader.js
'use strict';

// Экспортируем функцию, которая принимает options
module.exports = (options) =&gt; {
  // Возвращаем функцию-загрузчик
  return (filename) =&gt; {
    const { timeout } = options; // options попадает в замыкание

    const sandbox = {
      console,
      setTimeout,
      // ... остальные API
    };

    const context = vm.createContext(sandbox);
    // ... код запуска в sandbox
  };
};
</code></pre>
<p><strong>Использование в main.js:</strong></p>
<pre><code class="language-javascript">// main.js
const config = require('./config.js');
const createLoader = require('./loader.js');

// Передаем только нужную часть конфига
const loader = createLoader(config.sandbox);

// Теперь loader содержит настройки в замыкании
</code></pre>
<p><strong>Преимущества:</strong></p>
<ul>
<li>Модуль <code>loader.js</code> не знает про существование файла <code>config.js</code></li>
<li>Настройки попадают в замыкание и доступны внутри функции</li>
<li>Модуль получает <strong>только то, что ему нужно</strong>, а не весь конфиг</li>
</ul>
<h3 id="Пример-2-Инъекция-настроек-базы-данных"><a class="header" href="#Пример-2-Инъекция-настроек-базы-данных">Пример 2: Инъекция настроек базы данных</a></h3>
<pre><code class="language-javascript">// db.js
'use strict';

const pg = require('pg');

// Экспортируем функцию высшего порядка
module.exports = (options) =&gt; {
  // Создаем пул подключений с переданными настройками
  const pool = new pg.Pool(options);

  // Возвращаем функцию для создания CRUD операций
  const crud = (pool) =&gt; {
    return (tableName) =&gt; {
      return {
        async create(record) {
          const keys = Object.keys(record).join(', ');
          const values = Object.values(record);
          const params = values.map((_, i) =&gt; `$${i + 1}`).join(', ');
          const sql = `INSERT INTO ${tableName} (${keys}) VALUES (${params})`;
          const result = await pool.query(sql, values);
          return result.rows[0];
        },

        async read(id) {
          const sql = `SELECT * FROM ${tableName} WHERE id = $1`;
          const result = await pool.query(sql, [id]);
          return result.rows[0];
        },

        async update(id, record) {
          const keys = Object.keys(record);
          const values = Object.values(record);
          const set = keys.map((key, i) =&gt; `${key} = $${i + 2}`).join(', ');
          const sql = `UPDATE ${tableName} SET ${set} WHERE id = $1`;
          await pool.query(sql, [id, ...values]);
        },

        async delete(id) {
          const sql = `DELETE FROM ${tableName} WHERE id = $1`;
          await pool.query(sql, [id]);
        }
      };
    };
  };

  // Вызываем crud с пулом и возвращаем результат
  return crud(pool);
};
</code></pre>
<p><strong>Использование:</strong></p>
<pre><code class="language-javascript">// main.js
const config = require('./config.js');
const db = require('./db.js');

// Инжектируем настройки БД
const createCrud = db(config.db);

// Создаем CRUD для конкретной таблицы
const usersCrud = createCrud('users');

// Используем
await usersCrud.create({ name: 'John', email: 'john@example.com' });
</code></pre>
<p><strong>Цепочка вызовов:</strong></p>
<ol>
<li><code>db(config.db)</code> — передаем настройки, создаем пул, возвращаем функцию <code>crud</code></li>
<li><code>createCrud('users')</code> — передаем имя таблицы, возвращаем объект с методами CRUD</li>
<li>Пул и имя таблицы находятся в замыкании</li>
</ol>
<hr />
<h2 id="Часть-3-Инъекция-логгера"><a class="header" href="#Часть-3-Инъекция-логгера">Часть 3: Инъекция логгера</a></h2>
<h3 id="Проблема-использования-глобального-console"><a class="header" href="#Проблема-использования-глобального-console">Проблема использования глобального console</a></h3>
<p>Во многих модулях используется глобальный объект <code>console</code>, который:</p>
<ul>
<li>Невозможно переопределить или подменить</li>
<li>Не позволяет централизованно управлять логированием</li>
<li>Усложняет тестирование</li>
</ul>
<h3 id="Решение-Инъекция-кастомного-логгера"><a class="header" href="#Решение-Инъекция-кастомного-логгера">Решение: Инъекция кастомного логгера</a></h3>
<pre><code class="language-javascript">// logger.js
'use strict';

const pino = require('pino');

const logger = pino({
  level: 'info',
  transport: {
    target: 'pino-pretty',
    options: {
      colorize: true
    }
  }
});

// Создаем обертку с интерфейсом console
module.exports = {
  log: (...args) =&gt; logger.info(...args),
  error: (...args) =&gt; logger.error(...args),
  warn: (...args) =&gt; logger.warn(...args),
  debug: (...args) =&gt; logger.debug(...args),
};
</code></pre>
<p><strong>Использование в транспорте:</strong></p>
<pre><code class="language-javascript">// transport/ws.js
'use strict';

const { WebSocket } = require('ws');

module.exports = (routing, port, console) =&gt; {
  const ws = new WebSocket.Server({ port });

  ws.on('connection', (connection) =&gt; {
    console.log('WebSocket client connected'); // Используем инжектированный логгер

    connection.on('message', async (message) =&gt; {
      const { method, args } = JSON.parse(message);
      console.log(`Call: ${method}`, args);

      const handler = routing[method];
      if (!handler) {
        console.error(`Method not found: ${method}`);
        return;
      }

      const result = await handler(...args);
      connection.send(JSON.stringify(result));
    });
  });

  console.log(`WebSocket server on port ${port}`);
};
</code></pre>
<p><strong>В main.js:</strong></p>
<pre><code class="language-javascript">// main.js
const logger = require('./logger.js');
const transport = require('./transport/ws.js');

// Инжектируем логгер в транспорт
transport(routing, config.api.port, logger);
</code></pre>
<p><strong>Альтернатива — перекрытие имени:</strong></p>
<pre><code class="language-javascript">// static.js
module.exports = (path, port, console) =&gt; {
  // console теперь указывает на переданный логгер,
  // а не на глобальный объект

  const server = http.createServer((req, res) =&gt; {
    console.log(`${req.method} ${req.url}`);
    // ...
  });

  server.listen(port);
  console.log(`Static server on port ${port}`);
};
</code></pre>
<hr />
<h2 id="Часть-4-Абстрагирование-транспортов"><a class="header" href="#Часть-4-Абстрагирование-транспортов">Часть 4: Абстрагирование транспортов</a></h2>
<h3 id="Цель"><a class="header" href="#Цель">Цель</a></h3>
<p>Сделать приложение независимым от конкретного транспорта (HTTP или WebSocket). Переключение транспорта должно происходить изменением <strong>одного параметра в конфигурации</strong>.</p>
<h3 id="Структура-папки-transport"><a class="header" href="#Структура-папки-transport">Структура папки transport</a></h3>
<pre><code>transport/
├── http.js    # HTTP транспорт
└── ws.js      # WebSocket транспорт
</code></pre>
<h3 id="Контракт-транспорта"><a class="header" href="#Контракт-транспорта">Контракт транспорта</a></h3>
<p>Оба транспорта должны экспортировать функцию с одинаковой сигнатурой:</p>
<pre><code class="language-javascript">module.exports = (routing, port, console) =&gt; {
  // Инициализация транспорта
  // ...
};
</code></pre>
<p><strong>Параметры:</strong></p>
<ul>
<li><code>routing</code> — объект с методами API (маршрутизация)</li>
<li><code>port</code> — порт для запуска сервера</li>
<li><code>console</code> — логгер для вывода информации</li>
</ul>
<h3 id="Реализация-http-транспорта"><a class="header" href="#Реализация-http-транспорта">Реализация HTTP транспорта</a></h3>
<pre><code class="language-javascript">// transport/http.js
'use strict';

const http = require('http');

module.exports = (routing, port, console) =&gt; {
  const HEADERS = {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type',
  };

  const server = http.createServer(async (req, res) =&gt; {
    // Обработка CORS preflight
    if (req.method === 'OPTIONS') {
      res.writeHead(200, HEADERS);
      res.end();
      return;
    }

    // Парсинг URL: /api/interfaceName/methodName
    const url = req.url.split('/');
    const interfaceName = url[2];
    const methodName = url[3];

    console.log(`HTTP Call: ${interfaceName}.${methodName}`);

    // Получаем тело запроса
    let body = '';
    req.on('data', chunk =&gt; {
      body += chunk.toString();
    });

    req.on('end', async () =&gt; {
      const args = JSON.parse(body);
      const method = routing[methodName];

      if (!method) {
        res.writeHead(404, HEADERS);
        res.end(JSON.stringify({ error: 'Method not found' }));
        return;
      }

      try {
        const result = await method(...args);
        res.writeHead(200, HEADERS);
        res.end(JSON.stringify(result));
      } catch (error) {
        console.error(error);
        res.writeHead(500, HEADERS);
        res.end(JSON.stringify({ error: error.message }));
      }
    });
  });

  server.listen(port);
  console.log(`HTTP API server on port ${port}`);
};
</code></pre>
<h3 id="Реализация-websocket-транспорта"><a class="header" href="#Реализация-websocket-транспорта">Реализация WebSocket транспорта</a></h3>
<pre><code class="language-javascript">// transport/ws.js
'use strict';

const { WebSocketServer } = require('ws');

module.exports = (routing, port, console) =&gt; {
  const wss = new WebSocketServer({ port });

  wss.on('connection', (connection) =&gt; {
    console.log('WebSocket client connected');

    connection.on('message', async (message) =&gt; {
      const packet = JSON.parse(message);
      const { method, args } = packet;

      console.log(`WS Call: ${method}`, args);

      const handler = routing[method];

      if (!handler) {
        console.error(`Method not found: ${method}`);
        connection.send(JSON.stringify({ error: 'Method not found' }));
        return;
      }

      try {
        const result = await handler(...args);
        connection.send(JSON.stringify({ result }));
      } catch (error) {
        console.error(error);
        connection.send(JSON.stringify({ error: error.message }));
      }
    });

    connection.on('close', () =&gt; {
      console.log('WebSocket client disconnected');
    });
  });

  console.log(`WebSocket API server on port ${port}`);
};
</code></pre>
<h3 id="Динамическая-загрузка-транспорта-в-mainjs"><a class="header" href="#Динамическая-загрузка-транспорта-в-mainjs">Динамическая загрузка транспорта в main.js</a></h3>
<pre><code class="language-javascript">// main.js
'use strict';

const config = require('./config.js');
const logger = require('./logger.js');

// Динамически загружаем транспорт из конфига
const transportName = config.api.transport; // 'http' или 'ws'
const transport = require(`./transport/${transportName}.js`);

// Загружаем API (routing)
const routing = {};
const apiPath = './api';
const files = fs.readdirSync(apiPath);

for (const file of files) {
  const modulePath = path.join(apiPath, file);
  const methods = require(modulePath);
  Object.assign(routing, methods);
}

// Запускаем транспорт с инжекцией зависимостей
transport(routing, config.api.port, logger);
</code></pre>
<p><strong>Переключение транспорта:</strong></p>
<pre><code class="language-javascript">// config.js
module.exports = {
  api: {
    port: 8001,
    transport: 'http' // Меняем на 'ws' для WebSocket
  }
};
</code></pre>
<hr />
<h2 id="Часть-5-Абстрагирование-транспорта-на-клиенте"><a class="header" href="#Часть-5-Абстрагирование-транспорта-на-клиенте">Часть 5: Абстрагирование транспорта на клиенте</a></h2>
<h3 id="Цель-1"><a class="header" href="#Цель-1">Цель</a></h3>
<p>Клиентское приложение должно уметь работать с разными транспортами без изменения бизнес-логики.</p>
<h3 id="scaffold--динамическое-создание-api"><a class="header" href="#scaffold--динамическое-создание-api">Scaffold — динамическое создание API</a></h3>
<p><strong>Идея:</strong> На клиенте мы создаем прокси-объект, который имитирует серверное API. Вызов методов автоматически превращается в сетевые запросы.</p>
<pre><code class="language-javascript">// client.js
'use strict';

const scaffolds = {
  http: (url) =&gt; (structure) =&gt; {
    const api = {};
    for (const interfaceName in structure) {
      api[interfaceName] = {};
      const methods = structure[interfaceName];

      for (const methodName of methods) {
        api[interfaceName][methodName] = (...args) =&gt; {
          return fetch(`${url}/${interfaceName}/${methodName}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(args)
          }).then(res =&gt; res.json());
        };
      }
    }
    return api;
  },

  ws: (url) =&gt; (structure) =&gt; {
    const socket = new WebSocket(url);
    const api = {};
    const calls = new Map();
    let callId = 0;

    socket.addEventListener('message', (event) =&gt; {
      const packet = JSON.parse(event.data);
      const { id, result, error } = packet;
      const { resolve, reject } = calls.get(id);

      if (error) reject(new Error(error));
      else resolve(result);

      calls.delete(id);
    });

    for (const interfaceName in structure) {
      api[interfaceName] = {};
      const methods = structure[interfaceName];

      for (const methodName of methods) {
        api[interfaceName][methodName] = (...args) =&gt; {
          return new Promise((resolve, reject) =&gt; {
            const id = callId++;
            calls.set(id, { resolve, reject });

            const packet = { id, method: methodName, args };
            socket.send(JSON.stringify(packet));
          });
        };
      }
    }

    return new Promise((resolve) =&gt; {
      socket.addEventListener('open', () =&gt; resolve(api));
    });
  }
};

// Определение транспорта по URL
const scaffold = (url, structure) =&gt; {
  const protocol = url.startsWith('ws://') || url.startsWith('wss://') ? 'ws' : 'http';
  const transport = scaffolds[protocol];
  return transport(url)(structure);
};

// Использование
const api = await scaffold('http://localhost:8001', {
  test: ['say']
});

// Вызов метода — прозрачно, без знания о транспорте
const result = await api.test.say('Hello');
console.log(result); // { status: 'OK' }
</code></pre>
<p><strong>Переключение транспорта:</strong></p>
<pre><code class="language-javascript">// Для HTTP
const api = await scaffold('http://localhost:8001', structure);

// Для WebSocket (меняем только URL)
const api = await scaffold('ws://localhost:8001', structure);
</code></pre>
<hr />
<h2 id="Часть-6-Слои-и-low-coupling"><a class="header" href="#Часть-6-Слои-и-low-coupling">Часть 6: Слои и Low Coupling</a></h2>
<h3 id="Модель-isoosi-как-аналогия"><a class="header" href="#Модель-isoosi-как-аналогия">Модель ISO/OSI как аналогия</a></h3>
<p>В сетевой модели ISO/OSI каждый слой взаимодействует <strong>только с соседними слоями</strong>. Например:</p>
<ul>
<li><strong>Application Layer</strong> на клиенте общается с <strong>Application Layer</strong> на сервере</li>
<li>Но физически данные проходят через все нижележащие слои (Transport, Network, Data Link, Physical)</li>
</ul>
<p><strong>Преимущества:</strong></p>
<ul>
<li>Каждый слой решает свою задачу</li>
<li>Слои не знают о деталях реализации других слоев</li>
<li>Можно заменить реализацию слоя без изменения других</li>
</ul>
<h3 id="Применение-в-nodejs-приложении"><a class="header" href="#Применение-в-nodejs-приложении">Применение в Node.js приложении</a></h3>
<pre><code>┌─────────────────────────────────────┐
│   Business Logic (API methods)      │  ← Прикладной уровень
├─────────────────────────────────────┤
│   Routing (метод → обработчик)      │  ← Уровень маршрутизации
├─────────────────────────────────────┤
│   Transport (HTTP / WebSocket)      │  ← Транспортный уровень
├─────────────────────────────────────┤
│   Infrastructure (Config, Logger)   │  ← Инфраструктурный уровень
└─────────────────────────────────────┘
</code></pre>
<p><strong>Принцип Low Coupling:</strong></p>
<ul>
<li>Бизнес-логика <strong>не знает</strong> про транспорт</li>
<li>Транспорт <strong>не знает</strong> про конфигурацию (получает только порт)</li>
<li>Маршрутизация <strong>не знает</strong> про логирование (получает логгер как зависимость)</li>
</ul>
<h3 id="Пример-api-метод-не-зависит-от-транспорта"><a class="header" href="#Пример-api-метод-не-зависит-от-транспорта">Пример: API метод не зависит от транспорта</a></h3>
<pre><code class="language-javascript">// api/test.js
'use strict';

module.exports = {
  async say(message) {
    console.log('Received message:', message);
    return { status: 'OK', echo: message };
  }
};
</code></pre>
<p><strong>Этот код работает одинаково при любом транспорте!</strong></p>
<hr />
<h2 id="Часть-7-Отказ-от-кастомного-лоадера"><a class="header" href="#Часть-7-Отказ-от-кастомного-лоадера">Часть 7: Отказ от кастомного лоадера</a></h2>
<h3 id="Зачем-нужен-был-лоадер"><a class="header" href="#Зачем-нужен-был-лоадер">Зачем нужен был лоадер?</a></h3>
<p>Кастомный лоадер позволял:</p>
<ul>
<li>Автоматически загружать модули из папки</li>
<li>Инжектировать зависимости в контекст модуля через VM sandbox</li>
<li>Изолировать прикладной код</li>
</ul>
<h3 id="Переход-на-commonjs"><a class="header" href="#Переход-на-commonjs">Переход на CommonJS</a></h3>
<p>В примере <strong>C</strong> лоадер удален, используется стандартный <code>require</code>.</p>
<p><strong>До (с лоадером):</strong></p>
<pre><code class="language-javascript">// main.js
const loader = require('./loader.js');

const apiPath = './api';
const files = fs.readdirSync(apiPath);

const api = {};
for (const file of files) {
  const modulePath = path.join(apiPath, file);
  const module = loader(modulePath);
  Object.assign(api, module);
}
</code></pre>
<p><strong>После (без лоадера):</strong></p>
<pre><code class="language-javascript">// main.js
const apiPath = './api';
const files = fs.readdirSync(apiPath);

const routing = {};
for (const file of files) {
  const modulePath = path.join(apiPath, file);
  const methods = require(modulePath);
  Object.assign(routing, methods);
}
</code></pre>
<p><strong>Последствия:</strong></p>
<ul>
<li>Код проще и понятнее</li>
<li>Минус один уровень абстракции</li>
<li>Модули выполняются в общем контексте Node.js</li>
<li>Но теряется изоляция</li>
</ul>
<hr />
<h2 id="Часть-8-mime-типы-для-статического-сервера"><a class="header" href="#Часть-8-mime-типы-для-статического-сервера">Часть 8: MIME-типы для статического сервера</a></h2>
<p>При отдаче статических файлов нужно указывать правильный <code>Content-Type</code>.</p>
<h3 id="Словарь-mime-типов"><a class="header" href="#Словарь-mime-типов">Словарь MIME-типов</a></h3>
<pre><code class="language-javascript">// static.js
const MIME_TYPES = {
  html: 'text/html; charset=UTF-8',
  js: 'application/javascript; charset=UTF-8',
  css: 'text/css',
  png: 'image/png',
  ico: 'image/x-icon',
  svg: 'image/svg+xml',
  json: 'application/json',
};
</code></pre>
<h3 id="Использование"><a class="header" href="#Использование">Использование</a></h3>
<pre><code class="language-javascript">// static.js
'use strict';

const http = require('http');
const fs = require('fs');
const path = require('path');

const MIME_TYPES = {
  html: 'text/html; charset=UTF-8',
  js: 'application/javascript; charset=UTF-8',
  css: 'text/css',
  png: 'image/png',
  ico: 'image/x-icon',
  svg: 'image/svg+xml',
};

const HEADERS = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type',
};

module.exports = (staticPath, port, console) =&gt; {
  const server = http.createServer((req, res) =&gt; {
    const filePath = path.join(staticPath, req.url === '/' ? 'index.html' : req.url);
    const ext = path.extname(filePath).substring(1);
    const mimeType = MIME_TYPES[ext] || 'application/octet-stream';

    fs.readFile(filePath, (err, data) =&gt; {
      if (err) {
        res.writeHead(404, { 'Content-Type': 'text/plain' });
        res.end('Not Found');
        return;
      }

      res.writeHead(200, { ...HEADERS, 'Content-Type': mimeType });
      res.end(data);
    });
  });

  server.listen(port);
  console.log(`Static server on port ${port}`);
};
</code></pre>
<hr />
<h2 id="Часть-9-Способы-инъекции-зависимостей"><a class="header" href="#Часть-9-Способы-инъекции-зависимостей">Часть 9: Способы инъекции зависимостей</a></h2>
<p>В лекции были рассмотрены <strong>несколько способов</strong> внедрения зависимостей (Dependency Injection).</p>
<h3 id="Способ-1-Через-замыкание-closure-injection"><a class="header" href="#Способ-1-Через-замыкание-closure-injection">Способ 1: Через замыкание (Closure Injection)</a></h3>
<pre><code class="language-javascript">// module.js
module.exports = (dependency) =&gt; {
  return () =&gt; {
    // dependency доступна в замыкании
    dependency.doSomething();
  };
};

// main.js
const createModule = require('./module.js');
const module = createModule(someDependency);
</code></pre>
<p><strong>Плюсы:</strong></p>
<ul>
<li>Простота</li>
<li>Зависимость попадает в замыкание и всегда доступна</li>
<li>Нет глобального состояния</li>
</ul>
<h3 id="Способ-2-Через-require-singleton"><a class="header" href="#Способ-2-Через-require-singleton">Способ 2: Через require (Singleton)</a></h3>
<pre><code class="language-javascript">// logger.js
const pino = require('pino');
const logger = pino();
module.exports = logger;

// module1.js
const logger = require('./logger.js'); // Получает singleton
logger.info('Module 1');

// module2.js
const logger = require('./logger.js'); // Тот же экземпляр
logger.info('Module 2');
</code></pre>
<p><strong>Плюсы:</strong></p>
<ul>
<li>Автоматическое создание синглтона через кэш <code>require</code></li>
<li>Не нужно передавать зависимость явно</li>
</ul>
<p><strong>Минусы:</strong></p>
<ul>
<li>Сильное зацепление</li>
<li>Сложно тестировать (нужно чистить кэш <code>require</code>)</li>
</ul>
<h3 id="Способ-3-Через-конструктор-класса-constructor-injection"><a class="header" href="#Способ-3-Через-конструктор-класса-constructor-injection">Способ 3: Через конструктор класса (Constructor Injection)</a></h3>
<pre><code class="language-javascript">// Database.js
class Database {
  constructor(config, logger) {
    this.config = config;
    this.logger = logger;
    this.pool = new Pool(config);
  }

  async query(sql, params) {
    this.logger.info('Query:', sql);
    return this.pool.query(sql, params);
  }
}

module.exports = Database;

// main.js
const Database = require('./Database.js');
const db = new Database(config.db, logger);
</code></pre>
<p><strong>Плюсы:</strong></p>
<ul>
<li>Явная передача зависимостей</li>
<li>Легко тестировать (можно передать моки)</li>
<li>ООП подход</li>
</ul>
<h3 id="Способ-4-Через-sandbox-context-injection"><a class="header" href="#Способ-4-Через-sandbox-context-injection">Способ 4: Через Sandbox (Context Injection)</a></h3>
<pre><code class="language-javascript">// loader.js
const vm = require('vm');

module.exports = (filename, context) =&gt; {
  const code = fs.readFileSync(filename, 'utf8');
  const sandbox = { ...context, console, setTimeout };
  vm.runInContext(code, vm.createContext(sandbox));
};

// main.js
const context = {
  db: database,
  logger: logger,
  config: config
};

loader('./app.js', context);
</code></pre>
<p><strong>Плюсы:</strong></p>
<ul>
<li>Полная изоляция</li>
<li>Контроль над доступным API</li>
</ul>
<p><strong>Минусы:</strong></p>
<ul>
<li>Сложность</li>
<li>Производительность</li>
</ul>
<hr />
<h2 id="Резюме"><a class="header" href="#Резюме">Резюме</a></h2>
<h3 id="Что-было-сделано-в-лекции"><a class="header" href="#Что-было-сделано-в-лекции">Что было сделано в лекции:</a></h3>
<ol>
<li><strong>Вынесли конфигурацию</strong> в отдельный файл</li>
<li><strong>Создали единую точку входа</strong> для импорта конфига (main.js)</li>
<li><strong>Применили инъекцию зависимостей через замыкания</strong> для передачи:
<ul>
<li>Настроек Sandbox в loader</li>
<li>Настроек БД в db модуль</li>
<li>Логгера в транспорты</li>
<li>Порта в HTTP/WebSocket серверы</li>
</ul>
</li>
<li><strong>Абстрагировали транспорты:</strong>
<ul>
<li>Создали папку <code>transport/</code> с модулями <code>http.js</code> и <code>ws.js</code></li>
<li>Унифицировали контракт транспорта: <code>(routing, port, console) =&gt; {}</code></li>
<li>Реализовали динамическую загрузку транспорта из конфига</li>
</ul>
</li>
<li><strong>Реализовали scaffold на клиенте</strong> для автоматического создания API-прокси</li>
<li><strong>Показали переход от кастомного лоадера к CommonJS</strong></li>
<li><strong>Применили принцип Low Coupling:</strong>
<ul>
<li>Бизнес-логика не знает про транспорт</li>
<li>Транспорт не знает про конфигурацию</li>
<li>Модули получают только необходимые зависимости</li>
</ul>
</li>
</ol>
<h3 id="Домашнее-задание"><a class="header" href="#Домашнее-задание">Домашнее задание</a></h3>
<p><strong>Задание 5:</strong> Сделать подключаемый фреймворк (по аналогии с транспортом)</p>
<p><strong>Задание 7:</strong> Сделать подключаемый логгер (Pino или другой):</p>
<ul>
<li>Создать обертку, реализующую интерфейс <code>console</code></li>
<li>Инжектировать во все модули через замыкание</li>
<li>Обеспечить возможность переключения между нативным <code>console</code> и кастомным логгером</li>
</ul>
<h3 id="Ключевые-принципы"><a class="header" href="#Ключевые-принципы">Ключевые принципы</a></h3>
<p><strong>Low Coupling (Слабое зацепление):</strong></p>
<ul>
<li>Модули зависят от абстракций, а не от конкретных реализаций</li>
<li>Каждый модуль получает только то, что ему нужно</li>
<li>Изменения в одном модуле не затрагивают другие</li>
</ul>
<p><strong>Layered Architecture (Слоистая архитектура):</strong></p>
<ul>
<li>Четкое разделение ответственности между слоями</li>
<li>Слои взаимодействуют только через определенные интерфейсы</li>
<li>Возможность заменить реализацию слоя без изменения других</li>
</ul>
<p><strong>Dependency Injection (Инъекция зависимостей):</strong></p>
<ul>
<li>Зависимости передаются извне, а не создаются внутри модуля</li>
<li>Упрощает тестирование и переиспользование кода</li>
<li>Можно реализовать через замыкания, конструкторы, или контекст</li>
</ul>
<hr />
<h2 id="Дополнительные-примеры"><a class="header" href="#Дополнительные-примеры">Дополнительные примеры</a></h2>
<h3 id="Пример-Полный-цикл-запроса-через-слои"><a class="header" href="#Пример-Полный-цикл-запроса-через-слои">Пример: Полный цикл запроса через слои</a></h3>
<p><strong>Клиент (Browser):</strong></p>
<pre><code class="language-javascript">const api = await scaffold('http://localhost:8001', {
  test: ['say']
});

const result = await api.test.say('Hello');
console.log(result); // { status: 'OK', echo: 'Hello' }
</code></pre>
<p><strong>Сервер — Транспортный слой (HTTP):</strong></p>
<pre><code class="language-javascript">// transport/http.js
// Получает запрос POST /api/test/say
// Парсит тело: ["Hello"]
// Вызывает routing.say("Hello")
// Отправляет ответ: {"status": "OK", "echo": "Hello"}
</code></pre>
<p><strong>Сервер — Бизнес-логика:</strong></p>
<pre><code class="language-javascript">// api/test.js
module.exports = {
  async say(message) {
    return { status: 'OK', echo: message };
  }
};
</code></pre>
<p><strong>Поток данных:</strong></p>
<pre><code>Client → HTTP Request → Transport Layer → Routing → Business Logic
                                                          ↓
Client ← HTTP Response ← Transport Layer ← Return Value ←
</code></pre>
<h3 id="Пример-Переключение-с-http-на-websocket"><a class="header" href="#Пример-Переключение-с-http-на-websocket">Пример: Переключение с HTTP на WebSocket</a></h3>
<p><strong>Изменение на сервере:</strong></p>
<pre><code class="language-javascript">// config.js
module.exports = {
  api: {
    transport: 'ws' // Было: 'http'
  }
};
</code></pre>
<p><strong>Изменение на клиенте:</strong></p>
<pre><code class="language-javascript">// Было:
const api = await scaffold('http://localhost:8001', structure);

// Стало:
const api = await scaffold('ws://localhost:8001', structure);
</code></pre>
<p><strong>Бизнес-логика не меняется!</strong> Вызовы остаются прежними:</p>
<pre><code class="language-javascript">await api.test.say('Hello'); // Работает с любым транспортом
</code></pre>
<hr />
<h2 id="Заключение"><a class="header" href="#Заключение">Заключение</a></h2>
<p>Применение принципов <strong>Layers</strong> и <strong>Low Coupling</strong> позволяет создавать гибкие, легко тестируемые и поддерживаемые приложения. Инъекция зависимостей через замыкания — элегантный способ снизить зацепление в JavaScript/Node.js приложениях, сохраняя при этом простоту кода.</p>
<p>В следующих лекциях мы:</p>
<ul>
<li>Перейдем на ES Modules</li>
<li>Реализуем подключаемые фреймворки</li>
<li>Добавим работу с базами данных</li>
<li>Спроектируем API для мессенджера</li>
<li>Разработаем полноценное приложение на базе созданной инфраструктуры</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../week5/контрактное-программирование-lecture-notes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../week5/adapter-pattern-lecture-notes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../week5/контрактное-программирование-lecture-notes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../week5/adapter-pattern-lecture-notes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
