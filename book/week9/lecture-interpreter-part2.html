<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Паттерн «Интерпретатор» — реализация LISP и AST (часть 2) - Patterns</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Patterns</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Паттерн-Интерпретатор--Часть-2-Реализация-lisp-и-ast-на-javascripttypescript"><a class="header" href="#Паттерн-Интерпретатор--Часть-2-Реализация-lisp-и-ast-на-javascripttypescript">Паттерн «Интерпретатор» — Часть 2: Реализация LISP и AST на JavaScript/TypeScript</a></h1>
<h2 id="Введение"><a class="header" href="#Введение">Введение</a></h2>
<p>В этой лекции мы подробно разберём реализацию LISP-интерпретатора на JavaScript и TypeScript. Будет рассмотрено три варианта реализации: классический (на классах с наследованием), упрощённый (без абстрактного класса, с коллекцией операторов) и расширенный (с поддержкой операций <code>car</code>, <code>cdr</code>, <code>list</code>, <code>eq</code>).</p>
<p>LISP — это язык, основанный на списках. Программа на LISP — это вложенные списки, где первый элемент списка является оператором, а остальные — операндами. Например:</p>
<pre><code>(+ 1 2)          ; сложение: 1 + 2 = 3
(* 2 3)          ; умножение: 2 * 3 = 6
(- 10 3)         ; вычитание: 10 - 3 = 7
(+ (* 2 3) 1)    ; вложенное: (2 * 3) + 1 = 7
(+ x y)          ; переменные из контекста
</code></pre>
<p>Интерпретатор принимает такое выражение, строит AST (Abstract Syntax Tree — абстрактное синтаксическое дерево) и вычисляет результат.</p>
<hr />
<h2 id="Реализация-lisp-интерпретатора"><a class="header" href="#Реализация-lisp-интерпретатора">Реализация LISP-интерпретатора</a></h2>
<h3 id="Архитектура"><a class="header" href="#Архитектура">Архитектура</a></h3>
<p>Интерпретатор состоит из трёх слоёв:</p>
<ol>
<li><strong>Токенизатор (Tokenizer)</strong> — разбивает строку на токены (скобки, числа, идентификаторы).</li>
<li><strong>Парсер (Parser)</strong> — преобразует плоский список токенов в дерево вложенных массивов, а затем в экземпляры классов выражений.</li>
<li><strong>Вычислитель (Evaluator)</strong> — рекурсивно обходит дерево и вычисляет значение каждого узла.</li>
</ol>
<hr />
<h2 id="ast"><a class="header" href="#ast">AST</a></h2>
<p>AST (Abstract Syntax Tree) — абстрактное синтаксическое дерево. Каждый узел дерева представляет одну синтаксическую конструкцию языка. В нашем случае узлами являются:</p>
<ul>
<li><code>NumberExpression</code> — числовой литерал;</li>
<li><code>VariableExpression</code> — ссылка на переменную из контекста;</li>
<li><code>OperationExpression</code> — список с оператором и операндами.</li>
</ul>
<p>Все узлы реализуют единый интерфейс: метод <code>interpret(context)</code>, который возвращает вычисленное значение.</p>
<pre><code>Дерево для выражения (+ (* x 2) y):

        OperationExpression(+)
       /                      \
OperationExpression(*)     VariableExpression(y)
      /        \
VariableExpression(x)   NumberExpression(2)
</code></pre>
<hr />
<h2 id="Парсер"><a class="header" href="#Парсер">Парсер</a></h2>
<h3 id="Шаг-1--Токенизатор"><a class="header" href="#Шаг-1--Токенизатор">Шаг 1 — Токенизатор</a></h3>
<p>Токенизатор принимает строку с LISP-выражением и превращает её в плоский массив токенов, а затем строит дерево вложенных массивов по скобкам.</p>
<pre><code class="language-typescript">// Тип токена: число, строка-идентификатор или вложенный список
type Token = number | string | Token[];

/**
 * Токенизирует строку LISP-программы.
 * Разделяет по пробелам и скобкам, строит дерево вложенности.
 *
 * Пример: "(+ 1 2)" =&gt; ["+", 1, 2]
 *         "(+ (* 2 3) 1)" =&gt; ["+", ["*", 2, 3], 1]
 */
function tokenize(input: string): Token[] {
  // Добавляем пробелы вокруг скобок, чтобы split работал корректно
  const tokens = input
    .replace(/\(/g, ' ( ')
    .replace(/\)/g, ' ) ')
    .trim()
    .split(/\s+/)
    .filter(Boolean);

  const stack: Token[][] = [];
  let current: Token[] = [];

  for (const token of tokens) {
    if (token === '(') {
      // Открывающая скобка: сохраняем текущий уровень в стек,
      // начинаем новый вложенный список
      stack.push(current);
      current = [];
    } else if (token === ')') {
      // Закрывающая скобка: завершаем текущий список,
      // возвращаемся к родительскому уровню
      const completed = current;
      current = stack.pop()!;
      current.push(completed);
    } else {
      // Число или идентификатор
      const num = Number(token);
      current.push(isNaN(num) ? token : num);
    }
  }

  return current[0] as Token[];
}
</code></pre>
<h3 id="Шаг-2--Узлы-ast-на-typescript-классический-подход-с-наследованием"><a class="header" href="#Шаг-2--Узлы-ast-на-typescript-классический-подход-с-наследованием">Шаг 2 — Узлы AST на TypeScript (классический подход с наследованием)</a></h3>
<pre><code class="language-typescript">// Контекст: словарь переменных
type Context = Record&lt;string, number&gt;;

/**
 * Абстрактный базовый класс для всех выражений.
 * Все наследники обязаны реализовать метод interpret.
 */
abstract class Expression {
  abstract interpret(context: Context): number | number[];
}

/**
 * Числовой литерал.
 * Пример: 42
 */
class NumberExpression extends Expression {
  constructor(private value: number) {
    super();
  }

  interpret(_context: Context): number {
    // Возвращаем хранимое значение, контекст не нужен
    return this.value;
  }
}

/**
 * Переменная из контекста.
 * Пример: x — берётся из context["x"]
 */
class VariableExpression extends Expression {
  constructor(private name: string) {
    super();
  }

  interpret(context: Context): number {
    if (!(this.name in context)) {
      throw new Error(`Переменная "${this.name}" не найдена в контексте`);
    }
    return context[this.name];
  }
}

/**
 * Выражение с оператором и операндами.
 * Пример: (+ 1 2) =&gt; оператор "+", операнды [1, 2]
 */
class OperationExpression extends Expression {
  constructor(
    private operator: string,
    private operands: Expression[]
  ) {
    super();
  }

  interpret(context: Context): number {
    // Рекурсивно вычисляем все операнды
    const values = this.operands.map((op) =&gt; op.interpret(context) as number);

    switch (this.operator) {
      case '+':
        return values.reduce((acc, v) =&gt; acc + v, 0);
      case '-':
        // Вычитаем все остальные из первого элемента
        return values.slice(1).reduce((acc, v) =&gt; acc - v, values[0]);
      case '*':
        return values.reduce((acc, v) =&gt; acc * v, 1);
      case '/':
        return values.slice(1).reduce((acc, v) =&gt; acc / v, values[0]);
      default:
        throw new Error(`Неизвестный оператор: "${this.operator}"`);
    }
  }
}
</code></pre>
<h3 id="Шаг-3--Парсер-токены--ast"><a class="header" href="#Шаг-3--Парсер-токены--ast">Шаг 3 — Парсер: токены → AST</a></h3>
<pre><code class="language-typescript">/**
 * Преобразует токены (вложенный массив) в дерево Expression-объектов.
 */
function parse(tokens: Token[]): Expression {
  if (!Array.isArray(tokens)) {
    // Атомарный токен: число или переменная
    if (typeof tokens === 'number') {
      return new NumberExpression(tokens);
    }
    return new VariableExpression(tokens as string);
  }

  // Список: первый элемент — оператор, остальные — операнды
  const [operator, ...rest] = tokens as [string, ...Token[]];
  const operands = rest.map((token) =&gt; parse(token));
  return new OperationExpression(operator, operands);
}
</code></pre>
<hr />
<h2 id="Вычислитель-evaluator"><a class="header" href="#Вычислитель-evaluator">Вычислитель (Evaluator)</a></h2>
<p>Вычислитель в классическом варианте — это просто вызов <code>interpret</code> на корневом узле AST. Контекст передаётся при вычислении и содержит значения переменных.</p>
<pre><code class="language-typescript">/**
 * Evaluator: принимает корень AST и контекст,
 * возвращает результат вычисления.
 */
class Evaluator {
  evaluate(expression: Expression, context: Context): number | number[] {
    return expression.interpret(context);
  }
}

// --- Полный пример использования ---

const source = '(+ (* x 2) y)';

// 1. Токенизируем
const tokens = tokenize(source);
// =&gt; ["+", ["*", "x", 2], "y"]

// 2. Строим AST
const ast = parse(tokens);

// 3. Вычисляем с контекстом { x: 3, y: 5 }
const evaluator = new Evaluator();
const result = evaluator.evaluate(ast, { x: 3, y: 5 });

console.log(`Результат: ${result}`); // =&gt; Результат: 11
// (3 * 2) + 5 = 6 + 5 = 11
</code></pre>
<hr />
<h2 id="Упрощённая-реализация-на-javascript-без-наследования"><a class="header" href="#Упрощённая-реализация-на-javascript-без-наследования">Упрощённая реализация на JavaScript (без наследования)</a></h2>
<p>В JavaScript нет необходимости в абстрактном классе. Вместо иерархии классов используется коллекция операторов — обычный объект-словарь. Это делает систему легко расширяемой: чтобы добавить новый оператор, достаточно добавить запись в словарь.</p>
<pre><code class="language-javascript">// Коллекция операторов: имя =&gt; функция
const operators = {
  '+': (values) =&gt; values.reduce((acc, v) =&gt; acc + v, 0),
  '-': (values) =&gt; values.slice(1).reduce((acc, v) =&gt; acc - v, values[0]),
  '*': (values) =&gt; values.reduce((acc, v) =&gt; acc * v, 1),
  '/': (values) =&gt; values.slice(1).reduce((acc, v) =&gt; acc / v, values[0]),
};

// NumberExpression — просто объект с методом interpret
class NumberExpression {
  constructor(value) {
    this.value = value;
  }
  interpret(_context) {
    return this.value;
  }
}

// VariableExpression — читает переменную из контекста
class VariableExpression {
  constructor(name) {
    this.name = name;
  }
  interpret(context) {
    if (!(this.name in context)) {
      throw new Error(`Переменная "${this.name}" не найдена в контексте`);
    }
    return context[this.name];
  }
}

// OperationExpression — использует коллекцию operators
class OperationExpression {
  constructor(operator, operands) {
    this.operator = operator;
    this.operands = operands;
  }
  interpret(context) {
    // Рекурсивно интерпретируем каждый операнд
    const values = this.operands.map((op) =&gt; op.interpret(context));
    const fn = operators[this.operator];
    if (!fn) throw new Error(`Неизвестный оператор: "${this.operator}"`);
    return fn(values);
  }
}

// Токенизатор и парсер — те же, что в TypeScript-версии (адаптированы под JS)
function tokenize(input) {
  const tokens = input
    .replace(/\(/g, ' ( ')
    .replace(/\)/g, ' ) ')
    .trim()
    .split(/\s+/)
    .filter(Boolean);

  const stack = [];
  let current = [];

  for (const token of tokens) {
    if (token === '(') {
      stack.push(current);
      current = [];
    } else if (token === ')') {
      const completed = current;
      current = stack.pop();
      current.push(completed);
    } else {
      const num = Number(token);
      current.push(isNaN(num) ? token : num);
    }
  }

  return current[0];
}

function parse(tokens) {
  if (!Array.isArray(tokens)) {
    return typeof tokens === 'number'
      ? new NumberExpression(tokens)
      : new VariableExpression(tokens);
  }
  const [operator, ...rest] = tokens;
  return new OperationExpression(operator, rest.map(parse));
}

// Расширяем коллекцию операторов без изменения движка:
operators['max'] = (values) =&gt; Math.max(...values);
operators['min'] = (values) =&gt; Math.min(...values);
</code></pre>
<hr />
<h2 id="Расширение-lisp-операции-над-списками"><a class="header" href="#Расширение-lisp-операции-над-списками">Расширение LISP: операции над списками</a></h2>
<p>LISP исторически строится вокруг операций над списками. Добавим базовые операции: <code>list</code>, <code>car</code> (голова списка), <code>cdr</code> (хвост списка), <code>eq</code> (сравнение).</p>
<pre><code class="language-javascript">// Вспомогательные функции
const isList = (x) =&gt; Array.isArray(x) &amp;&amp; x.length &gt; 0;
const car  = (lst) =&gt; isList(lst) ? lst[0] : null;       // head
const cdr  = (lst) =&gt; isList(lst) ? lst.slice(1) : null; // tail

// Расширяем коллекцию операторов списковыми операциями
const lispOperators = {
  // Арифметика
  '+': (vals) =&gt; vals.reduce((a, v) =&gt; a + v, 0),
  '-': (vals) =&gt; vals.slice(1).reduce((a, v) =&gt; a - v, vals[0]),
  '*': (vals) =&gt; vals.reduce((a, v) =&gt; a * v, 1),
  '/': (vals) =&gt; vals.slice(1).reduce((a, v) =&gt; a / v, vals[0]),

  // Конструирование списка
  // (list 7 3 1) =&gt; [7, 3, 1]
  'list': (vals) =&gt; vals,

  // Проверка равенства
  // (eq 3 3) =&gt; true
  'eq': (vals) =&gt; vals[0] === vals[1],

  // Голова списка
  // (car (list 7 3 1)) =&gt; 7
  'car': (vals) =&gt; car(vals[0]),

  // Хвост списка
  // (cdr (list 7 3 1)) =&gt; [3, 1]
  'cdr': (vals) =&gt; cdr(vals[0]),
};

// OperationExpression с поддержкой lispOperators
class LispOperationExpression {
  constructor(operator, operands) {
    this.operator = operator;
    this.operands = operands;
  }
  interpret(context) {
    const values = this.operands.map((op) =&gt; op.interpret(context));
    const fn = lispOperators[this.operator];
    if (!fn) throw new Error(`Неизвестный оператор: "${this.operator}"`);
    return fn(values);
  }
}

function parseLisp(tokens) {
  if (!Array.isArray(tokens)) {
    return typeof tokens === 'number'
      ? new NumberExpression(tokens)
      : new VariableExpression(tokens);
  }
  const [operator, ...rest] = tokens;
  return new LispOperationExpression(operator, rest.map(parseLisp));
}

// Запуск LISP-программы
function run(source, context = {}) {
  const tokens = tokenize(source);
  const ast = parseLisp(tokens);
  return ast.interpret(context);
}
</code></pre>
<hr />
<h2 id="Примеры"><a class="header" href="#Примеры">Примеры</a></h2>
<pre><code class="language-javascript">// Арифметика
console.log(run('(+ 2 5)'));           // 7
console.log(run('(* 3 4)'));           // 12
console.log(run('(- 10 3 2)'));        // 5

// Переменные из контекста
console.log(run('(+ x y)', { x: 3, y: 5 }));  // 8

// Вложенные выражения
console.log(run('(+ (* 2 3) 1)'));     // 7
console.log(run('(* (+ 1 2) (- 5 2))')); // 9

// Переменные в сложных выражениях
console.log(run('(+ (* x 2) y)', { x: 3, y: 5 })); // 11

// Операции над списками
console.log(run('(list 7 3 1)'));
// =&gt; [7, 3, 1]

console.log(run('(car (list 7 3 1))'));
// =&gt; 7

console.log(run('(cdr (list 7 3 1))'));
// =&gt; [3, 1]

console.log(run('(eq 3 3)'));
// =&gt; true

console.log(run('(eq 3 5)'));
// =&gt; false

// Добавление нового оператора без изменения движка:
lispOperators['pow'] = (vals) =&gt; Math.pow(vals[0], vals[1]);
console.log(run('(pow 2 10)'));        // 1024
</code></pre>
<hr />
<h2 id="Транслятор-lisp--javascript-концепция"><a class="header" href="#Транслятор-lisp--javascript-концепция">Транслятор LISP → JavaScript (концепция)</a></h2>
<p>Одно из практических применений AST — трансляция между языками. AST-дерево можно обойти и сгенерировать эквивалентный JavaScript-код, который затем выполняется на движке V8 с нативной скоростью.</p>
<pre><code class="language-typescript">/**
 * Транслирует AST LISP-выражения в строку JavaScript-кода.
 */
function transpileToJS(tokens: Token[]): string {
  if (!Array.isArray(tokens)) {
    // Атом: число или имя переменной
    return String(tokens);
  }

  const [operator, ...operands] = tokens as [string, ...Token[]];
  const jsOperands = operands.map(transpileToJS);

  // Арифметические операторы транслируются напрямую
  if (['+', '-', '*', '/'].includes(operator)) {
    return `(${jsOperands.join(` ${operator} `)})`;
  }

  // Для специальных операторов — вызов функций
  if (operator === 'list') {
    return `[${jsOperands.join(', ')}]`;
  }
  if (operator === 'car') {
    return `(${jsOperands[0]})[0]`;
  }
  if (operator === 'cdr') {
    return `(${jsOperands[0]}).slice(1)`;
  }

  // Неизвестный оператор — вызов функции
  return `${operator}(${jsOperands.join(', ')})`;
}

// Пример трансляции
const lisp1 = tokenize('(+ (* x 2) y)');
console.log(transpileToJS(lisp1));
// =&gt; ((x * 2) + y)

const lisp2 = tokenize('(+ 1 (* 3 4))');
console.log(transpileToJS(lisp2));
// =&gt; (1 + (3 * 4))

// Выполняем транслированный код
const code = transpileToJS(tokenize('(+ (* x 2) y)'));
const fn = new Function('x', 'y', `return ${code};`);
console.log(fn(3, 5)); // =&gt; 11
</code></pre>
<hr />
<h2 id="Полный-пример-typescript-интерпретатор"><a class="header" href="#Полный-пример-typescript-интерпретатор">Полный пример: TypeScript-интерпретатор</a></h2>
<p>Ниже приведён полный самодостаточный пример на TypeScript, объединяющий все части:</p>
<pre><code class="language-typescript">// === types ===
type Token = number | string | Token[];
type Context = Record&lt;string, number | number[]&gt;;

// === AST Nodes ===
interface Expression {
  interpret(context: Context): number | number[] | boolean;
}

class NumberExpression implements Expression {
  constructor(private value: number) {}
  interpret(_ctx: Context) { return this.value; }
}

class VariableExpression implements Expression {
  constructor(private name: string) {}
  interpret(ctx: Context) {
    if (!(this.name in ctx)) throw new Error(`Переменная не найдена: ${this.name}`);
    return ctx[this.name] as number;
  }
}

// Коллекция операторов — легко расширяется
const ops: Record&lt;string, (vals: any[]) =&gt; any&gt; = {
  '+':    (v) =&gt; v.reduce((a: number, x: number) =&gt; a + x, 0),
  '-':    (v) =&gt; v.slice(1).reduce((a: number, x: number) =&gt; a - x, v[0]),
  '*':    (v) =&gt; v.reduce((a: number, x: number) =&gt; a * x, 1),
  '/':    (v) =&gt; v.slice(1).reduce((a: number, x: number) =&gt; a / x, v[0]),
  'list': (v) =&gt; v,
  'eq':   (v) =&gt; v[0] === v[1],
  'car':  (v) =&gt; Array.isArray(v[0]) ? v[0][0] : null,
  'cdr':  (v) =&gt; Array.isArray(v[0]) ? v[0].slice(1) : null,
};

class OperationExpression implements Expression {
  constructor(
    private operator: string,
    private operands: Expression[]
  ) {}

  interpret(ctx: Context) {
    const values = this.operands.map((op) =&gt; op.interpret(ctx));
    const fn = ops[this.operator];
    if (!fn) throw new Error(`Неизвестный оператор: ${this.operator}`);
    return fn(values);
  }
}

// === Tokenizer ===
function tokenize(input: string): Token[] {
  const raw = input.replace(/\(/g, ' ( ').replace(/\)/g, ' ) ')
    .trim().split(/\s+/).filter(Boolean);
  const stack: Token[][] = [];
  let cur: Token[] = [];
  for (const t of raw) {
    if (t === '(') { stack.push(cur); cur = []; }
    else if (t === ')') { const done = cur; cur = stack.pop()!; cur.push(done); }
    else { const n = Number(t); cur.push(isNaN(n) ? t : n); }
  }
  return cur[0] as Token[];
}

// === Parser ===
function parse(tokens: Token[]): Expression {
  if (!Array.isArray(tokens)) {
    return typeof tokens === 'number'
      ? new NumberExpression(tokens)
      : new VariableExpression(tokens as string);
  }
  const [op, ...rest] = tokens as [string, ...Token[]];
  return new OperationExpression(op, rest.map(parse));
}

// === Runner ===
function run(src: string, ctx: Context = {}): any {
  return parse(tokenize(src)).interpret(ctx);
}

// === Тесты ===
console.log(run('(+ 2 5)'));                        // 7
console.log(run('(+ (* x 2) y)', { x: 3, y: 5 })); // 11
console.log(run('(list 7 3 1)'));                   // [7, 3, 1]
console.log(run('(car (list 7 3 1))'));             // 7
console.log(run('(cdr (list 7 3 1))'));             // [3, 1]
console.log(run('(eq 3 3)'));                       // true

// Добавляем оператор без изменения движка
ops['pow'] = (v) =&gt; Math.pow(v[0], v[1]);
console.log(run('(pow 2 10)'));                     // 1024
</code></pre>
<hr />
<h2 id="Итог"><a class="header" href="#Итог">Итог</a></h2>
<p>Паттерн <strong>Interpreter</strong> реализует следующие принципы:</p>
<ol>
<li><strong>Разделение ответственности</strong> — токенизатор, парсер и вычислитель независимы.</li>
<li><strong>Открытость/закрытость (OCP)</strong> — движок не меняется при добавлении новых операторов: достаточно расширить коллекцию <code>ops</code>.</li>
<li><strong>Рекурсивная структура</strong> — AST обходится рекурсивно; каждый узел умеет вычислять себя сам.</li>
<li><strong>Иммутабельность</strong> — в функциональном стиле каждая операция возвращает новое значение, не мутируя входные данные.</li>
</ol>
<h3 id="Когда-применять"><a class="header" href="#Когда-применять">Когда применять</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Ситуация</th><th>Пример</th></tr></thead><tbody>
<tr><td>DSL для конфигураций</td><td>Описание правил бизнес-логики</td></tr>
<tr><td>Распределённые вычисления</td><td>Передача выражений между сервисами</td></tr>
<tr><td>Кроссплатформенность</td><td>Портирование выражений на мобильный движок</td></tr>
<tr><td>Анализ кода</td><td>Обход AST для линтинга и трансформаций</td></tr>
<tr><td>Расширяемый синтаксис</td><td>Макросы, пользовательские операторы</td></tr>
</tbody></table>
</div>
<p>Ключевое преимущество подхода: <strong>движок интерпретатора занимает менее 100 строк</strong>, при этом сам язык можно расширять до любой сложности через коллекцию операторов — без модификации ядра.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../week9/lecture-interpreter-part1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../week10.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../week9/lecture-interpreter-part1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../week10.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
